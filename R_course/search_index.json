[["index.html", "R Cytoscape AI生信作图分析教程 Hello", " R Cytoscape AI生信作图分析教程 生信宝典 陈同 chentong_biology@163.com 2025-11-01 Hello 点击访问编译好的网页版教案 生信的作用越来越大，想学的人越来越多，不管是为了以后发展，还是为了解决眼下的问题。但生信学习不是一朝一夕就可以完成的事情，也许你可以很短时间学会一个交互式软件的操作，却不能看完程序教学视频后就直接写程序。也许你可以跟着一个测序分析流程完成操作，但不懂得背后的原理，不知道什么参数需要修改，结果可以出来，却把握不住对还是错。 学习生信从来就不是一个简单的事，需要做好持久战的心理准备。 在学习时，我们都希望由浅入深的逐步深入，不断地练习和实践，这就是为什么我们需要一本书，因为书很系统。但生信发展的历史短于计算机编程的历史，如果想要一门程序设计的入门数据，每种语言都可以找到几本。但想要一个囊括生信的书，就有些难了。本身生信跨领域，需要多学科的知识，而其内部又有不少分子，都囊括了太大，包括的少又有些隔靴搔痒的感觉。 我们当时都是零基础下自学Linux, 自学Python，自学R，自学高通量测序；这些学习经历，之前都零星地记录在博客里。现在回头去看几年前自己记录的东西，觉得好简单，而当时却费了很大的力气。这些零星的随手记，当时也只是为了自己看，到现在确实只有自己能看得懂，不便惠及更多的人。 因此我们创建了生信宝典，希望从不同的角度传播知识。这个不同有三点含义，一是形式上的不同，摒弃之前主编们单人作战想写啥就写啥，而是有组织有计划的内容聚合，提供一系列的教程，由入门到提高。二是内容的不同，不去用网上现有教程的通用数据做例子，而是拿实际生物数据，讲述如何解释生信中普遍碰到的问题，讲述如何处理自己的数据。三是立足点不同。在写作时，我们回到了当年，在回忆中用整个阶段的学习去指导当初的那个小白，从那些会了的人觉得微不足道而不会的人又迈不过的坎入手，直击痛点。知识点的收录依据不是是否炫酷，是否难，而是是否必要。如果必要，再简单，也要提及；如果不必要，再炫酷，也暂不纳入。 通过大量的生信例子、关键的注释和浓缩的语句形成下面的一系列学习教程。每一篇内容都不多，可以当做小说阅读，也可以跟着去练，反复几遍，每读一次都会有不同的收获和体会。 "],["questions.html", "1 考题 1.1 理论题 (50分) 1.2 代码题 (70分) 1.3 错误识别题 (选答)", " 1 考题 1.1 理论题 (50分) 无特殊标注的题为1分，其它为标注的分数。选答题特殊标注，若无标注，则必答。必答题不答着，不合格。 简述R,Rstudio的区别? R中如何查看函数的帮助信息? R中变量名字命名有什么需要遵守的规则? R中怎么判断一个变量的类型是数值型? scale函数对数据做了什么？ (2分) R中如何把矩阵 (matrix)转换为数据框 (data frame)? 取出矩阵中所有值都为0的行? (2分) 写程序从矩阵和数据框中提取特定列? 简述reshape2中定义的wide format和long format矩阵的区别? ggplot2绘图接受的是那种格式? (3分) ggplot2绘制热图使用的是什么函数? (2分) ggplot2绘图时fill和color的区别是? (2分) ggplot2绘图时如何调整横轴标签的旋转角度? 因矩阵中数值相差很大导致绘制出的热图颜色区分不明显时有哪几种解决方式? (3分) ggplot2绘制热图时如何自定义行或列的顺序? (3分) 箱线图怎么理解？(2分) ggplot2绘图时如何调整legend的位置? 火山图横轴和纵轴分别表示什么? PCA图怎么理解? (2分) 生存分析图怎么理解? (2分) R中安装包的方式有几种? (2分) Cytoscape输入数据最少需要几列? (2分) Cytoscape中有哪几种常用的布局算法? (3分) Cytoscape怎么给边增加箭头? (2分) Cytoscape中怎么插入柱状图? (2分) 矢量图和标量图有什么区别? (2分) 什么是Adobe Illustrator (AI)的剪切蒙版？ AI中选择工具和直接选择工具什么区别? AI中设置一组文字之间等距对齐使用哪个按钮? AI中怎么给一个组分赋予另一组分的属性，比如有1条线是2 pt 红色，如何快速的让其它线跟其属性一致? 请说出一起学习的3位小伙伴的名字。 1.2 代码题 (70分) 无特殊标注的题为3分，其它为标注的分数。选答题特殊标注，若无标注，则必答。必答题不答着，不合格。 R中写代码获得如下向量 &quot;Gene_1&quot; &quot;Gene_2&quot; &quot;Gene_3&quot; &quot;Gene_4&quot; &quot;Gene_5&quot; &quot;Gene_6&quot; &quot;Gene_7&quot; &quot;Gene_8&quot; R中运行4+1:3和(4+1):3得到的结果分别是什么? 为什么? 在R中运行以下代码得到的数据框的列名字是什么? text=&quot;ID;2 cell;4 cell;8 cell;embryo Pou5f1_1;2;3;4;5 Nanog_1;2;3.2;4.3;5 c-Myc_2;2;3;4;5 Tet1_3;2;3;4;5&quot; read.table(text=text,sep=&quot;;&quot;, header=T, row.names=1) 题(3)中的矩阵转换为如下格式需要怎么操作? (5分) embryo variable value 1 5 X2.cell 2.0 2 5 X2.cell 2.0 3 5 X2.cell 2.0 4 5 X2.cell 2.0 5 5 X4.cell 3.0 6 5 X4.cell 3.2 7 5 X4.cell 3.0 8 5 X4.cell 3.0 9 5 X8.cell 4.0 10 5 X8.cell 4.3 11 5 X8.cell 4.0 12 5 X8.cell 4.0 R中写程序把题(3)中的矩阵按照每行数字变化幅度由大到小排序。 写代码利用题(3)的数据绘制热图。 写代码利用题(3)的数据绘制线图，展示基因在不同样品表达变化趋势。 写代码利用如下数据绘制3个集合的韦恩图。 list1 = sample(letters,20) list2 = sample(letters,18) list3 = sample(letters,25) 写代码绘制富集分析泡泡图 (最主要的是排序, 先按ontology排序，再按log_odds_ratio，再按-log10(qvalue))。(5分) Ontology Term Count log_odds_ratio qvalue biological_process one-carbon metabolic process 34 1.012 0.001 biological_process single-organism process 5781 0.070 8.140 biological_process single-organism cellular process 4988 0.060 0.002 biological_process cell communication 2169 0.100 0.007 biological_process signal transduction 1955 0.107 0.006 biological_process signaling 2100 0.102 0.006 biological_process single organism signaling 2100 0.102 0.006 biological_process response to stimulus 3251 0.074 0.012 molecular_function protein binding 3299 0.101 3.321 cellular_component cytoplasm 4711 0.065 0.001 cellular_component Golgi apparatus 611 0.171 0.057 cellular_component endomembrane system 1521 0.146 0.000 cellular_component cytoplasmic part 3314 0.067 0.037 cellular_component cell periphery 2059 0.086 0.065 写代码用题(3)的矩阵绘制堆积柱状图，展示样品中不同基因表达的相对高低。(5分) 如下数据绘制火山图，横轴为logFoldChange，纵轴为-log10(qvalue)。(5分) log2fc &lt;- rnorm(5000, mean=0, sd=10) qvalue &lt;- 10^(-1* abs(log2fc)) data &lt;- data.frame(log2fc=log2fc, qvalue=qvalue) 描述Cytoscape网络数据和节点数据输入格式。 Cytoscape中如何设置节点形状？ Cytoscape中如何将节点数值性数据映射到节点的颜色？ Cytoscape中如何设置边的线形？ 描述Cytoscape绘制miRNA-gene调控网络过程? 描述Cytoscape使用Bingo进行功能富集分析的步骤? 描述Cytoscape使用KeggParser如何导入一个通路，并映射表达量? (5分) 如何使用最新的Cytoscape直接获得关注的基因的调控网络? 选择2种上面绘制的图利用Adobe Illustrator编辑。 1.3 错误识别题 (选答) 请辨识以下错误可能的原因是： read.table: Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : No 11 elements in the first line. read.table: duplicate ‘row.name’ are not allowed "],["Rbasic.html", "2 R基础 2.1 R安装 2.2 Rstudio基础 2.3 R基本语法 2.4 检查并安装本教程需要的 R 包 2.5 ggplot2绘图 2.6 CheetSheets 2.7 参考 {ref01}", " 2 R基础 R语言是比较常用的统计分析和绘图语言，拥有强大的统计库、绘图库和生信分析的Bioconductor库，是学习生物信息分析的必备语言之一。 2.1 R安装 Linux下安装 如果使用的是新版的操作系统。直接可以用sudo apt-get install r-base 或者yum install r-base来安装。 若系统版本老，或没有根用户权限，则需要下载编译源码安装，最新地址为https://cran.r-project.org/src/base/R-latest.tar.gz。 具体编译方式为 (Linux下软件安装见 http://blog.genesino.com/2016/06/bash1): # configure是收集系统信息，生成Makefile的过程 # --enable-R-shlib 需要设置，使得其他程序包括Rstudio可以使用R的动态库 # --prefix指定软件安装目录，需使用绝对路径 ./configure --prefix=/home/ysx/R/4.0.2 --enable-R-shlib # 也可以使用这个命令，共享系统的blas库，提高运输速度 #./configure --prefix=/home/ysx/R/4.0.2 --enable-R-shlib --with-blas --with-lapack # make是编译的过程 make # 安装到指定目录的过程 make install 安装完成之后，在Linux终端输入R即可启动交互式运行界面，ctrl+d退出R运行界面。若提示找不到命令，需要判断有没有加入进环境变量。 Windows下安装 下载 https://cran.r-project.org/bin/windows/双击就可以了。 两者都需要考虑环境变量，若有问题，见文后的参考。 2.2 Rstudio基础 Rstudio是编辑、运行R语言的最为理想的工具之一，支持纯R脚本、Rmarkdown (脚本文档混排)、Bookdown (脚本文档混排成书)、Shiny (交互式网络应用)等。 2.2.1 Rstudio版本 Rsdutio分为桌面版和服务器版，桌面版可以在单机使用，服务器版可以从浏览器访问供多人使用。 服务器版安装好之后，访问地址为 (8787为默认端口号)，用户名和密码为Linux用户的用户名和密码。 2.2.2 Rstudio安装 Linux下安装服务器版 安装参考 https://www.rstudio.com/products/rstudio/download-server/ # 自己根据自己安装时间自己去获取最新软件的下载地址 wget -c https://download2.rstudio.org/server/centos6/x86_64/rstudio-server-rhel-1.3.1073-x86_64.rpm sudo yum install --nogpgcheck rstudio-server-rhel-1.3.1073-x86_64.rpm 安装完之后的检测、启动和配置 sudo rstudio-server verify-installation #查看是否安装正确 sudo rstudio-server start ## 启动 sudo rstudio-server status ## 查看状态 sudo rstudio-server stop ## 停止 ifconfig | grep &#39;inet addr&#39; ## 查看服务端ip地址 sudo rstudio-server start ## 修改配置文件后重启 sudo rstudio-server active-sessions ## 列出活跃的sessions: sudo rstudio-server suspend-session &lt;pid&gt; ## 暂停session sudo rstudio-server suspend-all ##暂停所有session 如果启动失败，进入Rstudio日志目录查看错误信息：/var/log/rstudio-server/ Rstudio的其它配置可在配置文件修改： /etc/rstudio/rserver.conf www-port=8787 (default) www-address=0.0.0.0 (default) rsession-ld-library-path=/opt/local/lib:/opt/local/someapp/lib rsession-which-r=/usr/local/bin/R /etc/rstudio/rsession.conf Timeout [user] session-timeout-minutes=30 [@powerusers] session-timeout-minutes=0 配置好并且rstudio-server成功启动后，就可以在火狐或谷歌浏览器中输入IP地址:端口号，比如127.123,34.29:8787进行访问了。 如果该网址不能打开，一般有2个原因： 安装rstudio-server的服务器是内网IP，不可以在外网访问，只能被连接到同一台路由器的电脑访问。这时需要配置外网IP或百度查找下其它IP穿透方式的设置。 确定自己的服务器没有被防火墙限制端口，一般在学校或科研单位会设置防火墙屏蔽大部分端口，这时联系网络管理员开通相应的端口即可。 Windows下安装桌面版 下载之后 (https://www.rstudio.com/products/rstudio/download2/)双击安装 (若windows登录名为中文，需要使用管理员权限)，其它无需要注意的。 2.2.3 Rstudio 使用 Windows下桌面版直接双击打开即可使用，Linux服务器版访问地址为服务器IP:8787，用户名和密码为Linux用户的用户名和密码。 2.2.3.1 Rstudio 界面 2.2.3.2 Rstudio中新建或打开文件 如果是桌面版，直接就可以访问”我的电脑”去打开之前写过的脚本。如果是服务器版，可直接访问服务器上写过的脚本。Rstudio右下1/4部分可以切换目录，点击more，设置工作目录。可以上传本地的脚本到对应目录打开。 2.3 R基本语法 knitr::include_graphics(&quot;images/R_basic.jpg&quot;) 2.3.1 获取帮助文档，查看命令或函数的使用方法、事例或适用范围 &gt;&gt;&gt; ?command &gt;&gt;&gt; ??command #深度搜索或模糊搜索此命令 &gt;&gt;&gt; example(command) #得到命令的例子 &gt;&gt;&gt; example(plot) 2.3.2 R中的变量及其初始化 # 数字变量 a &lt;- 10 a ## [1] 10 # 字符串变量 a &lt;- &quot;abc&quot; a ## [1] &quot;abc&quot; # 逻辑变量 a &lt;- TRUE a ## [1] TRUE b &lt;- T b ## [1] TRUE d &lt;- FALSE d ## [1] FALSE # 向量 a &lt;- vector(mode=&quot;logical&quot;, length=5) a ## [1] FALSE FALSE FALSE FALSE FALSE a &lt;- c(1,2,3,4) # 判断一个变量是不是vector is.vector(a) ## [1] TRUE a &lt;- list(element1=c(1,2,3,4), element2=1:5) a ## $element1 ## [1] 1 2 3 4 ## ## $element2 ## [1] 1 2 3 4 5 # 矩阵 a &lt;- matrix(1:20,nrow=5,ncol=4,byrow=T) a ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 ## [4,] 13 14 15 16 ## [5,] 17 18 19 20 is.matrix(a) ## [1] TRUE dim(a) #查看或设置数组的维度向量 ## [1] 5 4 # 错误的用法 # dim(a) &lt;- c(4,4) # 正确的用法 a &lt;- 1:20 dim(a) &lt;- c(5,4) #转换向量为矩阵 a ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 print(paste(&quot;矩阵a的行数&quot;, nrow(a))) ## [1] &quot;矩阵a的行数 5&quot; print(paste(&quot;矩阵a的列数&quot;, ncol(a))) ## [1] &quot;矩阵a的列数 4&quot; #查看或设置行列名 rownames(a) ## NULL rownames(a) &lt;- c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;) a ## [,1] [,2] [,3] [,4] ## a 1 6 11 16 ## b 2 7 12 17 ## c 3 8 13 18 ## d 4 9 14 19 ## e 5 10 15 20 # R中获取一系列的字母 letters[1:4] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; colnames(a) &lt;- letters[1:4] a ## a b c d ## a 1 6 11 16 ## b 2 7 12 17 ## c 3 8 13 18 ## d 4 9 14 19 ## e 5 10 15 20 2.3.3 变量类型和转换 不同的变量类型有不同的操作方式，is系列和as系列函数用来判断变量的属性和转换变量的属性 is.character(a) ## [1] FALSE is.numeric(a) ## [1] TRUE is.matrix(a) ## [1] TRUE is.data.frame(a) ## [1] FALSE is.data.frame(as.data.frame(a)) ## [1] TRUE 2.3.4 R中矩阵运算 # 获得随机的正态分布数据 # random generation for the normal distribution with mean equal to ‘mean’ # and standard deviation equal to ‘sd’. rnorm(10, mean = 0, sd = 1) # 正态分布的随机数 ## [1] 0.52712467 -0.10475994 -0.09139129 -0.41669693 0.18459219 -0.40894546 ## [7] 2.48039595 0.23856780 0.99240288 0.12540542 # 获得随机的均匀分布的数据 # random generation for the uniform distribution with mean equal to ‘mean’ # and standard deviation equal to ‘sd’. runif(10, min = 0, max = 1) # 平均分布的随机数 ## [1] 0.597723095 0.892481028 0.191395164 0.620892942 0.561990018 0.754794815 ## [7] 0.913468442 0.005828207 0.908370379 0.220653976 rep(1,5) # 把1重复5次 ## [1] 1 1 1 1 1 scale(1:5) # 标准化数据 ## [,1] ## [1,] -1.2649111 ## [2,] -0.6324555 ## [3,] 0.0000000 ## [4,] 0.6324555 ## [5,] 1.2649111 ## attr(,&quot;scaled:center&quot;) ## [1] 3 ## attr(,&quot;scaled:scale&quot;) ## [1] 1.581139 scale默认操作对等于 # 标准化数据 a &lt;- 1:5 (a - mean(a)) / sd(a) ## [1] -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 a &lt;- c(rnorm(5), rnorm(5,1), runif(5), runif(5,-1,1), 1:5, rep(0,5), c(2,10,11,13,4), scale(1:5)[1:5]) a ## [1] -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 1.2549925 ## [7] 0.8959074 0.8356582 1.0059939 -0.5865703 0.7674368 0.1619154 ## [13] 0.3920250 0.1162514 0.4566943 -0.7023189 -0.3025084 0.9406374 ## [19] -0.5611974 0.9154688 1.0000000 2.0000000 3.0000000 4.0000000 ## [25] 5.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [31] 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 -1.2649111 ## [37] -0.6324555 0.0000000 0.6324555 1.2649111 # ncol=5 5列 # byrow=T: 先填充行 a &lt;- matrix(a, ncol=5, byrow=T) a ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 ## [2,] 1.2549925 0.8959074 0.8356582 1.0059939 -0.5865703 ## [3,] 0.7674368 0.1619154 0.3920250 0.1162514 0.4566943 ## [4,] -0.7023189 -0.3025084 0.9406374 -0.5611974 0.9154688 ## [5,] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 ## [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [7,] 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 ## [8,] -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 # 按行加和 rowSums(a) ## [1] -4.520619e+00 3.405982e+00 1.894323e+00 2.900814e-01 1.500000e+01 ## [6] 0.000000e+00 4.000000e+01 2.220446e-16 # 注意检查括号的配对 #a &lt;- a[rowSums(abs(a)!=0,] #错误: 意外的&#39;]&#39; in &quot;a &lt;- a[rowSums(abs(a)!=0,]&quot; # 去除全部为0的行 a &lt;- a[rowSums(abs(a))!=0,] # 另外一种方式去除全部为0的行 #a[rowSums(a==0)&lt;ncol(a),] a ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 ## [2,] 1.2549925 0.8959074 0.8356582 1.0059939 -0.5865703 ## [3,] 0.7674368 0.1619154 0.3920250 0.1162514 0.4566943 ## [4,] -0.7023189 -0.3025084 0.9406374 -0.5611974 0.9154688 ## [5,] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 ## [6,] 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 ## [7,] -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 矩阵运算，R默认针对整个数据进行常见运算 #所有值都乘以2 a * 2 ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.4276551 -5.8445403 -1.348966 -2.8011560 1.3810801 ## [2,] 2.5099850 1.7918148 1.671316 2.0119878 -1.1731406 ## [3,] 1.5348737 0.3238308 0.784050 0.2325029 0.9133886 ## [4,] -1.4046379 -0.6050169 1.881275 -1.1223949 1.8309376 ## [5,] 2.0000000 4.0000000 6.000000 8.0000000 10.0000000 ## [6,] 4.0000000 20.0000000 22.000000 26.0000000 8.0000000 ## [7,] -2.5298221 -1.2649111 0.000000 1.2649111 2.5298221 # 所有值取绝对值，再取对数 （取对数前一般加一个数避免对0或负值取对数） log2(abs(a)+1) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.2795635 1.9716889 0.7437158 1.2633818 0.7574842 ## [2,] 1.1731226 0.9228885 0.8762975 1.0043172 0.6659114 ## [3,] 0.8216587 0.2165050 0.4771851 0.1586620 0.5426982 ## [4,] 0.7675014 0.3812927 0.9565306 0.6426530 0.9376975 ## [5,] 1.0000000 1.5849625 2.0000000 2.3219281 2.5849625 ## [6,] 1.5849625 3.4594316 3.5849625 3.8073549 2.3219281 ## [7,] 1.1794544 0.7070437 0.0000000 0.7070437 1.1794544 # 取出最大值、最小值、行数、列数 max(a) ## [1] 13 min(a) ## [1] -2.92227 nrow(a) ## [1] 7 ncol(a) ## [1] 5 #增加一列或一行 #cbind: column bind cbind(a, 1:7) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 1 ## [2,] 1.2549925 0.8959074 0.8356582 1.0059939 -0.5865703 2 ## [3,] 0.7674368 0.1619154 0.3920250 0.1162514 0.4566943 3 ## [4,] -0.7023189 -0.3025084 0.9406374 -0.5611974 0.9154688 4 ## [5,] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 5 ## [6,] 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 6 ## [7,] -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 7 # rbind: row bind rbind(a,1:5) ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 ## [2,] 1.2549925 0.8959074 0.8356582 1.0059939 -0.5865703 ## [3,] 0.7674368 0.1619154 0.3920250 0.1162514 0.4566943 ## [4,] -0.7023189 -0.3025084 0.9406374 -0.5611974 0.9154688 ## [5,] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 ## [6,] 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 ## [7,] -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 ## [8,] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 # 计算每一行的var (方差) # apply表示对数据（第一个参数）的每一行 (第二个参数赋值为1) 或每一列 (2)操作 # 最后返回一个列表 apply(a,1,var) ## [1] 1.84789449 0.52798175 0.06831292 0.65143955 2.50000000 22.50000000 ## [7] 1.00000000 # 计算每一行的mad (中值绝对偏差) # 一般认为比方差的鲁棒性更强，更少受异常值的影响，更能反映数据间的差异) # 函数中的第二个参数 1 表示安行操作 apply(a,1,mad) ## [1] 1.0765083 0.1632143 0.3411605 0.5927590 1.4826000 4.4478000 0.9376786 # 计算每一列的平均值 apply(a,2,mean) ## [1] 0.4059103 1.3143698 2.2134054 2.3989893 1.6772920 # 取出中值绝对偏差大于0.5的行 b = a[apply(a,1,mad)&gt;0.5,] b ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 ## [2,] -0.7023189 -0.3025084 0.9406374 -0.5611974 0.9154688 ## [3,] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 ## [4,] 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 ## [5,] -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 # 输出 1 4 2 3 5 # 解释：原列表第一个元素显示在第一位 # 原列表第四个元素显示在第二位 # 原列表第二个元素显示在第三位 order(c(1,3,4,2,5)) ## [1] 1 4 2 3 5 # 产生新的顺序 # order(apply(b,1,mad), decreasing=T) ## [1] 4 3 1 5 2 # 矩阵按照mad的大小降序排列 c = b[order(apply(b,1,mad), decreasing=T),] c ## [,1] [,2] [,3] [,4] [,5] ## [1,] 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 ## [2,] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 ## [3,] -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 ## [4,] -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 ## [5,] -0.7023189 -0.3025084 0.9406374 -0.5611974 0.9154688 rownames(c) &lt;- paste(&#39;Gene&#39;, letters[1:nrow(c)], sep=&quot;_&quot;) colnames(c) &lt;- toupper(letters[1:ncol(c)]) c ## A B C D E ## Gene_a 2.0000000 10.0000000 11.0000000 13.0000000 4.0000000 ## Gene_b 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 ## Gene_c -0.2138275 -2.9222701 -0.6744831 -1.4005780 0.6905400 ## Gene_d -1.2649111 -0.6324555 0.0000000 0.6324555 1.2649111 ## Gene_e -0.7023189 -0.3025084 0.9406374 -0.5611974 0.9154688 # 矩阵转置 expr = t(c) expr ## Gene_a Gene_b Gene_c Gene_d Gene_e ## A 2 1 -0.2138275 -1.2649111 -0.7023189 ## B 10 2 -2.9222701 -0.6324555 -0.3025084 ## C 11 3 -0.6744831 0.0000000 0.9406374 ## D 13 4 -1.4005780 0.6324555 -0.5611974 ## E 4 5 0.6905400 1.2649111 0.9154688 # 矩阵值的替换 expr2 = expr expr2[expr2&lt;0] = 0 expr2 ## Gene_a Gene_b Gene_c Gene_d Gene_e ## A 2 1 0.00000 0.0000000 0.0000000 ## B 10 2 0.00000 0.0000000 0.0000000 ## C 11 3 0.00000 0.0000000 0.9406374 ## D 13 4 0.00000 0.6324555 0.0000000 ## E 4 5 0.69054 1.2649111 0.9154688 # 矩阵中只针对某一列替换 # expr2是个矩阵不是数据框，不能使用列名字索引 # expr2[expr2$Gene_b&lt;1, &quot;Gene_b&quot;] &lt;- 1 # str是一个最为常用、好用的查看变量信息的工具，尤其是对特别复杂的变量， # 可以看清其层级结构，便于提取数据 str(expr2) ## num [1:5, 1:5] 2 10 11 13 4 1 2 3 4 5 ... ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:5] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## ..$ : chr [1:5] &quot;Gene_a&quot; &quot;Gene_b&quot; &quot;Gene_c&quot; &quot;Gene_d&quot; ... # 转换为数据框，再进行相应的操作 expr2 &lt;- as.data.frame(expr2) str(expr2) ## &#39;data.frame&#39;: 5 obs. of 5 variables: ## $ Gene_a: num 2 10 11 13 4 ## $ Gene_b: num 1 2 3 4 5 ## $ Gene_c: num 0 0 0 0 0.691 ## $ Gene_d: num 0 0 0 0.632 1.265 ## $ Gene_e: num 0 0 0.941 0 0.915 expr2[expr2$Gene_b&lt;1, &quot;Gene_b&quot;] &lt;- 1 expr2 ## Gene_a Gene_b Gene_c Gene_d Gene_e ## A 2 1 0.00000 0.0000000 0.0000000 ## B 10 2 0.00000 0.0000000 0.0000000 ## C 11 3 0.00000 0.0000000 0.9406374 ## D 13 4 0.00000 0.6324555 0.0000000 ## E 4 5 0.69054 1.2649111 0.9154688 2.3.5 R中矩阵筛选合并 # 读入样品信息 sampleInfo = &quot;Samp;Group;Genotype A;Control;WT B;Control;WT D;Treatment;Mutant C;Treatment;Mutant E;Treatment;WT F;Treatment;WT&quot; phenoData = read.table(text=sampleInfo,sep=&quot;;&quot;, header=T, row.names=1, quote=&quot;&quot;) phenoData ## Group Genotype ## A Control WT ## B Control WT ## D Treatment Mutant ## C Treatment Mutant ## E Treatment WT ## F Treatment WT # 把样品信息按照基因表达矩阵中的样品信息排序，并只保留有基因表达信息的样品 # ‘%in%’ is a more intuitive interface as a binary operator, which # returns a logical vector indicating if there is a match or not for # its left operand. phenoData = phenoData[rownames(phenoData) %in% rownames(expr),] phenoData ## Group Genotype ## A Control WT ## B Control WT ## D Treatment Mutant ## C Treatment Mutant ## E Treatment WT # 合并矩阵 # by=0 表示按照行的名字排序 # by=columnname 表示按照共有的某一列合并 # 合并后多出了新的一列Row.names merge_data = merge(expr, phenoData, by=0, all.x=T) merge_data ## Row.names Gene_a Gene_b Gene_c Gene_d Gene_e Group Genotype ## 1 A 2 1 -0.2138275 -1.2649111 -0.7023189 Control WT ## 2 B 10 2 -2.9222701 -0.6324555 -0.3025084 Control WT ## 3 C 11 3 -0.6744831 0.0000000 0.9406374 Treatment Mutant ## 4 D 13 4 -1.4005780 0.6324555 -0.5611974 Treatment Mutant ## 5 E 4 5 0.6905400 1.2649111 0.9154688 Treatment WT rownames(merge_data) &lt;- merge_data$Row.names merge_data ## Row.names Gene_a Gene_b Gene_c Gene_d Gene_e Group Genotype ## A A 2 1 -0.2138275 -1.2649111 -0.7023189 Control WT ## B B 10 2 -2.9222701 -0.6324555 -0.3025084 Control WT ## C C 11 3 -0.6744831 0.0000000 0.9406374 Treatment Mutant ## D D 13 4 -1.4005780 0.6324555 -0.5611974 Treatment Mutant ## E E 4 5 0.6905400 1.2649111 0.9154688 Treatment WT # 去除一列；-1表示去除第一列 merge_data = merge_data[,-1] merge_data ## Gene_a Gene_b Gene_c Gene_d Gene_e Group Genotype ## A 2 1 -0.2138275 -1.2649111 -0.7023189 Control WT ## B 10 2 -2.9222701 -0.6324555 -0.3025084 Control WT ## C 11 3 -0.6744831 0.0000000 0.9406374 Treatment Mutant ## D 13 4 -1.4005780 0.6324555 -0.5611974 Treatment Mutant ## E 4 5 0.6905400 1.2649111 0.9154688 Treatment WT # 提取出所有的数值列 merge_data[sapply(merge_data, is.numeric)] ## Gene_a Gene_b Gene_c Gene_d Gene_e ## A 2 1 -0.2138275 -1.2649111 -0.7023189 ## B 10 2 -2.9222701 -0.6324555 -0.3025084 ## C 11 3 -0.6744831 0.0000000 0.9406374 ## D 13 4 -1.4005780 0.6324555 -0.5611974 ## E 4 5 0.6905400 1.2649111 0.9154688 2.3.6 str的应用 str: Compactly display the internal structure of an R object, a diagnostic function and an alternative to ‘summary (and to some extent, ’dput’). Ideally, only one line for each ‘basic’ structure is displayed. It is especially well suited to compactly display the (abbreviated) contents of (possibly nested) lists. The idea is to give reasonable output for any R object. It calls ‘args’ for (non-primitive) function objects. str用来告诉结果的构成方式，对于不少Bioconductor的包，或者复杂的R函数的输出，都是一堆列表的嵌套，str(complex_result)会输出每个列表的名字，方便提取对应的信息。 # str的一个应用例子 str(list(a = &quot;A&quot;, L = as.list(1:100)), list.len = 9) ## List of 2 ## $ a: chr &quot;A&quot; ## $ L:List of 100 ## ..$ : int 1 ## ..$ : int 2 ## ..$ : int 3 ## ..$ : int 4 ## ..$ : int 5 ## ..$ : int 6 ## ..$ : int 7 ## ..$ : int 8 ## ..$ : int 9 ## .. [list output truncated] 利用str查看pca的结果，具体的PCA应用查看 http://mp.weixin.qq.com/s/sRElBMkyR9rGa4TQp9KjNQ。 pca_result &lt;- prcomp(expr) pca_result ## Standard deviations (1, .., p=5): ## [1] 4.842700e+00 2.060965e+00 7.007376e-01 5.558627e-01 7.775454e-17 ## ## Rotation (n x k) = (5 x 5): ## PC1 PC2 PC3 PC4 PC5 ## Gene_a 0.9791016897 0.003788981 0.1719731 -0.10849318 0.000000e+00 ## Gene_b 0.0782878704 -0.731231501 -0.4159160 0.02170449 -5.345225e-01 ## Gene_c -0.1810480386 -0.420752292 0.6755017 -0.57782918 1.010029e-16 ## Gene_d 0.0495135967 -0.462471408 -0.2630484 0.01372713 8.451543e-01 ## Gene_e -0.0009497244 -0.272715676 0.5214807 0.80850674 -8.829184e-16 str(pca_result) ## List of 5 ## $ sdev : num [1:5] 4.84 2.06 7.01e-01 5.56e-01 7.78e-17 ## $ rotation: num [1:5, 1:5] 0.9791 0.07829 -0.18105 0.04951 -0.00095 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:5] &quot;Gene_a&quot; &quot;Gene_b&quot; &quot;Gene_c&quot; &quot;Gene_d&quot; ... ## .. ..$ : chr [1:5] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ... ## $ center : Named num [1:5] 8.00 3.00 -9.04e-01 4.44e-17 5.80e-02 ## ..- attr(*, &quot;names&quot;)= chr [1:5] &quot;Gene_a&quot; &quot;Gene_b&quot; &quot;Gene_c&quot; &quot;Gene_d&quot; ... ## $ scale : logi FALSE ## $ x : num [1:5, 1:5] -6.22 2.21 2.89 5.1 -3.99 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:5] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## .. ..$ : chr [1:5] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;prcomp&quot; # 取出每个主成分解释的差异 pca_result$sdev ## [1] 4.842700e+00 2.060965e+00 7.007376e-01 5.558627e-01 7.775454e-17 2.3.7 R的包管理 什么时候需要安装包 library(&#39;unExistedPackage&#39;) Error in library(&quot;unExistedPackage&quot;) : 不存在叫‘unExistedPackage’这个名字的程辑包 如何安装R包 install.packages(&quot;package_name&quot;) # 指定安装来源 install.packages(&quot;package_name&quot;, repo=&quot;http://cran.us.r-project.org&quot;) # 安装Bioconductor的包 if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;, update = F) BiocManager::install(c(&quot;RUVSeq&quot;,&quot;pcaMethods&quot;)) # 安装Github的R包 install.packages(&quot;devtools&quot;) devtools::install_github(&quot;JustinaZ/pcaReduce&quot;) # 手动安装, 首先下载包的源文件（压缩版就可），然后在终端运行下面的命令。 ct@ysx:~$ R CMD INSTALL package.tar.gz # 移除包 remove.packages(&quot;package_name&quot;) # 查看所有安装的包 library() # 查看特定安装包的版本 installed.packages()[c(&quot;ggplot2&quot;), c(&quot;Package&quot;, &quot;Version&quot;)] # Package Version # &quot;ggplot2&quot; &quot;3.3.2&quot; # 查看默认安装包的位置 .libPaths() # 查看已加载的包 .packages() # 调用安装的包 library(package_name) 自动安装包 usePackage &lt;- function(p) { if (!requireNamespace(p, quietly = TRUE)) BiocManager::install(p, update = F) require(p, character.only = TRUE) } 2.4 检查并安装本教程需要的 R 包 site = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN&quot; # options(BioC_mirror = &quot;https://mirrors.tuna.tsinghua.edu.cn/bioconductor&quot;) options(BioC_mirror=&quot;https://mirrors.westlake.edu.cn/bioconductor&quot;) if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;, repos = site) a = rownames(installed.packages()) install_bioc &lt;- c( &quot;amap&quot;, &quot;BiocParallel&quot;, &quot;cowplot&quot;, &quot;data.table&quot;, &quot;dendextend&quot;, &quot;DESeq2&quot;, &quot;dplyr&quot;, &quot;ggfortify&quot;, &quot;ggplot2&quot;, &quot;ggpubr&quot;, &quot;ggrepel&quot;, &quot;ggstatsplot&quot;, &quot;ggthemes&quot;, &quot;gplots&quot;, &quot;grid&quot;, &quot;gridExtra&quot;, &quot;Hmisc&quot;, &quot;knitr&quot;, &quot;limma&quot;, &quot;patchwork&quot;, &quot;pheatmap&quot;, &quot;plyr &quot;, &quot;psych&quot;, &quot;RColorBrewer&quot;, &quot;reshape2&quot;, &quot;scatterplot3d&quot;, &quot;showtext&quot;, &quot;stringr&quot;, &quot;survival&quot;, &quot;survminer&quot;, &quot;sva&quot;, &quot;tidyr&quot;, &quot;tidyverse&quot;, &quot;UpSetR&quot;, &quot;useful&quot;, &quot;VennDiagram&quot; ) for (i in install_bioc) { if (!i %in% a) BiocManager::install(i) } ## &#39;getOption(&quot;repos&quot;)&#39; replaces Bioconductor standard repositories, see ## &#39;help(&quot;repositories&quot;, package = &quot;BiocManager&quot;)&#39; for details. ## Replacement repositories: ## CRAN: https://cran.rstudio.com/ ## Bioconductor version 3.20 (BiocManager 1.30.26), R 4.4.2 (2024-10-31) ## Installing package(s) &#39;plyr &#39; ## Old packages: &#39;DOSE&#39;, &#39;edgeR&#39;, &#39;fgsea&#39;, &#39;GenomeInfoDb&#39;, &#39;gert&#39;, &#39;ggbeeswarm&#39;, ## &#39;ggsci&#39;, &#39;igraph&#39;, &#39;IRanges&#39;, &#39;lava&#39;, &#39;limma&#39;, &#39;microeco&#39;, &#39;multcomp&#39;, ## &#39;parallelly&#39;, &#39;promises&#39;, &#39;reformulas&#39;, &#39;reticulate&#39;, &#39;rvest&#39;, &#39;vroom&#39;, ## &#39;xfun&#39;, &#39;xml2&#39; ## &#39;getOption(&quot;repos&quot;)&#39; replaces Bioconductor standard repositories, see ## &#39;help(&quot;repositories&quot;, package = &quot;BiocManager&quot;)&#39; for details. ## Replacement repositories: ## CRAN: https://cran.rstudio.com/ ## Bioconductor version 3.20 (BiocManager 1.30.26), R 4.4.2 (2024-10-31) ## Installing package(s) &#39;showtext&#39; ## also installing the dependencies &#39;sysfonts&#39;, &#39;showtextdb&#39; ## ## The downloaded binary packages are in ## /var/folders/_b/tnc424qj6g9f8xvfhmvdr0h00000gn/T//RtmpWuDZJM/downloaded_packages ## Old packages: &#39;DOSE&#39;, &#39;edgeR&#39;, &#39;fgsea&#39;, &#39;GenomeInfoDb&#39;, &#39;gert&#39;, &#39;ggbeeswarm&#39;, ## &#39;ggsci&#39;, &#39;igraph&#39;, &#39;IRanges&#39;, &#39;lava&#39;, &#39;limma&#39;, &#39;microeco&#39;, &#39;multcomp&#39;, ## &#39;parallelly&#39;, &#39;promises&#39;, &#39;reformulas&#39;, &#39;reticulate&#39;, &#39;rvest&#39;, &#39;vroom&#39;, ## &#39;xfun&#39;, &#39;xml2&#39; installed_packages = installed.packages() if (!&quot;ggbeeswarm&quot; %in% a){ install.packages(&quot;https://cran.r-project.org/src/contrib/Archive/ggbeeswarm/ggbeeswarm_0.6.0.tar.gz&quot;, repos = NULL, type = &quot;source&quot;) } else { if (installed_packages[&quot;ggbeeswarm&quot;,&quot;Version&quot;] != &quot;0.6.0&quot;) { install.packages(&quot;https://cran.r-project.org/src/contrib/Archive/ggbeeswarm/ggbeeswarm_0.6.0.tar.gz&quot;, repos = NULL, type = &quot;source&quot;) } } if (!&quot;ImageGP&quot; %in% a) { # devtools::install_github(&quot;Tong-Chen/ImageGP&quot;) devtools::install_git(&quot;https://gitee.com/ct5869/ImageGP.git&quot;) } 2.5 ggplot2绘图 data &lt;- &quot;Gene;Sample;Group;Abundance Gene1;KO1;KO;1.2 Gene2;KO1;KO;1.4 Gene3;KO1;KO;16 Gene4;KO1;KO;10 Gene5;KO1;KO;25 Gene6;KO1;KO;30 Gene7;KO1;KO;2 Gene8;KO1;KO;3 Gene1;KO2;KO;1.2 Gene2;KO2;KO;1.4 Gene3;KO2;KO;16 Gene4;KO2;KO;10 Gene5;KO2;KO;25 Gene6;KO2;KO;30 Gene7;KO2;KO;2 Gene8;KO2;KO;3 Gene1;KO3;KO;1.2 Gene2;KO3;KO;1.4 Gene3;KO3;KO;16 Gene4;KO3;KO;10 Gene5;KO3;KO;25 Gene6;KO3;KO;30 Gene7;KO3;KO;2 Gene8;KO3;KO;3 Gene8;WT1;WT;1.2 Gene7;WT1;WT;1.4 Gene6;WT1;WT;16 Gene5;WT1;WT;10 Gene4;WT1;WT;25 Gene3;WT1;WT;30 Gene2;WT1;WT;2 Gene1;WT1;WT;3 Gene8;WT2;WT;1.2 Gene7;WT2;WT;1.4 Gene6;WT2;WT;16 Gene5;WT2;WT;10 Gene4;WT2;WT;25 Gene3;WT2;WT;30 Gene2;WT2;WT;2 Gene1;WT2;WT;3 Gene8;WT3;WT;1.2 Gene7;WT3;WT;1.4 Gene6;WT3;WT;16 Gene5;WT3;WT;10 Gene4;WT3;WT;25 Gene3;WT3;WT;30 Gene2;WT3;WT;2 Gene1;WT3;WT;3&quot; data &lt;- read.table(text=data, header=T, row.names=NULL, sep=&quot;;&quot;) data[sample(1:nrow(data),6),] ## Gene Sample Group Abundance ## 32 Gene1 WT1 WT 3.0 ## 41 Gene8 WT3 WT 1.2 ## 48 Gene1 WT3 WT 3.0 ## 16 Gene8 KO2 KO 3.0 ## 11 Gene3 KO2 KO 16.0 ## 5 Gene5 KO1 KO 25.0 # 加载包 library(ggplot2) 初始化ggplot，建立坐标系 p &lt;- ggplot(data, aes(x=Sample, y=Gene)) p 绘制几何属性 p + geom_point() 映射数据到几何形状的属性，如颜色 p + geom_point(aes(color=Abundance)) 映射数据到几何形状的属性，如大小 p + geom_point(aes(size=Abundance)) 自定义颜色 p + geom_point(aes(color=Abundance)) + scale_color_continuous(low=&quot;green&quot;, high=&quot;red&quot;) 设置主题属性 p + geom_point(aes(color=Abundance)) + scale_color_continuous(low=&quot;green&quot;, high=&quot;red&quot;) + theme_classic() 放大点，并添加文字作为label p + geom_point(aes(color=Abundance), size=10) + scale_color_continuous(low=&quot;green&quot;, high=&quot;red&quot;) + geom_text(aes(label=Abundance)) + theme_classic() 自定义注释 p + geom_point(aes(color=Abundance), size=10) + scale_color_continuous(low=&quot;green&quot;, high=&quot;red&quot;) + geom_text(aes(label=Abundance)) + annotate(&quot;rect&quot;,xmin=0.5, xmax=3.5, ymin=5.5,ymax=6.5,alpha=0.2) + theme_classic() 绘制热图 p + geom_tile(aes(fill=Abundance)) + scale_fill_continuous(low=&quot;green&quot;, high=&quot;red&quot;) + geom_text(aes(label=Abundance)) + theme_classic() 转换坐标系 p + geom_tile(aes(fill=Abundance)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;steelblue&quot;) + geom_text(aes(label=Abundance)) + coord_polar(theta=&quot;x&quot;) + theme(panel.background=element_blank(), axis.title=element_blank(), panel.grid=element_blank(), axis.ticks=element_blank(), axis.text.y=element_text(size=5)) 更改横轴的顺序 # paste0(rep(c(&quot;WT&quot;,&quot;KO&quot;),each=3), rep(1:3)) data$Sample &lt;- factor(data$Sample,levels=c(&quot;WT1&quot;,&quot;WT2&quot;,&quot;WT3&quot;,&quot;KO1&quot;,&quot;KO2&quot;,&quot;KO3&quot;), ordered=T) p &lt;- ggplot(data, aes(x=Sample, y=Gene)) + geom_tile(aes(fill=Abundance)) + scale_fill_continuous(low=&quot;green&quot;, high=&quot;red&quot;) + geom_text(aes(label=Abundance)) + theme_classic() p 箱线图展示 p &lt;- ggplot(data, aes(x=Sample, y=Abundance)) + geom_boxplot(aes(fill=Group)) p 小提琴图加点的连线 # geom_line把同一个Gene的数据作为一组 p &lt;- ggplot(data, aes(x=Group, y=Abundance)) + geom_violin(aes(fill=Group), alpha=0.5) + geom_line(aes(group=Gene), alpha=0.5) p library(ggpubr) ggviolin(data, x=&quot;Group&quot;, y=&quot;Abundance&quot;, fill=&quot;Group&quot;, palette = &quot;npg&quot;, add=c(&quot;jitter&quot;)) + stat_compare_means(comparisons = list(c(&quot;KO&quot;, &quot;WT&quot;))) 2.5.1 数据格式转换和字符串处理 假如我们的数据如下形式，如何完成上面的图的绘制？ KO1;KO2;KO3;WT1;WT2;WT3 Gene1;1.2;1.2;1.2;3.0;3.0;3.0 Gene2;1.4;1.4;1.4;2.0;2.0;2.0 Gene3;16.0;16.0;16.0;30.0;30.0;30.0 Gene4;10.0;10.0;10.0;25.0;25.0;25.0 Gene5;25.0;25.0;25.0;10.0;10.0;10.0 Gene6;30.0;30.0;30.0;16.0;16.0;16.0 Gene7;2.0;2.0;2.0;1.4;1.4;1.4 Gene8;3.0;3.0;3.0;1.2;1.2;1.2 读入数据，查看数据格式 (注意：read.table中参数与之前的不同地方在哪？为什么？) data_matrix = &quot;KO1;KO2;KO3;WT1;WT2;WT3 Gene1;1.3;1.2;1.4;3.1;3.2;3.3 Gene2;1.1;1.9;1.6;2.3;2.2;2.1 Gene3;16.8;17.0;18.0;33.0;30.0;35.0 Gene4;11.0;13.0;12.0;25.0;26.0;28.0 Gene5;20.0;25.0;23.0;9.0;10.0;13.0 Gene6;33.0;30.0;35.0;16.0;17.0;16.0 Gene7;2.0;2.3;2.0;1.4;1.8;1.4 Gene8;3.0;3.6;3.0;1.2;1.9;1.2&quot; data_matrix &lt;- read.table(text=data_matrix, header=T, row.names=1, sep=&quot;;&quot;) data_matrix ## KO1 KO2 KO3 WT1 WT2 WT3 ## Gene1 1.3 1.2 1.4 3.1 3.2 3.3 ## Gene2 1.1 1.9 1.6 2.3 2.2 2.1 ## Gene3 16.8 17.0 18.0 33.0 30.0 35.0 ## Gene4 11.0 13.0 12.0 25.0 26.0 28.0 ## Gene5 20.0 25.0 23.0 9.0 10.0 13.0 ## Gene6 33.0 30.0 35.0 16.0 17.0 16.0 ## Gene7 2.0 2.3 2.0 1.4 1.8 1.4 ## Gene8 3.0 3.6 3.0 1.2 1.9 1.2 宽矩阵转换为长矩阵 library(tidyr) data_matrix$Gene &lt;- rownames(data_matrix) data_matrix_long &lt;- gather(data_matrix, key=&quot;Sample&quot;, value=&quot;Abundance&quot;, -Gene) head(data_matrix_long) ## Gene Sample Abundance ## 1 Gene1 KO1 1.3 ## 2 Gene2 KO1 1.1 ## 3 Gene3 KO1 16.8 ## 4 Gene4 KO1 11.0 ## 5 Gene5 KO1 20.0 ## 6 Gene6 KO1 33.0 data_matrix_long &lt;- data_matrix_long %&gt;% separate(&quot;Sample&quot;, c(&quot;Group&quot;, &quot;Rep&quot;), sep=2, remove=F) head(data_matrix_long) ## Gene Sample Group Rep Abundance ## 1 Gene1 KO1 KO 1 1.3 ## 2 Gene2 KO1 KO 1 1.1 ## 3 Gene3 KO1 KO 1 16.8 ## 4 Gene4 KO1 KO 1 11.0 ## 5 Gene5 KO1 KO 1 20.0 ## 6 Gene6 KO1 KO 1 33.0 获取分组信息 (分组名字等长) library(stringr) data_matrix_long$Group2 &lt;- str_sub(data_matrix_long$Sample,start=1,end=2) head(data_matrix_long) 另外一种拆分样本名字的方式 (分组名字和生物重复之间分隔符固定) library(stringr) library(tidyr) data_matrix2 = &quot;KO_1;KO_2;KO_3;WT_1;WT_2;WT_3 Gene1;1.3;1.2;1.4;3.1;3.2;3.3 Gene2;1.1;1.9;1.6;2.3;2.2;2.1 Gene3;16.8;17.0;18.0;33.0;30.0;35.0 Gene4;11.0;13.0;12.0;25.0;26.0;28.0 Gene5;20.0;25.0;23.0;9.0;10.0;13.0 Gene6;33.0;30.0;35.0;16.0;17.0;16.0 Gene7;2.0;2.3;2.0;1.4;1.8;1.4 Gene8;3.0;3.6;3.0;1.2;1.9;1.2&quot; data_matrix2 &lt;- read.table(text=data_matrix2, header=T, row.names=1, sep=&quot;;&quot;) data_matrix2$Gene &lt;- rownames(data_matrix2) data_matrix_long2 &lt;- gather(data_matrix2, key=&quot;Sample&quot;, value=&quot;Abundance&quot;, -Gene) head(data_matrix_long2) ## Gene Sample Abundance ## 1 Gene1 KO_1 1.3 ## 2 Gene2 KO_1 1.1 ## 3 Gene3 KO_1 16.8 ## 4 Gene4 KO_1 11.0 ## 5 Gene5 KO_1 20.0 ## 6 Gene6 KO_1 33.0 data_matrix_long2$Group &lt;- str_split(data_matrix_long2$Sample, pattern=&quot;_&quot;, simplify=T)[,1] head(data_matrix_long2) ## Gene Sample Abundance Group ## 1 Gene1 KO_1 1.3 KO ## 2 Gene2 KO_1 1.1 KO ## 3 Gene3 KO_1 16.8 KO ## 4 Gene4 KO_1 11.0 KO ## 5 Gene5 KO_1 20.0 KO ## 6 Gene6 KO_1 33.0 KO 使用separate更简单 data_matrix_long2 %&gt;% separate(Sample, c(&quot;Group&quot;, &quot;Rep&quot;),sep=&quot;_&quot;, remove=F) ## Gene Sample Group Rep Abundance ## 1 Gene1 KO_1 KO 1 1.3 ## 2 Gene2 KO_1 KO 1 1.1 ## 3 Gene3 KO_1 KO 1 16.8 ## 4 Gene4 KO_1 KO 1 11.0 ## 5 Gene5 KO_1 KO 1 20.0 ## 6 Gene6 KO_1 KO 1 33.0 ## 7 Gene7 KO_1 KO 1 2.0 ## 8 Gene8 KO_1 KO 1 3.0 ## 9 Gene1 KO_2 KO 2 1.2 ## 10 Gene2 KO_2 KO 2 1.9 ## 11 Gene3 KO_2 KO 2 17.0 ## 12 Gene4 KO_2 KO 2 13.0 ## 13 Gene5 KO_2 KO 2 25.0 ## 14 Gene6 KO_2 KO 2 30.0 ## 15 Gene7 KO_2 KO 2 2.3 ## 16 Gene8 KO_2 KO 2 3.6 ## 17 Gene1 KO_3 KO 3 1.4 ## 18 Gene2 KO_3 KO 3 1.6 ## 19 Gene3 KO_3 KO 3 18.0 ## 20 Gene4 KO_3 KO 3 12.0 ## 21 Gene5 KO_3 KO 3 23.0 ## 22 Gene6 KO_3 KO 3 35.0 ## 23 Gene7 KO_3 KO 3 2.0 ## 24 Gene8 KO_3 KO 3 3.0 ## 25 Gene1 WT_1 WT 1 3.1 ## 26 Gene2 WT_1 WT 1 2.3 ## 27 Gene3 WT_1 WT 1 33.0 ## 28 Gene4 WT_1 WT 1 25.0 ## 29 Gene5 WT_1 WT 1 9.0 ## 30 Gene6 WT_1 WT 1 16.0 ## 31 Gene7 WT_1 WT 1 1.4 ## 32 Gene8 WT_1 WT 1 1.2 ## 33 Gene1 WT_2 WT 2 3.2 ## 34 Gene2 WT_2 WT 2 2.2 ## 35 Gene3 WT_2 WT 2 30.0 ## 36 Gene4 WT_2 WT 2 26.0 ## 37 Gene5 WT_2 WT 2 10.0 ## 38 Gene6 WT_2 WT 2 17.0 ## 39 Gene7 WT_2 WT 2 1.8 ## 40 Gene8 WT_2 WT 2 1.9 ## 41 Gene1 WT_3 WT 3 3.3 ## 42 Gene2 WT_3 WT 3 2.1 ## 43 Gene3 WT_3 WT 3 35.0 ## 44 Gene4 WT_3 WT 3 28.0 ## 45 Gene5 WT_3 WT 3 13.0 ## 46 Gene6 WT_3 WT 3 16.0 ## 47 Gene7 WT_3 WT 3 1.4 ## 48 Gene8 WT_3 WT 3 1.2 字符串拼合 library(tidyr) # group_rep &lt;- as.data.frame(str_split(data_matrix_long2$Sample, pattern=&quot;_&quot;, simplify=T)) # colnames(group_rep) &lt;- c(&quot;Group&quot;, &quot;Rep&quot;) # unite(group_rep, col=&quot;Sample&quot;, sep=&quot;_&quot;) data_matrix_long2 %&gt;% separate(Sample, c(&quot;Group&quot;, &quot;Rep&quot;),sep=&quot;_&quot;, remove=F) %&gt;% unite(col=&quot;Sample2&quot;, c(&quot;Group&quot;,&quot;Rep&quot;), sep=&quot;-&quot;, remove=F) ## Gene Sample Sample2 Group Rep Abundance ## 1 Gene1 KO_1 KO-1 KO 1 1.3 ## 2 Gene2 KO_1 KO-1 KO 1 1.1 ## 3 Gene3 KO_1 KO-1 KO 1 16.8 ## 4 Gene4 KO_1 KO-1 KO 1 11.0 ## 5 Gene5 KO_1 KO-1 KO 1 20.0 ## 6 Gene6 KO_1 KO-1 KO 1 33.0 ## 7 Gene7 KO_1 KO-1 KO 1 2.0 ## 8 Gene8 KO_1 KO-1 KO 1 3.0 ## 9 Gene1 KO_2 KO-2 KO 2 1.2 ## 10 Gene2 KO_2 KO-2 KO 2 1.9 ## 11 Gene3 KO_2 KO-2 KO 2 17.0 ## 12 Gene4 KO_2 KO-2 KO 2 13.0 ## 13 Gene5 KO_2 KO-2 KO 2 25.0 ## 14 Gene6 KO_2 KO-2 KO 2 30.0 ## 15 Gene7 KO_2 KO-2 KO 2 2.3 ## 16 Gene8 KO_2 KO-2 KO 2 3.6 ## 17 Gene1 KO_3 KO-3 KO 3 1.4 ## 18 Gene2 KO_3 KO-3 KO 3 1.6 ## 19 Gene3 KO_3 KO-3 KO 3 18.0 ## 20 Gene4 KO_3 KO-3 KO 3 12.0 ## 21 Gene5 KO_3 KO-3 KO 3 23.0 ## 22 Gene6 KO_3 KO-3 KO 3 35.0 ## 23 Gene7 KO_3 KO-3 KO 3 2.0 ## 24 Gene8 KO_3 KO-3 KO 3 3.0 ## 25 Gene1 WT_1 WT-1 WT 1 3.1 ## 26 Gene2 WT_1 WT-1 WT 1 2.3 ## 27 Gene3 WT_1 WT-1 WT 1 33.0 ## 28 Gene4 WT_1 WT-1 WT 1 25.0 ## 29 Gene5 WT_1 WT-1 WT 1 9.0 ## 30 Gene6 WT_1 WT-1 WT 1 16.0 ## 31 Gene7 WT_1 WT-1 WT 1 1.4 ## 32 Gene8 WT_1 WT-1 WT 1 1.2 ## 33 Gene1 WT_2 WT-2 WT 2 3.2 ## 34 Gene2 WT_2 WT-2 WT 2 2.2 ## 35 Gene3 WT_2 WT-2 WT 2 30.0 ## 36 Gene4 WT_2 WT-2 WT 2 26.0 ## 37 Gene5 WT_2 WT-2 WT 2 10.0 ## 38 Gene6 WT_2 WT-2 WT 2 17.0 ## 39 Gene7 WT_2 WT-2 WT 2 1.8 ## 40 Gene8 WT_2 WT-2 WT 2 1.9 ## 41 Gene1 WT_3 WT-3 WT 3 3.3 ## 42 Gene2 WT_3 WT-3 WT 3 2.1 ## 43 Gene3 WT_3 WT-3 WT 3 35.0 ## 44 Gene4 WT_3 WT-3 WT 3 28.0 ## 45 Gene5 WT_3 WT-3 WT 3 13.0 ## 46 Gene6 WT_3 WT-3 WT 3 16.0 ## 47 Gene7 WT_3 WT-3 WT 3 1.4 ## 48 Gene8 WT_3 WT-3 WT 3 1.2 用柱状图看下每个Gene在不同组的表达情况 library(ggplot2) library(dplyr) # 给定数据，和x轴、y轴所在列名字 # 直接使用geom_bar就可以绘制柱状图 # position: dodge: 柱子并排放置 p &lt;- ggplot(data_matrix_long, aes(x=Gene, y=Abundance)) p + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, aes(fill=Sample)) # 如果没有图形界面，运行下面的语句把图存在工作目录下的Rplots.pdf文件中 #dev.off() 柱子有点多，也可以利用mean±SD的形式展现 首先计算平均值和标准差，使用group_by按Gene, Group分组，对每组做summarize。 data_matrix_long %&gt;% arrange(Gene) ## Gene Sample Group Rep Abundance ## 1 Gene1 KO1 KO 1 1.3 ## 2 Gene1 KO2 KO 2 1.2 ## 3 Gene1 KO3 KO 3 1.4 ## 4 Gene1 WT1 WT 1 3.1 ## 5 Gene1 WT2 WT 2 3.2 ## 6 Gene1 WT3 WT 3 3.3 ## 7 Gene2 KO1 KO 1 1.1 ## 8 Gene2 KO2 KO 2 1.9 ## 9 Gene2 KO3 KO 3 1.6 ## 10 Gene2 WT1 WT 1 2.3 ## 11 Gene2 WT2 WT 2 2.2 ## 12 Gene2 WT3 WT 3 2.1 ## 13 Gene3 KO1 KO 1 16.8 ## 14 Gene3 KO2 KO 2 17.0 ## 15 Gene3 KO3 KO 3 18.0 ## 16 Gene3 WT1 WT 1 33.0 ## 17 Gene3 WT2 WT 2 30.0 ## 18 Gene3 WT3 WT 3 35.0 ## 19 Gene4 KO1 KO 1 11.0 ## 20 Gene4 KO2 KO 2 13.0 ## 21 Gene4 KO3 KO 3 12.0 ## 22 Gene4 WT1 WT 1 25.0 ## 23 Gene4 WT2 WT 2 26.0 ## 24 Gene4 WT3 WT 3 28.0 ## 25 Gene5 KO1 KO 1 20.0 ## 26 Gene5 KO2 KO 2 25.0 ## 27 Gene5 KO3 KO 3 23.0 ## 28 Gene5 WT1 WT 1 9.0 ## 29 Gene5 WT2 WT 2 10.0 ## 30 Gene5 WT3 WT 3 13.0 ## 31 Gene6 KO1 KO 1 33.0 ## 32 Gene6 KO2 KO 2 30.0 ## 33 Gene6 KO3 KO 3 35.0 ## 34 Gene6 WT1 WT 1 16.0 ## 35 Gene6 WT2 WT 2 17.0 ## 36 Gene6 WT3 WT 3 16.0 ## 37 Gene7 KO1 KO 1 2.0 ## 38 Gene7 KO2 KO 2 2.3 ## 39 Gene7 KO3 KO 3 2.0 ## 40 Gene7 WT1 WT 1 1.4 ## 41 Gene7 WT2 WT 2 1.8 ## 42 Gene7 WT3 WT 3 1.4 ## 43 Gene8 KO1 KO 1 3.0 ## 44 Gene8 KO2 KO 2 3.6 ## 45 Gene8 KO3 KO 3 3.0 ## 46 Gene8 WT1 WT 1 1.2 ## 47 Gene8 WT2 WT 2 1.9 ## 48 Gene8 WT3 WT 3 1.2 library(dplyr) # 获取平均值和标准差 data_m_sd_mean &lt;- data_matrix_long %&gt;% group_by(Gene, Group) %&gt;% dplyr::summarise(sd=sd(Abundance), mean_value=mean(Abundance)) ## `summarise()` has grouped output by ## &#39;Gene&#39;. You can override using the ## `.groups` argument. data_m_sd_mean &lt;- as.data.frame(data_m_sd_mean) data_m_sd_mean ## Gene Group sd mean_value ## 1 Gene1 KO 0.1000000 1.300000 ## 2 Gene1 WT 0.1000000 3.200000 ## 3 Gene2 KO 0.4041452 1.533333 ## 4 Gene2 WT 0.1000000 2.200000 ## 5 Gene3 KO 0.6429101 17.266667 ## 6 Gene3 WT 2.5166115 32.666667 ## 7 Gene4 KO 1.0000000 12.000000 ## 8 Gene4 WT 1.5275252 26.333333 ## 9 Gene5 KO 2.5166115 22.666667 ## 10 Gene5 WT 2.0816660 10.666667 ## 11 Gene6 KO 2.5166115 32.666667 ## 12 Gene6 WT 0.5773503 16.333333 ## 13 Gene7 KO 0.1732051 2.100000 ## 14 Gene7 WT 0.2309401 1.533333 ## 15 Gene8 KO 0.3464102 3.200000 ## 16 Gene8 WT 0.4041452 1.433333 使用geom_errorbar添加误差线 p &lt;- ggplot(data_m_sd_mean, aes(x=Gene, y=mean_value, group=Group)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, aes(fill=Group)) + geom_errorbar(aes(ymin=mean_value-sd, ymax=mean_value+sd), width=0.2, position=position_dodge(width=0.9)) p 采用ggpubr绘制barplot+errorbar library(ggpubr) ggbarplot(data_matrix_long, x = &quot;Gene&quot;, y = &quot;Abundance&quot;, color = &quot;Group&quot;, #add.params = list(group = &quot;Group&quot;), add = c(&quot;mean_se&quot;,&quot;jitter&quot;), palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;), position = position_dodge()) 绘制带Error-bar的堆叠柱状图 library(plyr) data_m_sd_mean_stack &lt;- data_m_sd_mean factor_level &lt;- unique(data_m_sd_mean_stack$Group) data_m_sd_mean_stack$Group &lt;- factor(data_m_sd_mean_stack$Group, levels=factor_level, ordered=T) mydata2 &lt;- ddply(data_m_sd_mean_stack,.(Gene),transform,ymin = cumsum(mean_value) - sd,ymax = cumsum(mean_value) + sd) mydata2 ## Gene Group sd mean_value ymin ymax ## 1 Gene1 KO 0.1000000 1.300000 1.200000 1.400000 ## 2 Gene1 WT 0.1000000 3.200000 4.400000 4.600000 ## 3 Gene2 KO 0.4041452 1.533333 1.129188 1.937479 ## 4 Gene2 WT 0.1000000 2.200000 3.633333 3.833333 ## 5 Gene3 KO 0.6429101 17.266667 16.623757 17.909577 ## 6 Gene3 WT 2.5166115 32.666667 47.416722 52.449945 ## 7 Gene4 KO 1.0000000 12.000000 11.000000 13.000000 ## 8 Gene4 WT 1.5275252 26.333333 36.805808 39.860859 ## 9 Gene5 KO 2.5166115 22.666667 20.150055 25.183278 ## 10 Gene5 WT 2.0816660 10.666667 31.251667 35.414999 ## 11 Gene6 KO 2.5166115 32.666667 30.150055 35.183278 ## 12 Gene6 WT 0.5773503 16.333333 48.422650 49.577350 ## 13 Gene7 KO 0.1732051 2.100000 1.926795 2.273205 ## 14 Gene7 WT 0.2309401 1.533333 3.402393 3.864273 ## 15 Gene8 KO 0.3464102 3.200000 2.853590 3.546410 ## 16 Gene8 WT 0.4041452 1.433333 4.229188 5.037479 library(RColorBrewer) cols = colorRampPalette(brewer.pal(9, &quot;Paired&quot;))(length(factor_level)) mydata2$Group &lt;- factor(mydata2$Group, levels=rev(factor_level), ordered=T) p &lt;- ggplot(mydata2, aes(x=Gene, y=mean_value, group=Group)) + geom_bar(stat=&quot;identity&quot;, aes(fill=Group), position = &quot;stack&quot;) + scale_fill_manual(values=cols) + geom_errorbar(aes(ymin=ymin, ymax=ymax), width=0.2,color=&quot;black&quot;, position=position_identity()) p 在柱子中标记百分比值 首先计算百分比，同样是group_by (按照给定的变量分组，然后按组操作)和mutate两个函数(在当前数据表增加新变量) # group_by: 按照给定的变量分组，然后按组操作 # mutate: 在当前数据表增加新变量 # 第一步增加每个组的加和，第二步计算比例 data_m &lt;- data_matrix_long data_m &lt;- data_m %&gt;% group_by(Gene) %&gt;% mutate(count=sum(Abundance), freq=round(100*Abundance/count,2)) %&gt;% arrange(Gene, Sample) head(data_m) ## # A tibble: 6 × 7 ## # Groups: Gene [1] ## Gene Sample Group Rep Abundance count freq ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Gene1 KO1 KO 1 1.3 561. 0.23 ## 2 Gene1 KO2 KO 2 1.2 561. 0.21 ## 3 Gene1 KO3 KO 3 1.4 561. 0.25 ## 4 Gene1 WT1 WT 1 3.1 561. 0.55 ## 5 Gene1 WT2 WT 2 3.2 561. 0.57 ## 6 Gene1 WT3 WT 3 3.3 561. 0.59 再标记相对比例信息 p &lt;- ggplot(data_m, aes(x=Gene, y=Abundance, group=Group)) + geom_bar(stat=&quot;identity&quot;, position=&quot;fill&quot;, aes(fill=Sample)) + scale_y_continuous(labels = scales::percent) + geom_text(aes(label=freq), position=position_fill(vjust=0.5)) p 2.5.2 配色 序列型颜色板适用于从低到高排序明显的数据，浅色数字小，深色数字大。 library(RColorBrewer) display.brewer.all(type = &quot;seq&quot;) 离散型颜色板适合带“正、负”的，对极值和中间值比较注重的数据。 display.brewer.all(type = &quot;div&quot;) 分类型颜色板比较适合区分分类型的数据。 display.brewer.all(type = &quot;qual&quot;) 2.5.3 pheatmap绘制热图 data_matrix = &quot;KO1;KO2;KO3;WT1;WT2;WT3 Gene1;1.2;1.2;1.2;3.0;3.0;3.0 Gene2;1.4;1.4;1.4;2.0;2.0;2.0 Gene3;16.0;16.0;16.0;30.0;30.0;30.0 Gene4;10.0;10.0;10.0;25.0;25.0;25.0 Gene5;25.0;25.0;25.0;10.0;10.0;10.0 Gene6;30.0;30.0;30.0;16.0;16.0;16.0 Gene7;2.0;2.0;2.0;1.4;1.4;1.4 Gene8;3.0;3.0;3.0;1.2;1.2;1.2&quot; data_matrix &lt;- read.table(text=data_matrix, header=T, row.names=1, sep=&quot;;&quot;) head(data_matrix) ## KO1 KO2 KO3 WT1 WT2 WT3 ## Gene1 1.2 1.2 1.2 3 3 3 ## Gene2 1.4 1.4 1.4 2 2 2 ## Gene3 16.0 16.0 16.0 30 30 30 ## Gene4 10.0 10.0 10.0 25 25 25 ## Gene5 25.0 25.0 25.0 10 10 10 ## Gene6 30.0 30.0 30.0 16 16 16 #data_matrix &lt;- read.table(&quot;gene_expr_mat.txt&quot;, header=T, row.names=1, sep=&quot;\\t&quot;) #head(data_matrix) library(pheatmap) pheatmap(data_matrix) metadata &lt;- &quot;samp;Grp WT1;WT WT2;WT WT3;WT KO1;KO KO2;KO KO3;KO&quot; metadata &lt;- read.table(text=metadata, header=T, row.names=1, sep=&quot;;&quot;) pheatmap(data_matrix, annotation_col = metadata) colorL = colorRampPalette(c(&quot;green&quot;,&quot;red&quot;))(30) pheatmap(data_matrix, annotation_col = metadata, color = colorL) 2.6 CheetSheets https://www.rstudio.com/resources/cheatsheets/ 2.7 参考 {ref01} 生信宝典Linux系列 生信宝典R系列 "],["Rplots.html", "3 R plots 3.1 qplot绘制图形 (王绪宁) 3.2 热图绘制 3.3 热图美化 3.4 热图绘制 - pheatmap 3.5 聚类热图如何按自己的意愿调整分支顺序？ 3.6 箱线图 3.7 线图 3.8 散点图 3.9 功能富集泡泡图 3.10 韦恩图 3.11 柱状图绘制 3.12 图形支持中文字体 3.13 PCA原理解析和图形绘制 3.14 生存分析 3.15 一步作图的优势 3.16 不改脚本的热图绘制 3.17 参考资料", " 3 R plots 3.1 qplot绘制图形 (王绪宁) ggplot2中两大精髓的函数分别为 qplot (快速作图quick plot)，类似于R中基本的plot和ggplot (更符合ggplot2图层式绘图理念，一层层添加修改)。 测试数据是ggplot2包中自带的diamond数据，每一行为一种钻石，每一列为钻石不同的属性，如carat (克拉), cut (切工), color (色泽), clarity (透明度)等。 library(ggplot2) set.seed(23) dat &lt;- diamonds[sample(nrow(diamonds), 1000),] head(dat) ## # A tibble: 6 × 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.01 Very Good F VS2 62.9 56 5902 6.38 6.41 4.02 ## 2 0.58 Very Good D SI1 60.2 58 1785 5.37 5.46 3.26 ## 3 0.32 Premium H VS2 61.4 60 648 4.41 4.39 2.7 ## 4 0.32 Very Good D SI1 63 57 526 4.35 4.38 2.75 ## 5 1 Premium F VVS2 60.6 54 8924 6.56 6.52 3.96 ## 6 1.2 Ideal J SI1 62.5 55 4536 6.84 6.79 4.26 数据读进来后，怎么绘制呢？ 绘制散点图，横轴是克拉数，纵轴是价格 (正相关) qplot(carat,price,data=dat) 绘制散点图，对x,y值取log qplot(log(carat),log(price),data=dat) 颜色、大小、性状和其他属性的设置 qplot(carat,price,data=dat,colour=color) qplot(carat,price,data=dat,shape=cut)#以cut为分类依据设置不同的形状 几何对象 qplot()函数配合不同的几何对象便可绘制出不同的图形: 点图 geom=\"point\" 平滑曲线 geom=\"smooth\" 箱线图 geom=\"boxplot\" 任意方向的路径性geom=\"path\" 线条图 geom=\"line\" (从左到右连接) 对于连续变量，直方图geom=\"histogram\" 频率多边图 geom=\"freqpoly\" 绘制密度曲线 geom=\"density\" 如果只有x参数传递给qplot(),那么默认是直方图 对于离散变量，geom=“bar”绘制条形图 #向图形中加入平滑曲线(#从本张图片可以逐渐体会ggplot绘图的强大， #后期应用ggplot()函数后，可以更加自由的绘制各种组合图形) qplot(carat,price,data=dat,geom=c(&quot;point&quot;,&quot;smooth&quot;))#添加了一条拟合曲线 ## `geom_smooth()` using method = &#39;gam&#39; ## and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; #拟合曲线默认的方法为method=&quot;loss&quot;,程序会根据数据点的多少自动选取，曲线周围的灰色部分为标准误，可以用se=FALSE曲线 绘制其他常见图形 箱线图 qplot(color,price/carat,data=dat,geom=&quot;boxplot&quot;) 绕动图 (抖动图) qplot(color,price/carat,data=diamonds,geom=&quot;jitter&quot;) 直方图 qplot(carat,data=dat,geom=&quot;histogram&quot;) ## `stat_bin()` using `bins = 30`. Pick ## better value `binwidth`. 密度曲线图 qplot(carat,data=dat,geom=&quot;density&quot;) 条形图 qplot(color,data=dat,geom=&quot;bar&quot;) 时间序列线条图,采用另一个数据集economics qplot(date,unemploy/pop,data=economics,geom=&quot;line&quot;) 分面绘图facet=分类变量 qplot(carat,data=dat,facets=color ~ .,geom=&quot;histogram&quot;,binwidth=0.1,xlim=c(0,3)) 以上为ggplot2包中常见图形的快速绘制 (quickplot)即qplot函数的应用。 qplot函数还有很多其他的参数, 对xlim,ylim设置x,y轴的区间例如xlim=c(0,20); 对轴取log值，log=\"x\",对x轴取对数，log=\"xy\"表示对x轴和y轴取对数;main：图形的主题main=“qplot title”; #xlab,ylab:设置轴标签文字 qplot(carat,price,data=dat, xlab=&quot;Price($)&quot;,ylab=&quot;Weight(carat)&quot;, main=&quot;Price-Weight relationship&quot;) 3.2 热图绘制 热图是做分析时常用的展示方式，简单、直观、清晰。可以用来显示基因在不同样品中表达的高低、表观修饰水平的高低、样品之间的相关性等。任何一个数值矩阵都可以通过合适的方式用热图展示。 本篇使用R的ggplot2包实现从原始数据读入到热图输出的过程，并在教程结束后提供一份封装好的命令行绘图工具，只需要提供矩阵，即可一键绘图。 上一篇讲述了Rstudio的使用作为R写作和编译环境的入门，后面的命令都可以拷贝到Rstudio中运行，或写成一个R脚本，使用Rscript heatmap.r运行。我们还提供了Bash的封装，在不修改R脚本的情况下，改变参数绘制出不同的图形。 3.2.1 生成测试数据 绘图首先需要数据。通过生成几组向量，转换为矩阵，得到想要的数据。 data &lt;- c(1:6,6:1,6:1,1:6, (6:1)/10,(1:6)/10,(1:6)/10,(6:1)/10,1:6,6:1,6:1,1:6, 6:1,1:6,1:6,6:1) data ## [1] 1.0 2.0 3.0 4.0 5.0 6.0 6.0 5.0 4.0 3.0 2.0 1.0 6.0 5.0 4.0 3.0 2.0 1.0 1.0 ## [20] 2.0 3.0 4.0 5.0 6.0 0.6 0.5 0.4 0.3 0.2 0.1 0.1 0.2 0.3 0.4 0.5 0.6 0.1 0.2 ## [39] 0.3 0.4 0.5 0.6 0.6 0.5 0.4 0.3 0.2 0.1 1.0 2.0 3.0 4.0 5.0 6.0 6.0 5.0 4.0 ## [58] 3.0 2.0 1.0 6.0 5.0 4.0 3.0 2.0 1.0 1.0 2.0 3.0 4.0 5.0 6.0 6.0 5.0 4.0 3.0 ## [77] 2.0 1.0 1.0 2.0 3.0 4.0 5.0 6.0 1.0 2.0 3.0 4.0 5.0 6.0 6.0 5.0 4.0 3.0 2.0 ## [96] 1.0 注意：运算符的优先级。 1:3+4 ## [1] 5 6 7 (1:3)+4 ## [1] 5 6 7 1:(3+4) ## [1] 1 2 3 4 5 6 7 Vector转为矩阵 (matrix)，再转为数据框 (data.frame)。 # ncol: 指定列数 # byrow: 先按行填充数据 # ?matrix 可查看函数的使用方法 # as.data.frame的as系列是转换用的 data &lt;- as.data.frame(matrix(data, ncol=12, byrow=T)) data ## V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 V12 ## 1 1.0 2.0 3.0 4.0 5.0 6.0 6.0 5.0 4.0 3.0 2.0 1.0 ## 2 6.0 5.0 4.0 3.0 2.0 1.0 1.0 2.0 3.0 4.0 5.0 6.0 ## 3 0.6 0.5 0.4 0.3 0.2 0.1 0.1 0.2 0.3 0.4 0.5 0.6 ## 4 0.1 0.2 0.3 0.4 0.5 0.6 0.6 0.5 0.4 0.3 0.2 0.1 ## 5 1.0 2.0 3.0 4.0 5.0 6.0 6.0 5.0 4.0 3.0 2.0 1.0 ## 6 6.0 5.0 4.0 3.0 2.0 1.0 1.0 2.0 3.0 4.0 5.0 6.0 ## 7 6.0 5.0 4.0 3.0 2.0 1.0 1.0 2.0 3.0 4.0 5.0 6.0 ## 8 1.0 2.0 3.0 4.0 5.0 6.0 6.0 5.0 4.0 3.0 2.0 1.0 # 增加列的名字 colnames(data) &lt;- c(&quot;Zygote&quot;,&quot;2_cell&quot;,&quot;4_cell&quot;,&quot;8_cell&quot;,&quot;Morula&quot;,&quot;ICM&quot;,&quot;ESC&quot;, &quot;4 week PGC&quot;,&quot;7 week PGC&quot;,&quot;10 week PGC&quot;,&quot;17 week PGC&quot;, &quot;OOcyte&quot;) # 增加行的名字 # 注意paste和paste0的使用 rownames(data) &lt;- paste(&quot;Gene&quot;, 1:8, sep=&quot;_&quot;) # 只显示前6行和前4列 head(data)[,1:4] ## Zygote 2_cell 4_cell 8_cell ## Gene_1 1.0 2.0 3.0 4.0 ## Gene_2 6.0 5.0 4.0 3.0 ## Gene_3 0.6 0.5 0.4 0.3 ## Gene_4 0.1 0.2 0.3 0.4 ## Gene_5 1.0 2.0 3.0 4.0 ## Gene_6 6.0 5.0 4.0 3.0 虽然方法比较繁琐，但一个数值矩阵已经获得了。 还有另外2种获取数值矩阵的方式。 读入字符串 # 使用字符串的好处是不需要额外提供文件 # 简单测试时可使用，写起来不繁琐，又方便重复 # 尤其适用于在线提问时作为测试案例 txt &lt;- &quot;ID;Zygote;2_cell;4_cell;8_cell + Gene_1;1;2;3;4 + Gene_2;6;5;4;5 + Gene_3;0.6;0.5;0.4;0.4&quot; # 习惯设置quote为空，避免部分基因名字或注释中存在引号，导致读入文件错误。 # 具体错误可查看 http://blog.genesino.com/collections/R_tips/ 中的记录 data2 &lt;- read.table(text=txt,sep=&quot;;&quot;, header=T, row.names=1, quote=&quot;&quot;) head(data2) ## Zygote X2_cell X4_cell X8_cell ## + Gene_1 1.0 2.0 3.0 4.0 ## + Gene_2 6.0 5.0 4.0 5.0 ## + Gene_3 0.6 0.5 0.4 0.4 可以看到列名字中以数字开头的列都加了X。一般要尽量避免行或列名字以数字开头，会给后续分析带来匹配问题；另外名字中出现的非字母、数字、下划线、点的字符都会被转为点，也需要注意，尽量只用字母、下划线和数字。 # 读入时，增加一个参数`check.names=F`也可以解决问题。 # 这次数字前没有再加 X 了 data2 &lt;- read.table(text=txt,sep=&quot;;&quot;, header=T, row.names=1, quote=&quot;&quot;, check.names = F) head(data2) ## Zygote 2_cell 4_cell 8_cell ## + Gene_1 1.0 2.0 3.0 4.0 ## + Gene_2 6.0 5.0 4.0 5.0 ## + Gene_3 0.6 0.5 0.4 0.4 读入文件 与上一步类似，只是把txt代表的文字存到文件中，再利用文件名读取，不再赘述。 #data2 &lt;- read.table(&quot;filename&quot;,sep=&quot;;&quot;, header=T, row.names=1, quote=&quot;&quot;) 3.2.2 转换数据格式 数据读入后，还需要一步格式转换。在使用ggplot2作图时，有一种长表格模式是最为常用的，尤其是数据不规则时，更应该使用 （这点，我们在讲解箱线图时再说）。 melt：把正常矩阵转换为长表格模式的函数。工作原理是把全部的非id列的数值列转为1列 (列名默认为value)；所有字符列转为一列，列名默认为variable。 # 如果包没有安装，运行下面一句，安装包 #install.packages(c(&quot;reshape2&quot;,&quot;ggplot2&quot;)) library(reshape2) library(ggplot2) # 转换前，先增加一列ID列，保存行名字 data$ID &lt;- rownames(data) # id.vars 列用于指定哪些列为id列；这些列不会被merge，会保留为完整一列。 data_m &lt;- melt(data, id.vars=c(&quot;ID&quot;)) head(data_m) ## ID variable value ## 1 Gene_1 Zygote 1.0 ## 2 Gene_2 Zygote 6.0 ## 3 Gene_3 Zygote 0.6 ## 4 Gene_4 Zygote 0.1 ## 5 Gene_5 Zygote 1.0 ## 6 Gene_6 Zygote 6.0 3.2.3 分解绘图 数据转换后就可以画图了，分解命令如下： # data_m: 是前面费了九牛二虎之力得到的数据表 # aes: aesthetic的缩写，一般指定整体的X轴、Y轴、颜色、形状、大小等。 # 在最开始读入数据时，一般只指定x和y，其它后续指定 p &lt;- ggplot(data_m, aes(x=variable,y=ID)) # 热图就是一堆方块根据其值赋予不同的颜色，所以这里使用fill=value, 用数值做填充色。 p &lt;- p + geom_tile(aes(fill=value)) # ggplot2为图层绘制，一层层添加，存储在p中，在输出p的内容时才会出图。 p ## 如果你没有使用Rstudio或其它R图形版工具，而是在远程登录的服务器上运行的交互式R， ## 需要输入下面的语句，获得输出图形 （图形存储于R的工作目录下的Rplots.pdf文件中）。 ## 如何指定输出，后面会讲到。 #dev.off() 热图出来了，但有点不对劲，横轴重叠一起了。一个办法是调整图像的宽度，另一个是旋转横轴标记。 # theme: 是处理图美观的一个函数，可以调整横纵轴label的选择、图例的位置等。 # 这里选择X轴标签45度。 # hjust和vjust调整标签的相对位置， # 具体见下图。 # 简单说，hjust是水平的对齐方式，0为左，1为右，0.5居中，0-1之间可以取任意值。 # vjust是垂直对齐方式，0底对齐，1为顶对齐，0.5居中，0-1之间可以取任意值。 p &lt;- p + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) p #knitr::include_graphics(&quot;images/hjust_vjust.png&quot;) td &lt;- expand.grid( hjust=c(0, 0.5, 1), vjust=c(0, 0.5, 1), angle=c(0, 45, 90), text=&quot;text&quot; ) ggplot(td, aes(x=hjust, y=vjust)) + geom_point() + geom_text(aes(label=text, angle=angle, hjust=hjust, vjust=vjust)) + facet_grid(~angle) + scale_x_continuous(breaks=c(0, 0.5, 1), expand=c(0, 0.2)) + scale_y_continuous(breaks=c(0, 0.5, 1), expand=c(0, 0.2)) http://stackoverflow.com/questions/7263849/what-do-hjust-and-vjust-do-when-making-a-plot-using-ggplot 设置想要的颜色。 # 连续的数字，指定最小数值代表的颜色和最大数值赋予的颜色 # 注意fill和color的区别，fill是填充，color只针对边缘 p &lt;- p + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) p 调整legend的位置, legend.position, 可以接受的值有 top, bottom, left, right, 和一个坐标 c(0.05,0.8) (左上角，坐标是相对于图的左下角(即原点)计算的） p &lt;- p + theme(legend.position=&quot;top&quot;) p 调整背景和背景格线以及X轴、Y轴的标题。 p &lt;- p + xlab(&quot;samples&quot;) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) p 为了使横轴旋转45度，需要把这句话theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1))放在theme_bw()的后面。 p &lt;- p + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) p 合并以上命令，就得到了下面这个看似复杂的绘图命令。 p &lt;- ggplot(data_m, aes(x=variable,y=ID)) + xlab(&quot;samples&quot;) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) + theme(legend.position=&quot;top&quot;) + geom_tile(aes(fill=value)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + geom_point(aes(color=value), size=6) + geom_text(aes(label=value)) p 也可以只用Point p &lt;- ggplot(data_m, aes(x=variable,y=ID)) + xlab(&quot;samples&quot;) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) + theme(legend.position=&quot;top&quot;) + geom_point(aes(color=value), size=6) + scale_color_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + geom_text(aes(label=value)) p 3.2.4 图形存储 图形出来了，就得考虑存储了，一般输出为PDF格式，方便后期的修改。 # 可以跟输出文件不同的后缀，以获得不同的输出格式 # colormode支持srgb （屏幕）和cmyk （打印，部分杂志需要，看上去有点褪色的感觉）格式 ggsave(p, filename=&quot;heatmap.pdf&quot;, width=10, height=15, units=c(&quot;cm&quot;),colormodel=&quot;srgb&quot;) 点击下载：pdf 至此，完成了简单的heatmap的绘图。但实际绘制时，经常会碰到由于数值变化很大，导致颜色过于集中，使得图的可读性下降很多。因此需要对数据进行一些处理，具体的下次再说。 3.3 热图美化 上面的测试数据，数值的分布比较均一，相差不是太大，但是Gene_4和Gene_5由于整体的值低于其它的基因，从颜色上看，不仔细看，看不出差别。 data &lt;- c(rnorm(5,mean=5), rnorm(5,mean=20), rnorm(5, mean=100), c(600,700,800,900,10000)) data &lt;- matrix(data, ncol=5, byrow=T) data &lt;- as.data.frame(data) rownames(data) &lt;- letters[1:4] colnames(data) &lt;- paste(&quot;Grp&quot;, 1:5, sep=&quot;_&quot;) data ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a 6.202582 5.44537 3.966995 3.599798 3.492898 ## b 21.448145 20.54216 19.309617 19.759537 19.722281 ## c 99.119090 99.36267 100.153907 100.545386 100.713892 ## d 600.000000 700.00000 800.000000 900.000000 10000.000000 data$ID &lt;- rownames(data) data ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ID ## a 6.202582 5.44537 3.966995 3.599798 3.492898 a ## b 21.448145 20.54216 19.309617 19.759537 19.722281 b ## c 99.119090 99.36267 100.153907 100.545386 100.713892 c ## d 600.000000 700.00000 800.000000 900.000000 10000.000000 d data_m &lt;- melt(data, id.vars=c(&quot;ID&quot;)) head(data_m) ## ID variable value ## 1 a Grp_1 6.202582 ## 2 b Grp_1 21.448145 ## 3 c Grp_1 99.119090 ## 4 d Grp_1 600.000000 ## 5 a Grp_2 5.445370 ## 6 b Grp_2 20.542162 p &lt;- ggplot(data_m, aes(x=variable,y=ID)) + xlab(&quot;samples&quot;) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) + theme(legend.position=&quot;top&quot;) + geom_tile(aes(fill=value)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) p #dev.off() 图中只有右上角可以看到红色，其他地方就没了颜色的差异。这通常不是我们想要的。为了更好的可视化效果，需要对数据做些预处理，主要有 对数转换，Z-score转换，抹去异常值，非线性颜色等方式。 3.3.1 对数转换 假设下面的数据是基因表达数据，4个基因 (a, b, c, d)和5个样品 (Grp_1, Grp_2, Grp_3, Grp_4)，矩阵中的值代表基因表达FPKM值。 data &lt;- c(rnorm(5,mean=5), rnorm(5,mean=20), rnorm(5, mean=100), c(600,700,800,900,10000)) data &lt;- matrix(data, ncol=5, byrow=T) data &lt;- as.data.frame(data) rownames(data) &lt;- letters[1:4] colnames(data) &lt;- paste(&quot;Grp&quot;, 1:5, sep=&quot;_&quot;) data ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a 5.876552 4.976503 5.162671 5.251422 4.71722 ## b 19.971840 19.741816 18.057981 21.782768 19.73826 ## c 102.072205 100.558660 99.899542 100.131164 101.49612 ## d 600.000000 700.000000 800.000000 900.000000 10000.00000 data_log &lt;- log2(data+1) data_log ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a 2.781685 2.579302 2.623556 2.644184 2.515314 ## b 4.390382 4.374470 4.252323 4.509871 4.374223 ## c 6.687512 6.666169 6.656776 6.660084 6.679426 ## d 9.231221 9.453271 9.645658 9.815383 13.287857 data_log$ID = rownames(data_log) data_log_m = melt(data_log, id.vars=c(&quot;ID&quot;)) p &lt;- ggplot(data_log_m, aes(x=variable,y=ID)) + xlab(&quot;samples&quot;) + ylab(NULL) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(legend.position=&quot;top&quot;) + theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1)) + geom_tile(aes(fill=value)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) p #ggsave(p, filename=&quot;heatmap_log.pdf&quot;, width=8, height=12, units=c(&quot;cm&quot;),colormodel=&quot;srgb&quot;) 对数转换后的数据，看起来就清晰的多了。而且对数转换后，数据还保留着之前的变化趋势，不只是基因在不同样品之间的表达可比 (同一行的不同列)，不同基因在同一样品的值也可比 (同一列的不同行) (不同基因之间比较表达值存在理论上的问题，即便是按照长度标准化之后的FPKM也不代表基因之间是完全可比的)。 3.3.2 Z-score转换 Z-score又称为标准分数，是一组数中的每个数减去这一组数的平均值再除以这一组数的标准差，代表的是原始分数距离原始平均值的距离，以标准差为单位。可以对不同分布的各原始分数进行比较，用来反映数据的相对变化趋势，而非绝对变化量。 data_ori &lt;- &quot;Grp_1;Grp_2;Grp_3;Grp_4;Grp_5 a;6.6;20.9;100.1;600.0;5.2 b;20.8;99.8;700.0;3.7;19.2 c;100.0;800.0;6.2;21.4;98.6 d;900;3.3;20.3;101.1;10000&quot; data &lt;- read.table(text=data_ori, header=T, row.names=1, sep=&quot;;&quot;, quote=&quot;&quot;) # 去掉方差为0的行，也就是值全都一致的行 data &lt;- data[apply(data,1,var)!=0,] data ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a 6.6 20.9 100.1 600.0 5.2 ## b 20.8 99.8 700.0 3.7 19.2 ## c 100.0 800.0 6.2 21.4 98.6 ## d 900.0 3.3 20.3 101.1 10000.0 # 标准化数据，并转换为data.frame data_scale &lt;- as.data.frame(t(apply(data,1,scale))) # 重命名列 colnames(data_scale) &lt;- colnames(data) data_scale ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a -0.5456953 -0.4899405 -0.1811446 1.7679341 -0.5511538 ## b -0.4940465 -0.2301542 1.7747592 -0.5511674 -0.4993911 ## c -0.3139042 1.7740182 -0.5936858 -0.5483481 -0.3180801 ## d -0.2983707 -0.5033986 -0.4995116 -0.4810369 1.7823177 data_scale$ID = rownames(data_scale) data_scale_m = melt(data_scale, id.vars=c(&quot;ID&quot;)) data_scale_m$value &lt;- as.numeric(prettyNum(data_scale_m$value, digits=2)) p &lt;- ggplot(data_scale_m, aes(x=variable,y=ID)) + xlab(&quot;samples&quot;) + ylab(NULL) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) + geom_tile(aes(fill=value)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + geom_text(aes(label=value)) p #ggsave(p, filename=&quot;heatmap_scale.pdf&quot;, width=8, height=12, units=c(&quot;cm&quot;), # colormodel=&quot;srgb&quot;) Z-score转换后，颜色分布也相对均一了，每个基因在不同样品之间的表达的高低一目了然。但是不同基因之间就完全不可比了。 3.3.3 抹去异常值 粗暴一点，假设检测饱和度为100，大于100的值都视为100对待。 data_ori &lt;- &quot;Grp_1;Grp_2;Grp_3;Grp_4;Grp_5 a;6.6;20.9;100.1;600.0;5.2 b;20.8;99.8;700.0;3.7;19.2 c;100.0;800.0;6.2;21.4;98.6 d;900;3.3;20.3;101.1;10000&quot; data &lt;- read.table(text=data_ori, header=T, row.names=1, sep=&quot;;&quot;, quote=&quot;&quot;) data[data&gt;100] &lt;- 100 data ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a 6.6 20.9 100.0 100.0 5.2 ## b 20.8 99.8 100.0 3.7 19.2 ## c 100.0 100.0 6.2 21.4 98.6 ## d 100.0 3.3 20.3 100.0 100.0 data$ID = rownames(data) data_m = melt(data, id.vars=c(&quot;ID&quot;)) p &lt;- ggplot(data_m, aes(x=variable,y=ID)) + xlab(&quot;samples&quot;) + ylab(NULL) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) + geom_tile(aes(fill=value)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + geom_text(aes(label=value)) p #ggsave(p, filename=&quot;heatmap_nooutlier.pdf&quot;, width=8, height=12, units=c(&quot;cm&quot;), # colormodel=&quot;srgb&quot;) 虽然损失了一部分信息，但整体模式还是出来了。但是在选择异常值标准时需要根据实际确认。 3.3.4 非线性颜色 正常来讲，颜色的赋予在最小值到最大值之间是均匀分布的。如果最小值到最大值之间用100个颜色区分，则其中每一个bin，不论其大小、有没有值都会赋予一个颜色。非线性颜色则是对数据比较小但密集的地方赋予更多颜色，数据大但分布散的地方赋予更少颜色，这样既能加大区分度，又最小的影响原始数值。通常可以根据数据模式，手动设置颜色区间。为了方便自动化处理，也可选择用四分位数的方式设置颜色区间。 data_ori &lt;- &quot;Grp_1;Grp_2;Grp_3;Grp_4;Grp_5 a;6.6;20.9;100.1;600.0;5.2 b;20.8;99.8;700.0;3.7;19.2 c;100.0;800.0;6.2;21.4;98.6 d;900;3.3;20.3;101.1;10000&quot; data &lt;- read.table(text=data_ori, header=T, row.names=1, sep=&quot;;&quot;, quote=&quot;&quot;) data ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a 6.6 20.9 100.1 600.0 5.2 ## b 20.8 99.8 700.0 3.7 19.2 ## c 100.0 800.0 6.2 21.4 98.6 ## d 900.0 3.3 20.3 101.1 10000.0 获取数据的最大、最小、第一四分位数、中位数、第三四分位数 data$ID = rownames(data) data_m = melt(data, id.vars=c(&quot;ID&quot;)) summary_v &lt;- summary(data_m$value) summary_v ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 3.30 16.05 60.00 681.36 225.82 10000.00 在最小值和第一四分位数之间划出6个区间，第一四分位数和中位数之间划出6个区间，中位数和第三四分位数之间划出5个区间，最后的数划出5个区间 break_v &lt;- unique(c(seq(summary_v[1]*0.95,summary_v[2],length=6), seq(summary_v[2],summary_v[3],length=6),seq(summary_v[3],summary_v[5],length=5), seq(summary_v[5],summary_v[6]*1.05,length=5))) break_v ## [1] 3.1350 5.7180 8.3010 10.8840 13.4670 16.0500 ## [7] 24.8400 33.6300 42.4200 51.2100 60.0000 101.4562 ## [13] 142.9125 184.3687 225.8250 2794.3687 5362.9125 7931.4562 ## [19] 10500.0000 按照设定的区间分割数据, 原始数据替换为了其所在的区间的数值 data_m$value &lt;- cut(data_m$value, breaks=break_v,labels=break_v[2:length(break_v)]) break_v=unique(data_m$value) data_m ## ID variable value ## 1 a Grp_1 8.301 ## 2 b Grp_1 24.84 ## 3 c Grp_1 101.45625 ## 4 d Grp_1 2794.36875 ## 5 a Grp_2 24.84 ## 6 b Grp_2 101.45625 ## 7 c Grp_2 2794.36875 ## 8 d Grp_2 5.718 ## 9 a Grp_3 101.45625 ## 10 b Grp_3 2794.36875 ## 11 c Grp_3 8.301 ## 12 d Grp_3 24.84 ## 13 a Grp_4 2794.36875 ## 14 b Grp_4 5.718 ## 15 c Grp_4 24.84 ## 16 d Grp_4 101.45625 ## 17 a Grp_5 5.718 ## 18 b Grp_5 24.84 ## 19 c Grp_5 101.45625 ## 20 d Grp_5 10500 虽然看上去还是数值，但已经不是数字类型了，而是不同的因子了，这样就可以对不同的因子赋予不同的颜色了 is.numeric(data_m$value) ## [1] FALSE is.factor(data_m$value) ## [1] TRUE break_v ## [1] 8.301 24.84 101.45625 2794.36875 5.718 10500 ## 18 Levels: 5.718 8.301 10.884 13.467 16.05 24.84 33.63 42.42 51.21 ... 10500 产生对应数目的颜色 gradientC=c(&#39;green&#39;,&#39;yellow&#39;,&#39;red&#39;) col &lt;- colorRampPalette(gradientC)(length(break_v)) col ## [1] &quot;#00FF00&quot; &quot;#66FF00&quot; &quot;#CCFF00&quot; &quot;#FFCB00&quot; &quot;#FF6500&quot; &quot;#FF0000&quot; p &lt;- ggplot(data_m, aes(x=variable,y=ID)) + xlab(&quot;samples&quot;) + ylab(NULL) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) + geom_tile(aes(fill=value)) # 与上面不同的地方，使用的是scale_fill_manual逐个赋值 p &lt;- p + scale_fill_manual(values=col) p #ggsave(p, filename=&quot;heatmap_nonlinear.pdf&quot;, width=8, height=12, units=c(&quot;cm&quot;),colormodel=&quot;srgb&quot;) 3.3.5 调整行或列的顺序 如果想保持图中每一行的顺序与输入的数据框一致，需要设置因子的水平。这也是ggplot2中调整图例或横纵轴字符顺序的常用方式。 data_rowname &lt;- rownames(data) data_rowname &lt;- as.vector(rownames(data)) data_rownames &lt;- rev(data_rowname) data_log_m$ID &lt;- factor(data_log_m$ID, levels=data_rownames, ordered=T) p &lt;- ggplot(data_log_m, aes(x=variable,y=ID)) + xlab(NULL) + ylab(NULL) + theme_bw() + theme(panel.grid.major = element_blank()) + theme(legend.key=element_blank()) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) + theme(legend.position=&quot;top&quot;) + geom_tile(aes(fill=value)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) p #ggsave(p, filename=&quot;heatmap_log.pdf&quot;, width=8, height=12, units=c(&quot;cm&quot;),colormodel=&quot;srgb&quot;) 基于ggplot2的heatmap绘制到现在就差不多了，但总是这么画下去也会觉得有点累，有没有办法更简化呢？。 3.4 热图绘制 - pheatmap 绘制热图除了使用ggplot2，还可以有其它的包或函数，比如pheatmap::pheatmap (pheatmap包中的pheatmap函数)、gplots::heatmap.2等。 相比于ggplot2作heatmap, pheatmap会更为简单一些，一个函数设置不同的参数，可以完成行列聚类、行列注释、Z-score计算、颜色自定义等。那我们来看看效果怎样。 data_ori &lt;- &quot;Grp_1;Grp_2;Grp_3;Grp_4;Grp_5 a;6.6;20.9;100.1;600.0;5.2 b;20.8;99.8;700.0;3.7;19.2 c;100.0;800.0;6.2;21.4;98.6 d;900;3.3;20.3;101.1;10000&quot; data &lt;- read.table(text=data_ori, header=T, row.names=1, sep=&quot;;&quot;, quote=&quot;&quot;) #pheatmap::pheatmap(data, filename=&quot;pheatmap_1.pdf&quot;) pheatmap::pheatmap(data) 虽然有点丑，但一步就出来了。 在heatmap美化篇提到的数据前期处理方式，都可以用于pheatmap的画图。此外Z-score计算在pheatmap中只要一个参数就可以实现。 pheatmap::pheatmap(data, scale=&quot;row&quot;) 有时可能不需要行或列的聚类，原始展示就可以了。 pheatmap::pheatmap(data, scale=&quot;row&quot;, cluster_rows=FALSE, cluster_cols=FALSE) 给矩阵 (data)中行和列不同的分组注释。假如有两个文件，第一个文件为行注释，其第一列与矩阵中的第一列内容相同 (顺序没有关系)，其它列为第一列的不同的标记，如下面示例中(假设行为基因，列为样品)的2,3列对应基因的不同类型 (TF or enzyme)和不同分组。第二个文件为列注释，其第一列与矩阵中第一行内容相同，其它列则为样品的注释。 row_anno = data.frame(type=c(&quot;TF&quot;,&quot;Enzyme&quot;,&quot;Enzyme&quot;,&quot;TF&quot;), class=c(&quot;clu1&quot;,&quot;clu1&quot;,&quot;clu2&quot;,&quot;clu2&quot;), row.names=rownames(data)) row_anno ## type class ## a TF clu1 ## b Enzyme clu1 ## c Enzyme clu2 ## d TF clu2 col_anno = data.frame(grp=c(&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;), size=1:5, row.names=colnames(data)) col_anno ## grp size ## Grp_1 A 1 ## Grp_2 A 2 ## Grp_3 A 3 ## Grp_4 B 4 ## Grp_5 B 5 pheatmap::pheatmap(data, scale=&quot;row&quot;, cluster_rows=FALSE, annotation_col=col_anno, annotation_row=row_anno) 自定义下颜色吧。 # &lt;bias&gt; values larger than 1 will give more color for high end. # Values between 0-1 will give more color for low end. pheatmap::pheatmap(data, scale=&quot;row&quot;, cluster_rows=FALSE, annotation_col=col_anno, annotation_row=row_anno, color=colorRampPalette(c(&#39;green&#39;,&#39;yellow&#39;,&#39;red&#39;), bias=1)(50)) heatmap.2的使用在上一期转录组分析绘制相关性热图时有提到，这次就不介绍了，跟pheatmap有些类似，而且也有不少教程。 3.5 聚类热图如何按自己的意愿调整分支顺序？ 3.5.1 数据示例 exprTable &lt;- read.table(&quot;exprTable.txt&quot;, sep=&quot;\\t&quot;, row.names=1, header=T, check.names = F) exprTable ## Zygote 2_cell 4_cell 8_cell Morula ICM ## Pou5f1 1.0 2.0 4.0 8.0 16.0 32.0 ## Sox2 0.5 1.0 2.0 4.0 8.0 16.0 ## Gata2 0.3 0.6 1.3 2.6 5.2 10.4 ## cMyc 10.4 5.2 2.6 1.3 0.6 0.3 ## Tet1 16.0 8.0 4.0 2.0 1.0 0.5 ## Tet3 32.0 16.0 8.0 4.0 2.0 1.0 测试时直接拷贝这个数据即可 ## Zygote 2_cell 4_cell 8_cell Morula ICM ## Pou5f1 1.0 2.0 4.0 8.0 16.0 32.0 ## Sox2 0.5 1.0 2.0 4.0 8.0 16.0 ## Gata2 0.3 0.6 1.3 2.6 5.2 10.4 ## cMyc 10.4 5.2 2.6 1.3 0.6 0.3 ## Tet1 16.0 8.0 4.0 2.0 1.0 0.5 ## Tet3 32.0 16.0 8.0 4.0 2.0 1.0 3.5.2 绘制一个聚类热图很简单 library(pheatmap) pheatmap(exprTable) 3.5.3 如何自定义分支顺序呢 自己做个hclust传进去，顺序跟pheatmap默认是一样的 exprTable_t &lt;- as.data.frame(t(exprTable)) col_dist = dist(exprTable_t) hclust_1 &lt;- hclust(col_dist) pheatmap(exprTable, cluster_cols = hclust_1) 3.5.4 人为指定顺序排序样品 按发育时间排序样品 manual_order = c(&quot;Zygote&quot;, &quot;2_cell&quot;, &quot;4_cell&quot;, &quot;8_cell&quot;, &quot;Morula&quot;, &quot;ICM&quot;) dend = reorder(as.dendrogram(hclust_1), wts=order(match(manual_order, rownames(exprTable_t)))) # 默认为mean，无效时使用其他函数尝试 # dend = reorder(as.dendrogram(hclust_1), wts=order(match(manual_order, rownames(exprTable_t))), agglo.FUN = max) col_cluster &lt;- as.hclust(dend) pheatmap(exprTable, cluster_cols = col_cluster) 3.5.5 按某个基因的表达由小到大排序 可以按任意指标排序，基因表达是一个例子。 dend = reorder(as.dendrogram(hclust_1), wts=exprTable_t$Tet3) col_cluster &lt;- as.hclust(dend) pheatmap(exprTable, cluster_cols = col_cluster) 3.5.6 按某个基因的表达由大到小排序 dend = reorder(as.dendrogram(hclust_1), wts=exprTable_t$Tet3*(-1)) col_cluster &lt;- as.hclust(dend) pheatmap(exprTable, cluster_cols = col_cluster) 3.5.7 按分支名字（样品名字）的字母顺序排序 library(dendextend) ## ## --------------------- ## Welcome to dendextend version 1.19.1 ## Type citation(&#39;dendextend&#39;) for how to cite the package. ## ## Type browseVignettes(package = &#39;dendextend&#39;) for the package vignette. ## The github page is: https://github.com/talgalili/dendextend/ ## ## Suggestions and bug-reports can be submitted at: https://github.com/talgalili/dendextend/issues ## You may ask questions at stackoverflow, use the r and dendextend tags: ## https://stackoverflow.com/questions/tagged/dendextend ## ## To suppress this message use: suppressPackageStartupMessages(library(dendextend)) ## --------------------- ## ## Attaching package: &#39;dendextend&#39; ## The following object is masked from &#39;package:ggpubr&#39;: ## ## rotate ## The following object is masked from &#39;package:stats&#39;: ## ## cutree col_cluster &lt;- hclust_1 %&gt;% as.dendrogram %&gt;% sort %&gt;% as.hclust pheatmap(exprTable, cluster_cols = col_cluster) 3.5.8 梯子形排序：最小的分支在右侧 col_cluster &lt;- hclust_1 %&gt;% as.dendrogram %&gt;% ladderize(TRUE) %&gt;% as.hclust pheatmap(exprTable, cluster_cols = col_cluster) 3.5.9 梯子形排序：最小的分支在左侧 col_cluster &lt;- hclust_1 %&gt;% as.dendrogram %&gt;% ladderize(FALSE) %&gt;% as.hclust pheatmap(exprTable, cluster_cols = col_cluster) 3.5.10 按特征值排序 样本量多时的自动较忧排序 sv = svd(exprTable)$v[,1] dend = reorder(as.dendrogram(hclust_1), wts=sv) col_cluster &lt;- as.hclust(dend) pheatmap(exprTable, cluster_cols = col_cluster) exprTable_cor &lt;- cor(exprTable) exprTable_cor ## Zygote 2_cell 4_cell 8_cell Morula ICM ## Zygote 1.0000000 0.9971095 0.8866720 -0.2367354 -0.6001460 -0.6591611 ## 2_cell 0.9971095 1.0000000 0.9192236 -0.1622662 -0.5376675 -0.6001460 ## 4_cell 0.8866720 0.9192236 1.0000000 0.2393477 -0.1622662 -0.2367354 ## 8_cell -0.2367354 -0.1622662 0.2393477 1.0000000 0.9192236 0.8866720 ## Morula -0.6001460 -0.5376675 -0.1622662 0.9192236 1.0000000 0.9971095 ## ICM -0.6591611 -0.6001460 -0.2367354 0.8866720 0.9971095 1.0000000 pheatmap(exprTable_cor, cluster_rows = T, cluster_cols = T) cor_cluster = hclust(as.dist(1-exprTable_cor)) pheatmap(exprTable_cor, cluster_rows = cor_cluster, cluster_cols = cor_cluster) cor_sum &lt;- rowSums(exprTable_cor) dend = reorder(as.dendrogram(cor_cluster), wts=cor_sum) col_cluster &lt;- as.hclust(dend) pheatmap(exprTable_cor, cluster_rows = col_cluster, cluster_cols = col_cluster) manual_order = c(&quot;Zygote&quot;, &quot;2_cell&quot;, &quot;4_cell&quot;, &quot;8_cell&quot;, &quot;Morula&quot;, &quot;ICM&quot;) dend = reorder(as.dendrogram(cor_cluster), wts=order(match(manual_order, rownames(exprTable_cor))),agglo.FUN = max) col_cluster &lt;- as.hclust(dend) pheatmap(exprTable_cor, cluster_rows = col_cluster, cluster_cols = col_cluster) 3.6 箱线图 箱线图是能同时反映数据统计量和整体分布，又很漂亮的展示图。在2014年的Nature Method上有2篇Correspondence论述了使用箱线图的好处和一个在线绘制箱线图的工具。就这样都可以发两篇Nature method，没天理，但也说明了箱线图的重要意义。 下面这张图展示了Bar plot、Box plot、Volin plot和Bean plot对数据分布的反应。从Bar plot上只能看到数据标准差或标准误不同；Box plot可以看到数据分布的集中性不同；Violin plot和Bean plot展示的是数据真正的分布，尤其是对Biomodal数据的展示。 Boxplot从下到上展示的是最小值，第一四分位数 (箱子的下边线)、中位数 (箱子中间的线)、第三四分位数 (箱子上边线)、最大值，具体解读参见 http://mp.weixin.qq.com/s/t3UTI_qAIi0cy1g6ZmHtwg。 Nature Method文章 http://www.nature.com/nmeth/journal/v11/n2/full/nmeth.2811.html 3.6.1 一步步解析箱线图绘制 假设有这么一个基因表达矩阵，第一列为基因名字，第一行为样品名字，想绘制样品中基因表达的整体分布。 profile=&quot;Name;2cell_1;2cell_2;2cell_3;4cell_1;4cell_2;4cell_3;zygote_1;zygote_2;zygote_3 A;4;6;7;3.2;5.2;5.6;2;4;3 B;6;8;9;5.2;7.2;7.6;4;6;5 C;8;10;11;7.2;9.2;9.6;6;8;7 D;10;12;13;9.2;11.2;11.6;8;10;9 E;12;14;15;11.2;13.2;13.6;10;12;11 F;14;16;17;13.2;15.2;15.6;12;14;13 G;15;17;18;14.2;16.2;16.6;13;15;14 H;16;18;19;15.2;17.2;17.6;14;16;15 I;17;19;20;16.2;18.2;18.6;15;17;16 J;18;20;21;17.2;19.2;19.6;16;18;17 L;19;21;22;18.2;20.2;20.6;17;19;18 M;20;22;23;19.2;21.2;21.6;18;20;19 N;21;23;24;20.2;22.2;22.6;19;21;20 O;22;24;25;21.2;23.2;23.6;20;22;21&quot; 读入数据并转换为ggplot2需要的长数据表格式，好好体会下这个格式，虽然多占用了不少空间，但是确实很方便。 profile_text &lt;- read.table(text=profile, header=T, row.names=1, quote=&quot;&quot;,sep=&quot;;&quot;, check.names=F) # 在melt时保留位置信息 # melt格式是ggplot2画图最喜欢的格式 # library(ggplot2) library(reshape2) data_m &lt;- melt(profile_text) ## No id variables; using all as measure variables head(data_m) ## variable value ## 1 2cell_1 4 ## 2 2cell_1 6 ## 3 2cell_1 8 ## 4 2cell_1 10 ## 5 2cell_1 12 ## 6 2cell_1 14 summary(data_m) ## variable value ## 2cell_1:14 Min. : 2.00 ## 2cell_2:14 1st Qu.:10.25 ## 2cell_3:14 Median :16.00 ## 4cell_1:14 Mean :14.87 ## 4cell_2:14 3rd Qu.:19.20 ## 4cell_3:14 Max. :25.00 ## (Other):42 variable和value为矩阵melt后的两列的名字，内部变量, 可以通过?melt查看如何修改。variable代表了点线的属性，value代表对应的值。 像往常一样，就可以直接画图了。 p &lt;- ggplot(data_m, aes(x=variable, y=value,color=variable)) + geom_boxplot() + theme(axis.text.x=element_text(angle=50,hjust=0.5, vjust=0.5)) + theme(legend.position=&quot;none&quot;) p # 图会存储在当前目录的Rplots.pdf文件中，如果用Rstudio，可以不运行dev.off() # dev.off() 箱线图出来了，看上去还可以，再加点色彩 (fill)。 # variable和value为矩阵melt后的两列的名字，内部变量, variable代表了点线的属性，value代表对应的值。 p &lt;- ggplot(data_m, aes(x=variable, y=value)) + geom_boxplot(aes(fill=factor(variable))) + theme(axis.text.x=element_text(angle=50,hjust=0.5, vjust=0.5)) + theme(legend.position=&quot;none&quot;) p # 图会存储在当前目录的Rplots.pdf文件中，如果用Rstudio，可以不运行dev.off() #dev.off() 再看看Violin plot # variable和value为矩阵melt后的两列的名字，内部变量, variable代表了点线的属性，value代表对应的值。 p &lt;- ggplot(data_m, aes(x=variable, y=value)) + geom_violin(aes(fill=factor(variable))) + theme(axis.text.x=element_text(angle=50,hjust=0.5, vjust=0.5)) + theme(legend.position=&quot;none&quot;) p # 图会存储在当前目录的Rplots.pdf文件中，如果用Rstudio，可以不运行dev.off() #dev.off() # variable和value为矩阵melt后的两列的名字，内部变量, variable代表了点线的属性，value代表对应的值。 p &lt;- ggplot(data_m, aes(x=variable, y=value)) + geom_jitter(aes(color=factor(variable))) + theme(axis.text.x=element_text(angle=50,hjust=0.5, vjust=0.5)) + theme(legend.position=&quot;none&quot;) p # 图会存储在当前目录的Rplots.pdf文件中，如果用Rstudio，可以不运行dev.off() #dev.off() 还有Jitter plot (这里使用的是ggbeeswarm包) library(ggbeeswarm) # 为了更好的效果，只保留其中一个样品的数据 # grepl类似于Linux的grep命令，获取特定模式的字符串 data_m2 &lt;- data_m[grepl(&quot;_3&quot;, data_m$variable),] # variable和value为矩阵melt后的两列的名字，内部变量, # variable代表了点线的属性，value代表对应的值。 p &lt;- ggplot(data_m2, aes(x=variable, y=value),color=variable) + geom_quasirandom(aes(colour=factor(variable))) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), legend.key=element_blank()) + theme(legend.position=&quot;none&quot;) p #ggsave(p, filename=&quot;jitterplot.pdf&quot;, width=14, height=8, units=c(&quot;cm&quot;)) 也可以用geom_jitter(aes(colour=factor(variable)))代替geom_quasirandom(aes(colour=factor(variable)))绘制抖动图，但个人认为geom_quasirandom给出的结果更有特色。 3.6.2 绘制单个基因 (A)的箱线图 为了更好的展示效果，下面的矩阵增加了样品数量和样品的分组信息。 #profile=&quot;Name;2cell_1;2cell_2;2cell_3;2cell_4;2cell_5;2cell_6;4cell_1;4cell_2;4cell_3;\\ #4cell_4;4cell_5;4cell_6;zygote_1;zygote_2;zygote_3;zygote_4;zygote_5;zygote_6 #A;4;6;7;5;8;6;3.2;5.2;5.6;3.6;7.6;4.8;2;4;3;2;4;2.5 #B;6;8;9;7;10;8;5.2;7.2;7.6;5.6;9.6;6.8;4;6;5;4;6;4.5&quot; profile_text &lt;- read.table(&quot;data/boxplot_singleGene.data.txt&quot;, header=T, row.names=1, quote=&quot;&quot;, sep=&quot;\\t&quot;, check.names=F) data_m = data.frame(t(profile_text[&#39;A&#39;,])) data_m$sample = rownames(data_m) # 只挑选显示部分 # grepl前面已经讲过用于匹配 data_m[grepl(&#39;_[123]&#39;, data_m$sample),] ## A sample ## 2cell_1 4.0 2cell_1 ## 2cell_2 6.0 2cell_2 ## 2cell_3 7.0 2cell_3 ## 4cell_1 3.2 4cell_1 ## 4cell_2 5.2 4cell_2 ## 4cell_3 5.6 4cell_3 ## zygote_1 2.0 zygote_1 ## zygote_2 4.0 zygote_2 ## zygote_3 3.0 zygote_3 获得样品分组信息 (这个例子比较特殊，样品的分组信息就是样品名字下划线前面的部分) # 可以利用strsplit分割，取出其前面的字符串 # R中复杂的输出结果多数以列表的形式体现，在之前的矩阵操作教程中 # 提到过用str函数来查看复杂结果的结构，并从中获取信息 group = unlist(lapply(strsplit(data_m$sample,&quot;_&quot;), function(x) x[1])) data_m$group = group data_m[grepl(&#39;_[123]&#39;, data_m$sample),] ## A sample group ## 2cell_1 4.0 2cell_1 2cell ## 2cell_2 6.0 2cell_2 2cell ## 2cell_3 7.0 2cell_3 2cell ## 4cell_1 3.2 4cell_1 4cell ## 4cell_2 5.2 4cell_2 4cell ## 4cell_3 5.6 4cell_3 4cell ## zygote_1 2.0 zygote_1 zygote ## zygote_2 4.0 zygote_2 zygote ## zygote_3 3.0 zygote_3 zygote 如果没有这个规律，也可以提到类似于下面的文件，指定样品所属的组的信息。 sampleGroup_text=&quot;Sample;Group zygote_1;zygote zygote_2;zygote zygote_3;zygote zygote_4;zygote zygote_5;zygote zygote_6;zygote 2cell_1;2cell 2cell_2;2cell 2cell_3;2cell 2cell_4;2cell 2cell_5;2cell 2cell_6;2cell 4cell_1;4cell 4cell_2;4cell 4cell_3;4cell 4cell_4;4cell 4cell_5;4cell 4cell_6;4cell&quot; #sampleGroup = read.table(text=sampleGroup_text,sep=&quot;\\t&quot;,header=1,check.names=F,row.names=1) #data_m &lt;- merge(data_m, sampleGroup, by=&quot;row.names&quot;) # 会获得相同的结果，脚本注释掉了以免重复执行引起问题。 矩阵准备好了，开始画图了 (小提琴图做例子，其它类似) # 调整下样品出现的顺序 data_m$group &lt;- factor(data_m$group, levels=c(&quot;zygote&quot;,&quot;2cell&quot;,&quot;4cell&quot;)) # group和A为矩阵中两列的名字，group代表了值的属性，A代表基因A对应的表达值。 # 注意看修改了的地方 p &lt;- ggplot(data_m, aes(x=group, y=A)) + geom_violin(aes(fill=factor(group))) + theme(axis.text.x=element_text(angle=50,hjust=0.5, vjust=0.5)) + theme(legend.position=&quot;none&quot;) p # 图会存储在当前目录的Rplots.pdf文件中，如果用Rstudio，可以不运行dev.off() #dev.off() 3.6.3 长矩阵绘制箱线图 常规矩阵绘制箱线图要求必须是个方正的矩阵输入，而有时想比较的几个组里面检测的值数目不同。比如有三个组，GrpA组检测了6个病人，GrpB组检测了10个病人，GrpC组是12个正常人的检测数据。这时就很难形成一个行为检测值，列为样品的矩阵，就需要长表格模式解决这一问题。 long_table &lt;- &quot;Grp;Value GrpA;10 GrpA;11 GrpA;11 GrpA;11 GrpA;12 GrpA;11 GrpA;15 GrpB;5 GrpB;4 GrpB;3 GrpB;2 GrpB;4 GrpB;3 GrpB;2 GrpB;3 GrpB;3.1 GrpC;2 GrpC;1 GrpC;1 GrpC;1.1 GrpC;1.5 GrpC;1.1 GrpC;1.5 GrpC;1.8 GrpC;2&quot; long_table &lt;- read.table(text=long_table,sep=&quot;;&quot;,header=T,check.names=F) p &lt;- ggplot(long_table, aes(x=Grp, y=Value)) + geom_violin(aes(fill=factor(Grp))) + theme(axis.text.x=element_text(angle=50,hjust=0.5, vjust=0.5)) + theme(legend.position=&quot;none&quot;) p a = c(rep(c(&#39;F&#39;,&quot;M&quot;),12), &#39;F&#39;) long_table$gender &lt;- a p &lt;- ggplot(long_table, aes(x=Grp, y=Value)) + geom_boxplot(aes(fill=factor(gender))) + geom_quasirandom() p 长表格形式自身就是常规矩阵melt后的格式，这种用来绘制箱线图就很简单了，就不举例子了。 3.7 线图 线图是反映趋势变化的一种方式，其输入数据一般也是一个矩阵。 3.7.1 单线图 假设有这么一个矩阵，第一列为转录起始位点及其上下游5 kb的区域，第二列为H3K27ac修饰在这些区域的丰度，想绘制一张线图展示。 profile=&quot;Pos;H3K27ac -5000;8.7 -4000;8.4 -3000;8.3 -2000;7.2 -1000;3.6 0;3.6 1000;7.1 2000;8.2 3000;8.4 4000;8.5 5000;8.5&quot; 读入数据 profile_text &lt;- read.table(text=profile, header=T, row.names=NULL, quote=&quot;&quot;,sep=&quot;;&quot;) profile_text ## Pos H3K27ac ## 1 -5000 8.7 ## 2 -4000 8.4 ## 3 -3000 8.3 ## 4 -2000 7.2 ## 5 -1000 3.6 ## 6 0 3.6 ## 7 1000 7.1 ## 8 2000 8.2 ## 9 3000 8.4 ## 10 4000 8.5 ## 11 5000 8.5 plot(profile_text$Pos, profile_text$H3K27ac,type = &quot;l&quot;) ggplot(profile_text, aes(x=Pos, y=H3K27ac)) + geom_line() profile_text &lt;- read.table(text=profile, header=T, row.names=1, quote=&quot;&quot;,sep=&quot;;&quot;) profile_text ## H3K27ac ## -5000 8.7 ## -4000 8.4 ## -3000 8.3 ## -2000 7.2 ## -1000 3.6 ## 0 3.6 ## 1000 7.1 ## 2000 8.2 ## 3000 8.4 ## 4000 8.5 ## 5000 8.5 # 在melt时保留位置信息 # melt格式是ggplot2画图最喜欢的格式 # 好好体会下这个格式，虽然多占用了不少空间，但是确实很方便 # 这里可以用 `xvariable`，也可以是其它字符串，但需要保证后面与这里的一致 # 因为这一列是要在X轴显示，所以起名为`xvariable`。 profile_text$xvariable = rownames(profile_text) #library(ggplot2) #library(reshape2) data_m &lt;- melt(profile_text, id.vars=c(&quot;xvariable&quot;)) data_m ## xvariable variable value ## 1 -5000 H3K27ac 8.7 ## 2 -4000 H3K27ac 8.4 ## 3 -3000 H3K27ac 8.3 ## 4 -2000 H3K27ac 7.2 ## 5 -1000 H3K27ac 3.6 ## 6 0 H3K27ac 3.6 ## 7 1000 H3K27ac 7.1 ## 8 2000 H3K27ac 8.2 ## 9 3000 H3K27ac 8.4 ## 10 4000 H3K27ac 8.5 ## 11 5000 H3K27ac 8.5 然后开始画图，与上面画heatmap一样。 # variable和value为矩阵melt后的两列的名字，内部变量, variable代表了点线的属性，value代表对应的值。 p &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable)) + geom_line() p ## `geom_line()`: Each group consists of ## only one observation. ## ℹ Do you need to adjust the group ## aesthetic? # 图会存储在当前目录的Rplots.pdf文件中，如果用Rstudio，可以不运行dev.off() # dev.off() 满心期待一个倒钟形曲线，结果，什么也没有。 仔细看，出来一段提示 geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? 原来默认ggplot2把每个点都视作了一个分组，什么都没画出来。而data_m中的数据都来源于一个分组H3K27ac，分组的名字为variable，修改下脚本，看看效果。 p &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable,group=variable)) + geom_line() + theme(legend.position=c(0.1,0.9)) p # dev.off() 图出来了，一条线，看一眼没问题；再仔细看，不对了，怎么还不是倒钟形，原来横坐标错位了。 检查下数据格式 summary(data_m) ## xvariable variable value ## Length:11 H3K27ac:11 Min. :3.600 ## Class :character 1st Qu.:7.150 ## Mode :character Median :8.300 ## Mean :7.318 ## 3rd Qu.:8.450 ## Max. :8.700 问题来了，xvariable虽然看上去数字，但存储的实际是字符串 (因为是作为行名字读取的)，需要转换为数字。 data_m$xvariable &lt;- as.numeric(data_m$xvariable) #再检验下 summary(data_m) ## xvariable variable value ## Min. :-5000 H3K27ac:11 Min. :3.600 ## 1st Qu.:-2500 1st Qu.:7.150 ## Median : 0 Median :8.300 ## Mean : 0 Mean :7.318 ## 3rd Qu.: 2500 3rd Qu.:8.450 ## Max. : 5000 Max. :8.700 好了，继续画图。 # 注意断行时，加号在行尾，不能放在行首 p &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable,group=variable)) + geom_line() + theme(legend.position=c(0.07,0.7)) p #dev.off() 图终于出来了，调了下legend的位置，看上去有点意思了。 有点难看，如果平滑下，会不会好一些，stat_smooth可以对绘制的线进行局部拟合。在不影响变化趋势的情况下，可以使用 (但慎用)。 p &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable,group=variable)) + geom_line() + stat_smooth(method=&quot;auto&quot;, se=FALSE) + theme(legend.position=c(0.06,0.5)) p ## `geom_smooth()` using method = ## &#39;loess&#39; and formula = &#39;y ~ x&#39; #dev.off() 从图中看，趋势还是一致的，线条更优美了。另外一个方式是增加区间的数量，线也会好些，而且更真实。 stat_smooth和geom_line各绘制了一条线，只保留一条就好。 p &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable,group=variable)) + stat_smooth(method=&quot;auto&quot;, se=FALSE) + theme(legend.position=c(0.06,0.5)) p ## `geom_smooth()` using method = ## &#39;loess&#39; and formula = &#39;y ~ x&#39; #dev.off() 好了，终于完成了单条线图的绘制。 3.7.2 多线图 那么再来一个多线图的例子吧，只要给之前的数据矩阵多加几列就好了。 profile = &quot;Pos;h3k27ac;ctcf;enhancer;h3k4me3;polII -5000;8.7;10.7;11.7;10;8.3 -4000;8.4;10.8;11.8;9.8;7.8 -3000;8.3;10.5;12.2;9.4;7 -2000;7.2;10.9;12.7;8.4;4.8 -1000;3.6;8.5;12.8;4.8;1.3 0;3.6;8.5;13.4;5.2;1.5 1000;7.1;10.9;12.4;8.1;4.9 2000;8.2;10.7;12.4;9.5;7.7 3000;8.4;10.4;12;9.8;7.9 4000;8.5;10.6;11.7;9.7;8.2 5000;8.5;10.6;11.7;10;8.2&quot; profile_text &lt;- read.table(text=profile, header=T, row.names=1, quote=&quot;&quot;,sep=&quot;;&quot;) profile_text$xvariable = rownames(profile_text) data_m &lt;- melt(profile_text, id.vars=c(&quot;xvariable&quot;)) data_m$xvariable &lt;- as.numeric(data_m$xvariable) # 这里group=variable，而不是group=1 (如果上面你用的是1的话) # variable和value为矩阵melt后的两列的名字，内部变量, # variable代表了点线的属性，value代表对应的值。 p &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable,group=variable)) + stat_smooth(method=&quot;auto&quot;, se=FALSE) + theme(legend.position=c(0.85,0.2)) p ## `geom_smooth()` using method = ## &#39;loess&#39; and formula = &#39;y ~ x&#39; #dev.off() 3.7.3 横轴文本线图 如果横轴是文本，又该怎么调整顺序呢？还记得之前热图旁的行或列的顺序调整吗？重新设置变量的factor水平就可以控制其顺序。 profile = &quot;Pos;h3k27ac;ctcf;enhancer;h3k4me3;polII -5000;8.7;10.7;11.7;10;8.3 -4000;8.4;10.8;11.8;9.8;7.8 -3000;8.3;10.5;12.2;9.4;7 -2000;7.2;10.9;12.7;8.4;4.8 -1000;3.6;8.5;12.8;4.8;1.3 0;3.6;8.5;13.4;5.2;1.5 1000;7.1;10.9;12.4;8.1;4.9 2000;8.2;10.7;12.4;9.5;7.7 3000;8.4;10.4;12;9.8;7.9 4000;8.5;10.6;11.7;9.7;8.2 5000;8.5;10.6;11.7;10;8.2&quot; profile_text &lt;- read.table(text=profile, header=T, row.names=1, quote=&quot;&quot;,sep=&quot;;&quot;) profile_text_rownames &lt;- row.names(profile_text) profile_text$xvariable = rownames(profile_text) data_m &lt;- melt(profile_text, id.vars=c(&quot;xvariable&quot;)) data_m$xvariable &lt;- factor(data_m$xvariable, levels=profile_text_rownames, ordered=T) # geom_line设置线的粗细和透明度 p1 &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable,group=variable)) + geom_line(size=1, alpha=0.9) + theme(legend.position=c(0.8,0.25)) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) # stat_smooth p2 &lt;- ggplot(data_m, aes(x=xvariable, y=value,color=variable,group=variable)) + stat_smooth(method=&quot;auto&quot;, se=FALSE) + theme(legend.position=c(0.8,0.25)) + theme(axis.text.x=element_text(angle=45,hjust=1, vjust=1)) library(&quot;cowplot&quot;) ## ## Attaching package: &#39;cowplot&#39; ## The following object is masked from &#39;package:ggpubr&#39;: ## ## get_legend plot_grid(p1,p2, labels=c(&quot;A&quot;,&quot;B&quot;), ncol=2, nrow=1) ## `geom_smooth()` using method = ## &#39;loess&#39; and formula = &#39;y ~ x&#39; #dev.off() 比较下位置信息做为数字(前面的线图)和位置信息横轴的差别。当为数值时，ggplot2会选择合适的几个刻度做标记，当为文本时，会全部标记。另外文本横轴，smooth效果不明显。 3.8 散点图 散点图在生物信息分析中是应用比较广的一个图，常见的差异基因火山图、功能富集分析泡泡图、相关性分析散点图、抖动图、PCA样品分类图等。凡是想展示分布状态的都可以用散点图。 3.8.1 横纵轴都为数字的散点图解析 绘制散点图的输入一般都是规规矩矩的矩阵，可以让不同的列分别代表X轴、Y轴、点的大小、颜色、形状、名称等。 3.8.1.1 输入数据格式 (使用火山图的输入数据为例) 火山图用于展示基因表达差异的分布，横轴为Log2 Fold Change，越偏离中心差异倍数越大；纵轴为(-1)*Log10 P_adjust，值越大差异越显著。一般横轴越偏离中心的点其纵轴值也会比较大，因此呈现火山喷发的形状。 火山图需要的数据格式如下 id: 不是必须的，但一般的软件输出结果中都会包含，表示基因名字。 log2FoldChange: 差异倍数的对数，一般的差异分析输出结果中也会给出对数处理的值, 因此程序没有提供这一步的计算操作。 padj: 多重假设检验矫正过的差异显著性P值；一般的差异分析输出结果为原始值，程序提供一个参数对其求取负对数。 significant: 可选列，标记哪些基因是上调、下调、无差异；若无此列或未在参数中指定此列，默认程序会根据padj列和log2FoldChange列根据给定的阈值自动计算差异基因，并作出不同颜色的标记。 label: 可选列，一般用于在图中标记出感兴趣的基因的名字。非-行的字符串都会标记在图上。 volcano = &quot;id;log2FoldChange;padj;significant;label E00007;4.28238;0;Samp_UP;A E00008;-1.1036;0.476466843393901;Unchanged;- E00009;-0.274368;1;Unchanged;- E00010;4.62347;7.37606076333335e-103;Samp_UP;- E00012;0.973987;0.482982440163204;Unchanged;- E00017;-1.30205;0.000555693857439792;Baodian_UP;B E00024;0.617636;2.78047837287061e-13;Unchanged;- E00033;1.48669;2.56000581595275e-60;Samp_UP;- E00034;-0.783716;0.00341521725291801;Unchanged;- E00036;2.01592;6.03136656016401e-06;Samp_UP;C E00040;-1.89657;4.73663890849056e-21;Baodian_UP;- E00041;-0.268168;0.563429434558031;Unchanged;- E00042;0.0861048;0.367700939634328;Unchanged;- E00043;-1.19328;1.42673872027352e-153;Baodian_UP;- E00044;-0.887981;2.43067804654905e-26;Unchanged;- E00047;-0.610941;5.51696648645932e-57;Unchanged;-&quot; # 数据的读取之前的R语言统计和绘图系列都已解释过，不再赘述 # 文末也有链接可直达之前的文章，新学者建议从头开始 #volcanoData &lt;- read.table(text=volcano, sep=&quot;;&quot;, header=T, quote=&quot;&quot;, check.names=F) volcanoData &lt;- read.table(&quot;data/volcano.txt&quot;, sep=&quot;\\t&quot;, header=T, row.names=NULL, quote=&quot;&quot;, check.names=F) head(volcanoData) ## id log2FoldChange padj significant label ## 1 E00007 4.282380 0.000000e+00 Samp_UP A ## 2 E00008 -1.103600 4.764668e-01 Unchanged - ## 3 E00009 -0.274368 1.000000e+00 Unchanged - ## 4 E00010 4.623470 7.376061e-103 Samp_UP - ## 5 E00012 0.973987 4.829824e-01 Unchanged - ## 6 E00017 -1.302050 5.556939e-04 Baodian_UP B dim(volcanoData) ## [1] 16 5 绘制散点图，只需要指定X轴和Y轴，再加上geom_point即可。 #library(ggplot2) p &lt;- ggplot(volcanoData, aes(x=log2FoldChange, y=padj)) p &lt;- p + geom_point() # 前面是给p不断添加图层的过程 # 单输入一个p是真正作图 # 前面有人说，上面都输完了，怎么没出图 # 就因为差了一个p p 说好的火山图的例子，但怎么也看不出喷发的态势。 对数据坐下预处理，差异大的基因padj小，先对其求取负对数，所谓负负得正，差异大的基因就会处于图的上方了。 # 从示例数据中看到，最小的padj值为0，求取负对数为正无穷。 # 实际上padj值小到一个点对我们来讲就是个数 # 所以可以给所有小于1e-6的padj都让其等于1e-6，再小也没意义 # volcanoData[volcanoData$padj&lt;1e-6, &quot;padj&quot;] &lt;- 1e-6 volcanoData$padj &lt;- (-1)* log10(volcanoData$padj) summary(volcanoData) ## id log2FoldChange padj significant ## Length:16 Min. :-1.8966 Min. :0.0000 Length:16 ## Class :character 1st Qu.:-0.9419 1st Qu.:0.4064 Class :character ## Mode :character Median :-0.2713 Median :5.6098 Mode :character ## Mean : 0.3603 Mean :3.7664 ## 3rd Qu.: 1.1022 3rd Qu.:6.0000 ## Max. : 4.6235 Max. :6.0000 ## label ## Length:16 ## Class :character ## Mode :character ## ## ## 数据中基因的上调倍数远高于下调倍数，使得出来的图是偏的，这次画图时调整下X轴的区间使图对称。 log2fc_max_abs = max(abs(volcanoData$log2FoldChange)) + 0.1 padj_max = max(volcanoData$padj) + 0.1 p &lt;- ggplot(volcanoData, aes(x=log2FoldChange, y=padj)) + geom_point() + xlim(-1*log2fc_max_abs, log2fc_max_abs) + ylim(0,padj_max) p 有点意思了，数据太少不明显，下一步加上颜色看看。 p &lt;- ggplot(volcanoData, aes(x=log2FoldChange, y=padj)) + geom_point(aes(color=significant)) + xlim(-1*log2fc_max_abs, log2fc_max_abs) + ylim(0,padj_max) p volcanoData[volcanoData$label==&quot;-&quot;, &quot;label&quot;] = NA p &lt;- ggplot(volcanoData, aes(x=log2FoldChange, y=padj)) + geom_point(aes(color=significant)) + xlim(-1*log2fc_max_abs, log2fc_max_abs) + ylim(0,padj_max) + geom_text(aes(label=label)) p 利用现有的数据，基本上就是这个样子了。虽然还不太像，原理都已经都点到了。 volcanoData$sig &lt;- ifelse( volcanoData$padj&gt;1.30103, ifelse( volcanoData$log2FoldChange&gt;=1, &quot;UP&quot;, ifelse( volcanoData$log2FoldChange&lt;=-1, &quot;DW&quot;, &quot;NoDiff&quot;) ), &quot;NoDiff&quot;) volcanoData$sig &lt;- factor(volcanoData$sig, levels=c(&quot;UP&quot;, &quot;DW&quot;, &quot;NoDiff&quot;)) summary(volcanoData) ## id log2FoldChange padj significant ## Length:16 Min. :-1.8966 Min. :0.0000 Length:16 ## Class :character 1st Qu.:-0.9419 1st Qu.:0.4064 Class :character ## Mode :character Median :-0.2713 Median :5.6098 Mode :character ## Mean : 0.3603 Mean :3.7664 ## 3rd Qu.: 1.1022 3rd Qu.:6.0000 ## Max. : 4.6235 Max. :6.0000 ## label sig ## Length:16 UP :4 ## Class :character DW :3 ## Mode :character NoDiff:9 ## ## ## 3.8.2 横纵轴都为字符串的散点图展示 3.8.2.1 输入数据格式如下 这个数据是FASTQC结果总结中的直观的查看所有样品测序碱基质量和GC含量的散点图的示例数据。 fastqc&lt;-&quot;ID;GC_quality;Base_quality Samp_1_1;PASS;PASS Samp_1_2;PASS;PASS Samp_2_1;WARN;PASS Samp_2_2;WARN;PASS Other_1_1;FAIL;FAIL Other_1_2;FAIL;FAIL&quot; fastqc_data &lt;- read.table(text=fastqc, sep=&quot;;&quot;, header=T) # 就不查看了 p &lt;- ggplot(fastqc_data, aes(x=GC_quality, y=Base_quality)) + geom_point() p p &lt;- ggplot(fastqc_data, aes(x=GC_quality, y=Base_quality)) + geom_jitter() + geom_text(aes(label=ID), position=&quot;jitter&quot;) p 六个点少了只剩下了3个，重叠在一起了，而且也不知道哪个点代表什么样品。这时需要把点抖动下，用到一个包ggbeeswarm，抖动图的神器。 library(ggbeeswarm) p &lt;- ggplot(fastqc_data, aes(x=GC_quality, y=Base_quality)) + geom_quasirandom() # 使用geom_text增加点的标记 # label表示标记哪一列的数值 # position_quasirandom获取点偏移后的位置 # xjust调整对齐方式; hjust是水平的对齐方式，0为左，1为右，0.5居中，0-1之间可以取任意值。 # vjust是垂直对齐方式，0底对齐，1为顶对齐，0.5居中，0-1之间可以取任意值。 # check_overlap检查名字在图上是否重叠，若有重叠，只显示一个 p &lt;- p + geom_text(aes(label=ID), position=position_quasirandom(),hjust=1.1,check_overlap=T) p 3.9 功能富集泡泡图 功能富集分析用来展示某一组基因(一般是单个样品上调或下调的基因)倾向参与哪些功能调控通路，对从整体理解变化了的基因的功能和潜在的调控意义具有指导作用，也是文章发表中一个有意义的美图。通常会用柱状图、泡泡图和热图进行展示。热图的画法之前已经介绍过，这次介绍下富集分析泡泡图, 其展示的信息是最为全面的，也是比较抓人眼球的。 假设有这么一个富集分析结果矩阵 (文件名为GOenrichement.xls) 存储了Samp样品和Baodian样品中各自上调的基因富集的通路。 http://omicslab.genetics.ac.cn/GOEAST Description 为GO通路的描述，也可以是KEGG通路。 GeneRatio 为对应通路差异基因占总差异基因的比例，本列可以用分数或小数表示，都可以处理。 qvalue 表示对应通路富集的显著性程度，可以是log处理过的，也可以是原始的。 Count 为对应通路差异基因数目。 Type 这个矩阵合并了Samp样品和Baodian样品中各自上调的基因富集的通路，用Type列做区分。如果只有一个样品可不要。 Description GeneRatio qvalue Count Type ERBB signaling pathway 7/320 0.001836081 7 Samp_up regulation of ERBB signaling pathway 5/320 0.003886659 5 Samp_up negative regulation of cell cycle G1/S phase transition 4/320 0.016153254 4 Samp_up Wnt signaling pathway 13/320 0.01680096 13 Samp_up cell-cell signaling by wnt 13/320 0.0171473 13 Samp_up negative regulation of cell cycle process 8/320 0.019453085 8 Samp_up extrinsic apoptotic signaling pathway 9/320 0.024164034 9 Samp_up positive regulation of extrinsic apoptotic signaling pathway 4/320 0.025708228 4 Samp_up cell cycle G1/S phase transition 7/320 0.035797856 7 Samp_up negative regulation of apoptotic signaling pathway 8/320 0.038684745 8 Samp_up regulation of Notch signaling pathway 4/320 0.041592045 4 Samp_up regulation of cell cycle G1/S phase transition 5/320 0.047407619 5 Samp_up negative regulation of BMP signaling pathway 3/320 0.049460847 3 Samp_up regulation of ERK1 and ERK2 cascade 14/342 0.000629602 14 Baodian_up positive regulation of cell adhesion 17/342 0.000827275 17 Baodian_up ERK1 and ERK2 cascade 14/342 0.001086508 14 Baodian_up regulation of cell growth 17/342 0.002228511 17 Baodian_up positive regulation of cytoskeleton organization 10/342 0.004406867 10 Baodian_up regulation of cell-cell adhesion 15/342 0.005075219 15 Baodian_up regulation of cytoskeleton organization 15/342 0.019685646 15 Baodian_up negative regulation of Notch signaling pathway 3/342 0.020578211 3 Baodian_up neuron apoptotic process 10/342 0.040284925 10 Baodian_up enrichment = read.table(&quot;data/GOenrichement.xls&quot;, header=T, row.names=NULL, sep=&quot;\\t&quot;, quote=&quot;&quot;) head(enrichment) ## Description GeneRatio qvalue ## 1 ERBB signaling pathway 7/320 0.001836081 ## 2 regulation of ERBB signaling pathway 5/320 0.003886659 ## 3 negative regulation of cell cycle G1/S phase transition 4/320 0.016153254 ## 4 Wnt signaling pathway 13/320 0.016800960 ## 5 cell-cell signaling by wnt 13/320 0.017147300 ## 6 negative regulation of cell cycle process 8/320 0.019453085 ## Count Type ## 1 7 Samp_up ## 2 5 Samp_up ## 3 4 Samp_up ## 4 13 Samp_up ## 5 13 Samp_up ## 6 8 Samp_up 3.9.1 单样品分开绘制 示例矩阵中包含两个样品上调基因的富集通路，现在先取出一个样品绘制。 enrichment_sxbd = droplevels(enrichment[enrichment$Type==&quot;Baodian_up&quot;, ]) 构造一个函数，转换分数为小数。 library(plyr) library(stringr) library(ggplot2) library(grid) # Function get from https://stackoverflow.com/questions/10674992/convert-a-character-vector-of-mixed-numbers-fractions-and-integers-to-numeric?rq=1 # With little modifications mixedToFloat &lt;- function(x){ x &lt;- sapply(x, as.character) is.integer &lt;- grepl(&quot;^-?\\\\d+$&quot;, x) is.fraction &lt;- grepl(&quot;^-?\\\\d+\\\\/\\\\d+$&quot;, x) is.float &lt;- grepl(&quot;^-?\\\\d+\\\\.\\\\d+$&quot;, x) is.mixed &lt;- grepl(&quot;^-?\\\\d+ \\\\d+\\\\/\\\\d+$&quot;, x) stopifnot(all(is.integer | is.fraction | is.float | is.mixed)) numbers &lt;- strsplit(x, &quot;[ /]&quot;) ifelse(is.integer, as.numeric(sapply(numbers, `[`, 1)), ifelse(is.float, as.numeric(sapply(numbers, `[`, 1)), ifelse(is.fraction, as.numeric(sapply(numbers, `[`, 1)) / as.numeric(sapply(numbers, `[`, 2)), as.numeric(sapply(numbers, `[`, 1)) + as.numeric(sapply(numbers, `[`, 2)) / as.numeric(sapply(numbers, `[`, 3))))) } mixedToFloat(c(&#39;1 1/2&#39;, &#39;2 3/4&#39;, &#39;2/3&#39;, &#39;11 1/4&#39;, &#39;1&#39;)) ## [1] 1.5000000 2.7500000 0.6666667 11.2500000 1.0000000 转换数据列为小数或整数 enrichment_sxbd$GeneRatio = mixedToFloat(enrichment_sxbd$GeneRatio) enrichment_sxbd$Count = mixedToFloat(enrichment_sxbd$Count) qvalue转换负对数，并作为新的一列 # qvalue转换 log_name = paste0(&quot;negLog10_&quot;, &quot;qvalue&quot;) col_name_enrichment_sxbd &lt;- colnames(enrichment_sxbd) col_name_enrichment_sxbd &lt;- c(col_name_enrichment_sxbd, log_name) enrichment_sxbd$log_name &lt;- log10(enrichment_sxbd$qvalue) * (-1) colnames(enrichment_sxbd) &lt;- col_name_enrichment_sxbd Term排序 获取Term出现的次数 # 计算每个Term出现的顺序，用于排序，出现次数最多的排在前面 enrichment_sxbd_freq &lt;- as.data.frame(table(enrichment_sxbd$Description)) colnames(enrichment_sxbd_freq) &lt;- c(&quot;Description&quot;, &quot;IDctct&quot;) head(enrichment_sxbd_freq) ## Description IDctct ## 1 ERK1 and ERK2 cascade 1 ## 2 negative regulation of Notch signaling pathway 1 ## 3 neuron apoptotic process 1 ## 4 positive regulation of cell adhesion 1 ## 5 positive regulation of cytoskeleton organization 1 ## 6 regulation of cell growth 1 根据出现次数、GeneRatio、-log10(qvalue)排序 enrichment_sxbd2 &lt;- merge(enrichment_sxbd, enrichment_sxbd_freq, by=&quot;Description&quot;) # 首先根据出现次数排序、然后根据GeneRatio、然后根据-log10(qvalue) enrichment_sxbd3 &lt;- enrichment_sxbd2[order(enrichment_sxbd2$IDctct, enrichment_sxbd2$GeneRatio, enrichment_sxbd2$negLog10_qvalue), ] term_order &lt;- unique(enrichment_sxbd3$Description) # 设置排序顺序 enrichment_sxbd$Description &lt;- factor(enrichment_sxbd$Description, levels=term_order, ordered=T) color_v &lt;- c(&quot;green&quot;, &quot;red&quot;) # 指定x,y p &lt;- ggplot(enrichment_sxbd, aes(x=GeneRatio,y=Description)) + labs(x=&quot;GeneRatio&quot;, y=&quot;GO description&quot;) + labs(title=&quot;&quot;) p &lt;- p + geom_point(aes(size=Count, color=negLog10_qvalue )) + scale_colour_gradient(low=color_v[1], high=color_v[2], name=&quot;negLog10_qvalue&quot;) # Term单行长度不超过60字符 p &lt;- p + scale_y_discrete(labels=function(x) str_wrap(x, width=60)) p &lt;- p + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) top=&#39;top&#39; bottom=&#39;bottom&#39; left=&#39;left&#39; right=&#39;right&#39; none=&#39;none&#39; legend_pos_par &lt;- right uwid = 0 vhig = 12 # 自动估算图形长宽 if (uwid == 0 || vhig == 0) { x_len = length(unique(enrichment_sxbd$Description)) if(x_len&lt;10){ vhig = 10 } else if(x_len&lt;20) { vhig = 10 + (x_len-10)/3 } else if(x_len&lt;100) { vhig = 13 + (x_len-20)/5 } else { vhig = 40 } uwid = vhig if(legend_pos_par %in% c(&quot;left&quot;, &quot;right&quot;)){ uwid = 1.5 * uwid } } p &lt;- p + theme(legend.position=legend_pos_par) p &lt;- p + theme( panel.grid = element_blank(), panel.border=element_blank(), legend.background = element_blank(), axis.line.x=element_line(size=0.4, colour=&quot;black&quot;, linetype=&#39;solid&#39;), axis.line.y=element_line(size=0.4, colour=&quot;black&quot;, linetype=&#39;solid&#39;), axis.ticks = element_line(size=0.4) ) #ggsave(p, filename=&quot;GOenrichement.Samp.xls.scatterplot.dv.pdf&quot;, dpi=300, width=uwid, #height=vhig, units=c(&quot;cm&quot;)) p 3.9.2 多样品合并绘制 #enrichment$Type &lt;- factor(enrichment$Type, levels=sample_ho, ordered=T) # First order by Term, then order by Sample enrichment &lt;- enrichment[order(enrichment$Description, enrichment$Type), ] enrichment$GeneRatio = mixedToFloat(enrichment$GeneRatio) enrichment$Count = mixedToFloat(enrichment$Count) log_name = paste0(&quot;negLog10_&quot;, &quot;qvalue&quot;) col_name_enrichment &lt;- colnames(enrichment) col_name_enrichment &lt;- c(col_name_enrichment, log_name) enrichment$log_name &lt;- log10(enrichment$qvalue) * (-1) colnames(enrichment) &lt;- col_name_enrichment # Get the count of each unique Term enrichment_freq &lt;- as.data.frame(table(enrichment$Description)) colnames(enrichment_freq) &lt;- c(&quot;Description&quot;, &quot;IDctct&quot;) enrichment2 &lt;- merge(enrichment, enrichment_freq, by=&quot;Description&quot;) # 增加一列，样品信息用于排序 enrichment_samp &lt;- ddply(enrichment2, &quot;Description&quot;, summarize, sam_ct_ct_ct=paste(Type, collapse=&quot;_&quot;)) enrichment2 &lt;- merge(enrichment2, enrichment_samp, by=&quot;Description&quot;) # 排序与上面相同，但增加了按样品组合排序 enrichment3 &lt;- enrichment2[order(enrichment2$IDctct, enrichment2$sam_ct_ct_ct, enrichment2$Type, enrichment2$GeneRatio, enrichment2$negLog10_qvalue), ] #print(enrichment3) term_order &lt;- unique(enrichment3$Description) enrichment$Description &lt;- factor(enrichment$Description, levels=term_order, ordered=T) #print(enrichment) rm(enrichment_freq, enrichment2, enrichment3) color_v &lt;- c(&quot;green&quot;, &quot;red&quot;) p &lt;- ggplot(enrichment, aes(x=GeneRatio,y=Description)) + labs(x=&quot;GeneRatio&quot;, y=&quot;GO description&quot;) + labs(title=&quot;&quot;) p &lt;- p + geom_point(aes(size=Count, color=negLog10_qvalue, shape=Type)) + scale_colour_gradient(low=color_v[1], high=color_v[2], name=&quot;negLog10_qvalue&quot;) p &lt;- p + scale_y_discrete(labels=function(x) str_wrap(x, width=60)) p &lt;- p + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) p &lt;- p + theme(axis.text.x=element_text(angle=45,hjust=0.5, vjust=1)) top=&#39;top&#39; bottom=&#39;bottom&#39; left=&#39;left&#39; right=&#39;right&#39; none=&#39;none&#39; legend_pos_par &lt;- right uwid = 0 vhig = 12 if (uwid == 0 || vhig == 0) { x_len = length(unique(enrichment$Description)) if(x_len&lt;10){ vhig = 10 } else if(x_len&lt;20) { vhig = 10 + (x_len-10)/3 } else if(x_len&lt;100) { vhig = 13 + (x_len-20)/5 } else { vhig = 40 } uwid = vhig if(legend_pos_par %in% c(&quot;left&quot;, &quot;right&quot;)){ uwid = 1.5 * uwid } } p &lt;- p + theme(legend.position=legend_pos_par) p &lt;- p + theme( panel.grid = element_blank(), panel.border=element_blank(), legend.background = element_blank(), axis.line.x=element_line(size=0.4, colour=&quot;black&quot;, linetype=&#39;solid&#39;), axis.line.y=element_line(size=0.4, colour=&quot;black&quot;, linetype=&#39;solid&#39;), axis.ticks = element_line(size=0.4) ) #ggsave(p, filename=&quot;GOenrichement.xls.scatterplot.dv.pdf&quot;, dpi=300, width=uwid, #height=vhig, units=c(&quot;cm&quot;)) p 通过这张图解释下，富集分析的结果怎么解读。富集分析实际是查找哪些通路里面包含的差异基因占总差异基因的比例显著高于通路中总基因占所有已经注释的基因的比例。这一显著性通常用多重假设检验矫正过的pvalue(又称qvalue, FDR或p.adjust)来表示。在图中体现为点的颜色。从绿到红富集显著性逐渐增高。点的大小表示对应通路中包含的差异基因的数目。点的形状代表了不同类型的基因，如Samp中上调的基因和Baodian中上调的基因。横轴表示对应通路包含的差异基因占总的差异基因的比例, 本图中最高不过5%, 这个值越大说明通路被影响的越多。 3.10 韦恩图 维恩图是用来反映不同集合之间的交集和并集情况的展示图。一般用于展示2-5个集合之间的交并关系。集合数目更多时，将会比较难分辨，更多集合的展示方式一般使用upSetView。 较早的文章列举了多个在线工具http://mp.weixin.qq.com/s/zn654JqG9OeO71rJUTDr2Q。 3.10.1 韦恩图三个圈 library(VennDiagram) ## Loading required package: futile.logger ## ## Attaching package: &#39;VennDiagram&#39; ## The following object is masked from &#39;package:dendextend&#39;: ## ## rotate ## The following object is masked from &#39;package:ggpubr&#39;: ## ## rotate list1 = sample(letters,20) list2 = sample(letters,20) list3 = sample(letters,20) color_v &lt;- c(&quot;dodgerblue&quot;, &quot;goldenrod1&quot;, &quot;darkorange1&quot;) label_size = 1 margin = 0.1 p &lt;- venn.diagram( x = list(Samp1=list1, Samp2=list2, Samp3=list3), filename = NULL, col = &quot;black&quot;, lwd = 1, fill = color_v, alpha = 0.50, main=&quot;&quot;, label.col = c(&quot;black&quot;), cex = 1, fontfamily = &quot;Helvetica&quot;, cat.col = color_v,cat.cex = label_size, margin=margin, cat.fontfamily = &quot;Helvetica&quot; ) grid.draw(p) 3.10.2 韦恩图五个圈 假设有这么一个矩阵，第一列为不同集合中的ID，第二列为集合的名字，无标题行，存储为venn.txt。 a Samp1 b Samp1 c Samp1 d Samp1 e Samp1 f Samp1 g Samp1 h Samp2 i Samp2 j Samp2 k Samp2 e Samp2 f Samp2 g Samp2 a Samp3 b Samp3 h Samp3 j Samp3 i Samp3 f Samp3 g Samp3 a Samp4 b Samp4 h Samp4 d Samp5 e Samp5 y Samp5 x Samp5 library(VennDiagram) #pdf(file=&quot;venn.txt.vennDiagram.pdf&quot;, onefile=FALSE, paper=&quot;special&quot;) data &lt;- read.table(file=&quot;data/venn.txt&quot;, sep=&quot;\\t&quot;, quote=&quot;&quot;) num &lt;- 0 Samp1 &lt;- data[grepl(&quot;\\\\&lt;Samp1\\\\&gt;&quot;,data[,2]),1] num &lt;- num + 1 Samp2 &lt;- data[grepl(&quot;\\\\&lt;Samp2\\\\&gt;&quot;,data[,2]),1] num &lt;- num + 1 Samp3 &lt;- data[grepl(&quot;\\\\&lt;Samp3\\\\&gt;&quot;,data[,2]),1] num &lt;- num + 1 Samp4 &lt;- data[grepl(&quot;\\\\&lt;Samp4\\\\&gt;&quot;,data[,2]),1] num &lt;- num + 1 Samp5 &lt;- data[grepl(&quot;\\\\&lt;Samp5\\\\&gt;&quot;,data[,2]),1] num &lt;- num + 1 color_v &lt;- c(&quot;dodgerblue&quot;, &quot;goldenrod1&quot;, &quot;darkorange1&quot;, &quot;seagreen3&quot;, &quot;orchid3&quot;)[1:num] # label.col = c(&quot;orange&quot;, &quot;white&quot;, &quot;darkorchid4&quot;, &quot;white&quot;, &quot;white&quot;, &quot;white&quot;, &quot;white&quot;, #&quot;white&quot;, &quot;darkblue&quot;, &quot;white&quot;, &quot;white&quot;, &quot;white&quot;, &quot;white&quot;, &quot;darkgreen&quot;, &quot;white&quot;), label_size = 0.8 margin = 0.3 p &lt;- venn.diagram( x = list(Samp1=Samp1, Samp4=Samp4, Samp5=Samp5, Samp2=Samp2, Samp3=Samp3), filename = NULL, col = &quot;black&quot;, lwd = 1, fill = color_v, alpha = 0.50, main=&quot;&quot;, label.col = c(&quot;black&quot;), cex = 1, fontfamily = &quot;Helvetica&quot;, cat.col = color_v,cat.cex = label_size, margin=margin, cat.fontfamily = &quot;Helvetica&quot; ) grid.draw(p) #dev.off() 3.10.3 UpSetView展示 对于集合比较多的时候，包括上面提到的5个集合的交并集情况，如果只是为了展示个炫图，还可以，但如果想解释结果，就会比较头疼，难判断区域的归属。 因此对于这种多集合情况，推荐使用UpSetView展示，看效果如下。 测试数据，存储为upsetview.txt （第一行为集合的名，每个集合一列；每一行为一个ID，如果对应ID出现在这个集合则标记1，否则标记0）： pattern Samp1 Samp2 Samp3 Samp4 Samp5 a 1 0 1 1 0 b 1 0 1 1 0 c 1 0 0 0 0 d 1 0 0 0 1 e 1 1 0 0 1 f 1 1 1 0 0 g 1 1 1 0 0 h 0 1 1 1 0 i 0 1 1 0 0 j 0 1 1 0 0 k 0 1 0 0 0 x 0 0 0 0 1 y 0 0 0 0 1 library(UpSetR) matrix = read.table(&quot;data/upsetview.txt&quot;, header=T, row.names=NULL, sep=&quot;\\t&quot;) nsets = dim(matrix)[2]-1 #pdf(file=&quot;upsetview.txt.upsetV.pdf&quot;, onefile=FALSE, paper=&quot;special&quot;, width=10, #height=5, bg=&quot;white&quot;, pointsize=12) upset(matrix, nsets=nsets, sets.bar.color = &quot;#56B4E9&quot;, order.by = &quot;freq&quot;, empty.intersections = &quot;on&quot;) #dev.off() UpSetR: http://www.caleydo.org/tools/upset/ 采用连线的方式展示不同的组合之间共有的和特有的项目，对于特别多的组合尤其适用。 单个点表示特有，连起来的点表示共有，相当于venn图中重叠的部分。 垂直的柱子代表的是Venn图中的数字，看连接的点判断归属。 水平的柱子代表对应样品中Item的总数。 3.11 柱状图绘制 柱状图也是较为常见的一种数据展示方式，可以展示基因的表达量，也可以展示GO富集分析结果，基因注释数据等。39个转录组分析工具，120种组合评估(转录组分析工具哪家强-导读版)中提到了较多堆积柱状图的使用。下面就详细介绍下怎么绘制。 3.11.1 常规矩阵柱状图绘制 有如下4个基因在5组样品中的表达值 data_ori &lt;- &quot;Grp_1;Grp_2;Grp_3;Grp_4;Grp_5 a;2.6;2.9;2.1;2.0;2.2 b;20.8;9.8;7.0;3.7;19.2 c;10.0;11.0;9.2;12.4;9.6 d;9;3.3;10.3;11.1;10&quot; data &lt;- read.table(text=data_ori, header=T, row.names=1, sep=&quot;;&quot;, quote=&quot;&quot;) data ## Grp_1 Grp_2 Grp_3 Grp_4 Grp_5 ## a 2.6 2.9 2.1 2.0 2.2 ## b 20.8 9.8 7.0 3.7 19.2 ## c 10.0 11.0 9.2 12.4 9.6 ## d 9.0 3.3 10.3 11.1 10.0 整理数据格式，保留基因名字信息 library(ggplot2) library(reshape2) library(dplyr) data_rownames &lt;- rownames(data) data_colnames &lt;- colnames(data) data$gene &lt;- data_rownames data_m &lt;- melt(data, id.vars=c(&quot;gene&quot;)) data_m ## gene variable value ## 1 a Grp_1 2.6 ## 2 b Grp_1 20.8 ## 3 c Grp_1 10.0 ## 4 d Grp_1 9.0 ## 5 a Grp_2 2.9 ## 6 b Grp_2 9.8 ## 7 c Grp_2 11.0 ## 8 d Grp_2 3.3 ## 9 a Grp_3 2.1 ## 10 b Grp_3 7.0 ## 11 c Grp_3 9.2 ## 12 d Grp_3 10.3 ## 13 a Grp_4 2.0 ## 14 b Grp_4 3.7 ## 15 c Grp_4 12.4 ## 16 d Grp_4 11.1 ## 17 a Grp_5 2.2 ## 18 b Grp_5 19.2 ## 19 c Grp_5 9.6 ## 20 d Grp_5 10.0 首先看下每个基因在不同组的表达情况 # 给定数据，和x轴、y轴所在列名字 # 直接使用geom_bar就可以绘制柱状图 # position: dodge: 柱子并排放置 p &lt;- ggplot(data_m, aes(x=gene, y=value)) p + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, aes(fill=variable)) # 如果没有图形界面，运行下面的语句把图存在工作目录下的Rplots.pdf文件中 #dev.off() 柱子有点多，也可以利用mean±SD的形式展现 首先计算平均值和标准差，使用group_by按gene分组，对每组做summarize # 获取平均值和标准差 data_m_sd_mean &lt;- data_m %&gt;% group_by(gene) %&gt;% dplyr::summarise(sd=sd(value), mean_value=mean(value)) data_m_sd_mean &lt;- as.data.frame(data_m_sd_mean) data_m_sd_mean ## gene sd mean_value ## 1 a 0.3781534 2.36 ## 2 b 7.5491721 12.10 ## 3 c 1.2837445 10.44 ## 4 d 3.1325708 8.74 使用geom_errorbar添加误差线 p &lt;- ggplot(data_m_sd_mean, aes(x=gene, y=mean_value)) + geom_bar(stat=&quot;identity&quot;) + geom_errorbar(aes(ymin=mean_value-sd, ymax=mean_value+sd)) p 设置误差线的宽度和位置 p &lt;- ggplot(data_m_sd_mean, aes(x=gene, y=mean_value)) + geom_bar(stat=&quot;identity&quot;, aes(fill=gene)) + geom_errorbar(aes(ymin=mean_value-sd, ymax=mean_value+sd), width=0.2, position=position_dodge(width=0.75)) p 每个基因的原始表达值堆积柱状图 (只需要修改positon=stack) # position=&quot;fill&quot; 展示的是堆积柱状图各部分的相对比例 # position=&quot;stack&quot; 展示的是堆积柱状图的原始值 p &lt;- ggplot(data_m, aes(x=variable, y=value)) + geom_bar(stat=&quot;identity&quot;, position=&quot;stack&quot;, aes(fill=gene)) + geom_text(aes(label=value), position=position_stack(vjust=0.5)) p 堆积柱状图显示没问题，但文本标记错位了 指定下分组信息，位置计算就正确了 # position=&quot;fill&quot; 展示的是堆积柱状图各部分的相对比例 # position=&quot;stack&quot; 展示的是堆积柱状图的原始值 p &lt;- ggplot(data_m, aes(x=variable, y=value, group=gene)) + geom_bar(stat=&quot;identity&quot;, position=&quot;stack&quot;, aes(fill=gene)) + geom_text(aes(label=value), position=position_stack(vjust=0.5)) p 比较每组各个基因的相对表达 (position=fill) # position=&quot;fill&quot; 展示的是堆积柱状图各部分的相对比例 # position=&quot;stack&quot; 展示的是堆积柱状图的原始值，可以自己体现下看卡差别 p &lt;- ggplot(data_m, aes(x=variable, y=value)) + geom_bar(stat=&quot;identity&quot;, position=&quot;fill&quot;, aes(fill=gene)) p 纵轴的显示改为百分比 p &lt;- ggplot(data_m, aes(x=variable, y=value)) + geom_bar(stat=&quot;identity&quot;, position=&quot;fill&quot;, aes(fill=gene)) + scale_y_continuous(labels = scales::percent) p 在柱子中标记百分比值 首先计算百分比，同样是group_by (按照给定的变量分组，然后按组操作)和mutate两个函数(在当前数据表增加新变量) # group_by: 按照给定的变量分组，然后按组操作 # mutate: 在当前数据表增加新变量 # 第一步增加每个组的加和，第二步计算比例 data_m &lt;- data_m %&gt;% group_by(variable) %&gt;% mutate(count=sum(value)) %&gt;% mutate(freq=round(100*value/count,2)) head(data_m) ## # A tibble: 6 × 5 ## # Groups: variable [2] ## gene variable value count freq ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a Grp_1 2.6 168. 1.55 ## 2 b Grp_1 20.8 168. 12.4 ## 3 c Grp_1 10 168. 5.95 ## 4 d Grp_1 9 168. 5.35 ## 5 a Grp_2 2.9 168. 1.72 ## 6 b Grp_2 9.8 168. 5.83 再标记相对比例信息 p &lt;- ggplot(data_m, aes(x=variable, y=value, group=gene)) + geom_bar(stat=&quot;identity&quot;, position=&quot;fill&quot;, aes(fill=gene)) + scale_y_continuous(labels = scales::percent) + geom_text(aes(label=freq), position=position_fill(vjust=0.5)) p 3.11.2 长矩阵分面绘制 再复杂一些的矩阵 (除了有不同时间点的信息，再增加对照和处理的信息) library(ggplot2) library(reshape2) library(dplyr) data_ori &lt;- &quot;Gene;Group;Expr;Condition a;T1;2.6;Control b;T1;20.8;Control c;T1;10;Control d;T1;9;Control a;T2;2.9;Control b;T2;9.8;Control c;T2;11;Control d;T2;3.3;Control a;T3;2.1;Control b;T3;7;Control c;T3;9.2;Control d;T3;10.3;Control a;T4;2;Control b;T4;3.7;Control c;T4;12.4;Control d;T4;11.1;Control a;T5;2.2;Control b;T5;19.2;Control c;T5;9.6;Control d;T5;10;Control d;T1;2.6;Treatment b;T1;20.8;Treatment c;T1;10;Treatment a;T1;9;Treatment d;T2;2.9;Treatment b;T2;9.8;Treatment c;T2;11;Treatment a;T2;3.3;Treatment a;T3;2.1;Treatment c;T3;7;Treatment b;T3;9.2;Treatment d;T3;10.3;Treatment a;T4;2;Treatment c;T4;3.7;Treatment b;T4;12.4;Treatment d;T4;11.1;Treatment a;T5;2.2;Treatment d;T5;19.2;Treatment c;T5;9.6;Treatment b;T5;10;Treatment&quot; data_m &lt;- read.table(text=data_ori, header=T, sep=&quot;;&quot;, quote=&quot;&quot;) head(data_m) ## Gene Group Expr Condition ## 1 a T1 2.6 Control ## 2 b T1 20.8 Control ## 3 c T1 10.0 Control ## 4 d T1 9.0 Control ## 5 a T2 2.9 Control ## 6 b T2 9.8 Control 首先看下每个基因在不同组的表达情况, facet_grid和facet_wrap可以对图形分面显示。 # scales: free_y 表示不同子图之间使用独立的Y轴信息 # 但x轴使用同样的信息。 # 其它可选参数有free_x, free, fixed p &lt;- ggplot(data_m, aes(x=Gene, y=Expr)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, aes(fill=Group)) + facet_grid(Condition~., scales=&quot;free_y&quot;) p # 如果没有图形界面，运行下面的语句把图存在工作目录下的Rplots.pdf文件中 #dev.off() 柱子有点多，也可以利用mean±SD的形式展现 # 获取平均值和标准差 # 分组时不只Gene一个变量了，还需要考虑Condition data_m_sd_mean &lt;- data_m %&gt;% group_by(Gene, Condition) %&gt;% dplyr::summarise(sd=sd(Expr), value=mean(Expr)) ## `summarise()` has grouped output by ## &#39;Gene&#39;. You can override using the ## `.groups` argument. data_m_sd_mean &lt;- as.data.frame(data_m_sd_mean) data_m_sd_mean ## Gene Condition sd value ## 1 a Control 0.3781534 2.36 ## 2 a Treatment 2.9978326 3.72 ## 3 b Control 7.5491721 12.10 ## 4 b Treatment 4.8299068 12.44 ## 5 c Control 1.2837445 10.44 ## 6 c Treatment 2.9458445 8.26 ## 7 d Control 3.1325708 8.74 ## 8 d Treatment 6.8568943 9.22 p &lt;- ggplot(data_m_sd_mean, aes(x=Gene, y=value)) + geom_bar(stat=&quot;identity&quot;, aes(fill=Gene)) + geom_errorbar(aes(ymin=value-sd, ymax=value+sd), width=0.2, position=position_dodge(width=0.75)) + facet_wrap(~Condition, ncol=1) p 每组里面各个基因的相对表达, 纵轴的显示改为百分比 # position=&quot;fill&quot; 展示的是堆积柱状图各部分的相对比例 # position=&quot;stack&quot; 展示的是堆积柱状图的原始值，可以自己体现下看卡差别 p &lt;- ggplot(data_m, aes(x=Group, y=Expr)) + geom_bar(stat=&quot;identity&quot;, position=&quot;fill&quot;, aes(fill=Gene)) + scale_y_continuous(labels = scales::percent) + facet_wrap(~Condition, ncol=1) p facet后，显示正常，不需要做特别的修改 在柱子中标记百分比值 (计算百分比值需要注意了, 文本显示位置还是跟之前一致) # group_by: 按照给定的变量分组，然后按组操作 # mutate: 在当前数据表增加新变量 # 第一步增加每个组 (Group和Condition共同定义分组)的加和，第二步计算比例 data_m &lt;- data_m %&gt;% group_by(Group, Condition) %&gt;% mutate(count=sum(Expr)) %&gt;% mutate(freq=round(100*Expr/count,2)) head(data_m) ## # A tibble: 6 × 6 ## # Groups: Group, Condition [2] ## Gene Group Expr Condition count freq ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a T1 2.6 Control 336. 0.77 ## 2 b T1 20.8 Control 336. 6.18 ## 3 c T1 10 Control 336. 2.97 ## 4 d T1 9 Control 336. 2.68 ## 5 a T2 2.9 Control 336. 0.86 ## 6 b T2 9.8 Control 336. 2.91 p &lt;- ggplot(data_m, aes(x=Group, y=Expr, group=Group)) + geom_bar(stat=&quot;identity&quot;, position=&quot;fill&quot;, aes(fill=Gene)) + scale_y_continuous(labels = scales::percent) + geom_text(aes(label=freq), position=position_fill(vjust=0.5)) + facet_wrap(~Condition, ncol=1) p 文本显示位置没有问题，但柱子的位置有些奇怪，使得两组之间不可比。 先对数据做下排序，然后再标记文本 (这部分可以看下视频，或者自己输出下数据看看为什么要排序。底层原因可能是这种新的数据结构的问题。) # with: 产生一个由data_m组成的局部环境，再这个环境里，列名字可以直接使用 data_m &lt;- data_m[with(data_m, order(Condition, Group, Gene)),] p &lt;- ggplot(data_m, aes(x=Group, y=Expr, group=Group)) + geom_bar(stat=&quot;identity&quot;, position=&quot;fill&quot;, aes(fill=Gene)) + scale_y_continuous(labels = scales::percent) + geom_text(aes(label=freq), position=position_fill(vjust=0.5)) + facet_wrap(~Condition, ncol=1) p 这样两种条件下的比较更容易了。 3.12 图形支持中文字体 3.12.1 修改图形的字体 ggplot2中修改图形字体。 # 修改坐标轴和legend、标题的字体 theme(text=element_text(family=&quot;Arial&quot;)) # 或者 theme_bw(base_family=&quot;Arial&quot;) # 修改geom_text的字体 geom_text(family=&quot;Arial&quot;) 3.12.2 ggplot2支持中文字体输出PDF showtext包可给定字体文件，加载到R环境中，生成新的字体家族名字，后期调用这个名字设定字体，并且支持中文写入pdf不乱码 library(showtext) showtext.auto(enable=TRUE) font_path = &quot;FZSTK.TTF&quot; font_name = tools::file_path_sans_ext(basename(font_path)) font.add(font_name, font_path) # 修改坐标轴和legend、标题的字体 theme(text=element_text(family=font_name)) # 修改geom_text的字体 geom_text(family=font_name) 3.12.3 系统可用字体 Linux字体一般在 /usr/share/fonts下，也可以使用fc-list列出所以加载的字体。 Windows字体在 C:\\Windows\\Fonts\\下，直接可以看到，也可以拷贝到Linux下使用。 3.12.4 合并字体支持中英文 通常情况下，作图的字体都是英文，ggplot2默认的或按需求加载一种字体就可以了。但如果中英文混合出现时，单个字体只能支持一种文字，最好的方式是合并两种字体，类似于Word中设置中英文分别使用不同的字体。 软件FontForge可以方便的合并中英文字体，其安装也比较简单，直接 yum install fontforge.x86_64。 假如需要合并FZSTK.TTF (windows下获取)和Schoolbell-Regular.ttf (谷歌下载)，这两个都是手写字体。按如下，把字体文件和程序脚本mergefont.pe放在同一目录下，运行fontforge -script mergefont.pe即可获得合并后的字体FZ_School.ttf。 ct@Samp $ ls FZSTK.TTF mergefont.pe Schoolbell-Regular.ttf ct@Samp $ cat mergefont.pe Open(&quot;FZSTK.TTF&quot;) SelectAll() ScaleToEm(1024) Generate(&quot;temp.ttf&quot;, &quot;&quot;, 0x14) Close() # Open English font and merge to the Chinese font Open(&quot;Schoolbell-Regular.ttf&quot;) SelectAll() ScaleToEm(1024) MergeFonts(&quot;temp.ttf&quot;) SetFontNames(&quot;FZ_School&quot;, &quot;FZST&quot;, &quot;Schoolbel&quot;, &quot;Regular&quot;, &quot;&quot;) Generate(&quot;FZ_School.ttf&quot;, &quot;&quot;, 0x14) Close() ct@Samp $ fontforge -script mergefont.pe ct@Samp $ ls FZ_School.ttf FZSTK.TTF mergefont.pe Schoolbell-Regular.ttf 然后安装前面的介绍使用showtext导入即可使用。 3.12.5 一个示例 字体文件自己从Windows获取，School bell从Google fonts获取。 library(showtext) ## Add fonts that are available on current path # 方正字体+schoole bell (中英混合) font.add(&quot;FZ_School&quot;, &quot;font/FZ_School.ttf&quot;) # 黑体 font.add(&quot;simhei&quot;, &quot;font/simhei.ttf&quot;) font.add(&quot;Arial&quot;,&quot;font/arial.ttf&quot;) # 黑体和Arial的合体 font.add(&quot;HeiArial&quot;, &quot;font/HeiArial.ttf&quot;) showtext.auto() ## automatically use showtext for new devices library(ggplot2) p = ggplot(NULL, aes(x = 1:10, y = 2^(1:10), group=1)) + geom_line() + theme(axis.title.y=element_text(family=&quot;Arial&quot;), axis.title.x=element_text(family=&quot;HeiArial&quot;), plot.title=element_text(family=&quot;simhei&quot;)) + xlab(&quot;Days spent on 生信宝典&quot;) + ylab(&quot;Things you have learned&quot;) + ggtitle(&quot;生信宝典，换个角度学生信&quot;) + annotate(&quot;text&quot;, 7, 300, family = &quot;FZ_School&quot;, size = 8, label = &quot;收获曲线 (Harvest curve)&quot;, angle=15) # annotate指定的是文字的中间部分的位置 #ggsave(p, filename=&quot;example-SXBD.pdf&quot;, width = 7, height = 4) ## PDF device p 3.13 PCA原理解析和图形绘制 library(knitr) library(psych) ## ## Attaching package: &#39;psych&#39; ## The following objects are masked from &#39;package:ggplot2&#39;: ## ## %+%, alpha library(reshape2) library(ggplot2) library(ggbeeswarm) library(scatterplot3d) library(useful) library(ggfortify) ## Registered S3 methods overwritten by &#39;ggfortify&#39;: ## method from ## autoplot.acf useful ## fortify.acf useful ## fortify.kmeans useful ## fortify.ts useful 3.13.1 主成分分析简介 主成分分析 (PCA, principal component analysis)是一种数学降维方法, 利用正交变换 (orthogonal transformation)把一系列可能线性相关的变量转换为一组线性不相关的新变量，也称为主成分，从而利用新变量在更小的维度下展示数据的特征。 主成分是原有变量的线性组合，其数目不多于原始变量。组合之后，相当于我们获得了一批新的观测数据，这些数据的含义不同于原有数据，但包含了之前数据的大部分特征，并且有着较低的维度，便于进一步的分析。 在空间上，PCA可以理解为把原始数据投射到一个新的坐标系统，第一主成分为第一坐标轴，它的含义代表了原始数据中多个变量经过某种变换得到的新变量的变化区间；第二成分为第二坐标轴，代表了原始数据中多个变量经过某种变换得到的第二个新变量的变化区间。这样我们把利用原始数据解释样品的差异转变为利用新变量解释样品的差异。 这种投射方式会有很多，为了最大限度保留对原始数据的解释，一般会用最大方差理论或最小损失理论，使得第一主成分有着最大的方差或变异数 (就是说其能尽量多的解释原始数据的差异)；随后的每一个主成分都与前面的主成分正交，且有着仅次于前一主成分的最大方差 (正交简单的理解就是两个主成分空间夹角为90°，两者之间无线性关联，从而完成去冗余操作)。 3.13.2 主成分分析的意义 简化运算。 在问题研究中，为了全面系统地分析问题，我们通常会收集众多的影响因素也就是众多的变量。这样会使得研究更丰富，通常也会带来较多的冗余数据和复杂的计算量。 比如我们我们测序了100种样品的基因表达谱借以通过分子表达水平的差异对这100种样品进行分类。在这个问题中，研究的变量就是不同的基因。每个基因的表达都可以在一定程度上反应样品之间的差异，但某些基因之间却有着调控、协同或拮抗的关系，表现为它们的表达值存在一些相关性，这就造成了统计数据所反映的信息存在一定程度的冗余。另外假如某些基因如持家基因在所有样本中表达都一样，它们对于解释样本的差异也没有意义。这么多的变量在后续统计分析中会增大运算量和计算复杂度，应用PCA就可以在尽量多的保持变量所包含的信息又能维持尽量少的变量数目，帮助简化运算和结果解释。 去除数据噪音。 比如说我们在样品的制备过程中，由于不完全一致的操作，导致样品的状态有细微的改变，从而造成一些持家基因也发生了相应的变化，但变化幅度远小于核心基因 (一般认为噪音的方差小于信息的方差）。而PCA在降维的过程中滤去了这些变化幅度较小的噪音变化，增大了数据的信噪比。 利用散点图实现多维数据可视化。 在上面的表达谱分析中，假如我们有1个基因，可以在线性层面对样本进行分类；如果我们有2个基因，可以在一个平面对样本进行分类；如果我们有3个基因，可以在一个立体空间对样本进行分类；如果有更多的基因，比如说n个，那么每个样品就是n维空间的一个点，则很难在图形上展示样品的分类关系。利用PCA分析，我们可以选取贡献最大的2个或3个主成分作为数据代表用以可视化。这比直接选取三个表达变化最大的基因更能反映样品之间的差异。（利用Pearson相关系数对样品进行聚类在样品数目比较少时是一个解决办法） 发现隐性相关变量。 我们在合并冗余原始变量得到主成分过程中，会发现某些原始变量对同一主成分有着相似的贡献，也就是说这些变量之间存在着某种相关性，为相关变量。同时也可以获得这些变量对主成分的贡献程度。对基因表达数据可以理解为发现了存在协同或拮抗关系的基因。 3.13.3 示例展示原始变量对样品的分类 假设有一套数据集，包含100个样品中某一基因的表达量。如下所示，每一行为一个样品，每一列为基因的表达值。这也是做PCA分析的基本数据组织方式，每一行代表一个样品，每一列代表一组观察数据即一个变量。 count &lt;- 50 Gene1_a &lt;- rnorm(count,5,0.5) Gene1_b &lt;- rnorm(count,20,0.5) grp_a &lt;- rep(&#39;a&#39;, count) grp_b &lt;- rep(&#39;b&#39;, count) cy_data &lt;- data.frame(Gene1 = c(Gene1_a, Gene1_b), Group=c(grp_a, grp_b)) cy_data &lt;- as.data.frame(cy_data) label &lt;- c(paste0(grp_a, 1:count), paste0(grp_b, 1:count)) row.names(cy_data) &lt;- label library(knitr) library(psych) # Add additional column to data only for plotting cy_data$Y &lt;- rep(0,count*2) kable(headTail(cy_data), booktabs=TRUE, caption=&quot;Expression profile for Gene1 in 100 samples&quot;) Table 3.1: Expression profile for Gene1 in 100 samples Gene1 Group Y a1 5.03 a 0 a2 5.1 a 0 a3 5.12 a 0 a4 5.4 a 0 … … NA … b47 20.66 b 0 b48 19.9 b 0 b49 19.6 b 0 b50 19.48 b 0 从下图可以看出，100个样品根据Gene1表达量的不同在横轴上被被分为了2类，可以看做是在线性水平的分类。 library(&quot;ggplot2&quot;) library(&quot;ggbeeswarm&quot;) # geom_quasirandom:用于画Jitter Plot # theme(axis.*.y): 去除Y轴 # xlim, ylim设定坐标轴的区间 ggplot(cy_data,aes(Gene1, Y))+geom_quasirandom(aes(color=factor(Group)))+ theme(legend.position=c(0.5,0.7)) + theme(legend.title=element_blank()) + scale_fill_discrete(name=&quot;Group&quot;) + theme(axis.line.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.y=element_blank()) + ylim(-0.5,5) + xlim(0,25) 那么如果有2个基因呢？ count &lt;- 50 Gene2_a &lt;- rnorm(count,5,0.2) Gene2_b &lt;- rnorm(count,5,0.2) cy_data2 &lt;- data.frame(Gene1 = c(Gene1_a, Gene1_b), Gene2 = c(Gene2_a, Gene2_b), Group=c(grp_a, grp_b)) cy_data2 &lt;- as.data.frame(cy_data2) row.names(cy_data2) &lt;- label kable(headTail(cy_data2), booktabs=T, caption=&quot;Expression profile for Gene1 and Gene2 in 100 samples&quot;) Table 3.2: Expression profile for Gene1 and Gene2 in 100 samples Gene1 Gene2 Group a1 5.03 5.12 a a2 5.1 4.99 a a3 5.12 4.65 a a4 5.4 4.79 a … … … NA b47 20.66 5.24 b b48 19.9 4.66 b b49 19.6 5.19 b b50 19.48 4.88 b 从下图可以看出，100个样品根据Gene1和Gene2的表达量的不同在坐标轴上被被分为了2类，可以看做是在平面水平的分类。而且在这个例子中，我们可以很容易的看出Gene1对样品分类的贡献要比Gene2大，因为Gene1在样品间的表达差异大。 ggplot(cy_data2,aes(Gene1, Gene2))+geom_point(aes(color=factor(Group)))+ theme(legend.position=c(0.5,0.9)) + theme(legend.title=element_blank()) + ylim(0,10) + xlim(0,25) 如果有3个基因呢？ count &lt;- 50 Gene3_a &lt;- c(rnorm(count/2,5,0.2), rnorm(count/2,15,0.2)) Gene3_b &lt;- c(rnorm(count/2,15,0.2), rnorm(count/2,5,0.2)) data3 &lt;- data.frame(Gene1 = c(Gene1_a, Gene1_b), Gene2 = c(Gene2_a, Gene2_b), Gene3 = c(Gene3_a, Gene3_b), Group=c(grp_a, grp_b)) data3 &lt;- as.data.frame(data3) data3$Group &lt;- as.factor(data3$Group) row.names(data3) &lt;- label kable(headTail(data3), booktabs=T, caption=&quot;Expression profile for 3 genes in 100 samples&quot;) Table 3.3: Expression profile for 3 genes in 100 samples Gene1 Gene2 Gene3 Group a1 5.03 5.12 4.7 a a2 5.1 4.99 4.85 a a3 5.12 4.65 5.05 a a4 5.4 4.79 4.69 a … … … … NA b47 20.66 5.24 4.67 b b48 19.9 4.66 4.96 b b49 19.6 5.19 4.98 b b50 19.48 4.88 4.87 b 从下图可以看出，100个样品根据Gene1、Gene2和Gene3的表达量的不同在坐标轴上被被分为了4类，可以看做是立体空间的分类。而且在这个例子中，我们可以很容易的看出Gene1和Gene3对样品分类的贡献要比Gene2大。 library(scatterplot3d) colorl &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;) # Extract same number of colors as the Group and same Group would have same color. colors &lt;- colorl[as.numeric(data3$Group)] scatterplot3d(data3[,1:3], color=colors, xlim=c(0,25), ylim=c(0,25), zlim=c(0,25), angle=55, pch=16) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) 当我们向由Gene1和Gene2构成的X-Y平面做垂线时，可以很明显的看出，Gene2所在的轴对样品的分类没有贡献。因为投射到X-Y屏幕上的点在Y轴几乎处于同一位置。 library(scatterplot3d) colorl &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;) colors &lt;- colorl[as.numeric(data3$Group)] scatterplot3d(data3[,1:3], color=colors, xlim=c(0,25), ylim=c(0,25), zlim=c(0,25),type=&#39;h&#39;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) 我们把坐标轴做一个转换，可以看到在由Gene1和Gene3构成的X-Y平面上，样品被分为了4类。Gene2对样品的分类几乎没有贡献，因为几乎所有样品在Gene2维度上的值都一样。 library(scatterplot3d) colorl &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;) colors &lt;- colorl[as.numeric(data3$Group)] scatterplot3d(x=data3$Gene1, y= data3$Gene3, z= data3$Gene2, color=colors, xlim=c(0,25), ylim=c(0,25), zlim=c(0,25),type=&#39;h&#39;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) 在上述例子中，我们可以很容易的区分出Gene1和Gene3可以作为分类的主成分，而Gene2则对分类没有帮助，可以在计算中去除。 但是如果我们测序了几万个基因的表达时，就很难通过肉眼去看，或者作出一个图供我们筛选哪些基因对样本分类贡献大。这时我们应该怎么做呢？ 其中有一个方法是，在这个基因表达矩阵中选出3个变化最大的基因做为3个主成分对样品进行分类。我们试验下效果怎么样。 # 数据集来源于 http://satijalab.org/seurat/old-get-started/ # 原始下载链接 http://www.broadinstitute.org/~rahuls/seurat/seurat_files_nbt.zip # 为了保证文章的使用，文末附有数据的新下载链接，以防原链接失效 data4 &lt;- read.table(&quot;data/HiSeq301-RSEM-linear_values.txt&quot;, header=T, row.names=1,sep=&quot;\\t&quot;) dim(data4) ## [1] 11978 1152 library(useful) knitr::kable(corner(data4,r=15,c=8), booktabs=T, caption=&quot;Gene expression matrix&quot;) Table 3.4: Gene expression matrix zf1_p7_S31_umi zf2_dis_S1238_umi zf1_p5_S91_umi zf2_dis_S322_umi zf2_dis_S1179_umi zf1_p6_S44_umi zf2_dis_S1228_umi zf1_p5_S61_umi A2ML 0.00000 0 0.000000 2.585148 0.00000 0.000000 0 0.000000 AAAS 0.00000 0 0.000000 0.000000 13.50001 0.000000 0 30.658931 AACS 0.00000 0 0.000000 0.000000 0.00000 0.000000 0 0.000000 AADACL4 0.00000 0 0.000000 0.000000 0.00000 0.000000 0 0.000000 AAGAB 0.00000 0 0.000000 23.266335 13.50001 0.000000 0 0.000000 AAMDC 0.00000 0 6.159342 0.000000 0.00000 0.000000 0 0.000000 AAMP 36.07253 0 0.000000 0.000000 0.00000 27.926623 0 33.017311 AANAT1 0.00000 0 0.000000 0.000000 0.00000 0.000000 0 0.000000 AANAT2 0.00000 0 0.000000 0.000000 0.00000 0.000000 0 0.000000 AAR2 0.00000 0 0.000000 0.000000 0.00000 0.000000 0 0.000000 AARS 2.77481 0 12.318684 20.681187 0.00000 45.380762 0 18.867035 AARSD1 0.00000 0 6.159342 0.000000 0.00000 0.000000 0 4.716759 AASDHPPT 0.00000 0 0.000000 0.000000 24.30002 0.000000 0 0.000000 AASS 0.00000 0 0.000000 0.000000 0.00000 0.000000 0 0.000000 AATF 0.00000 0 86.230791 64.628708 13.50001 3.490828 0 4.716759 我们筛选变异系数最大的3个基因。在这之前我们先剔除在少于5个样品中表达的基因和少于1000个表达的基因样品 （这里我们把表达值不小于1的基因视为表达的基因），并把所有基因根据其在不同样品中表达值的变异系数排序。 #去除表达值全为0的行 #data4_nonzero &lt;- data4[rowSums(data4)!=0,] #筛选符合要求的表达的行和列 #data4_use &lt;- data4[apply(data4,1,function(row) sum(row&gt;=1)&gt;=5),] #data4_use &lt;- data4[,apply(data4,2,function(col) sum(col&gt;=1)&gt;=1000),] data4_use &lt;- data4[rowSums(data4&gt;=1)&gt;5,colSums(data4&gt;=1)&gt;1000] # 对于表达谱数据，因为涉及到PCR的指数扩增，一般会取log处理 # 其它数据log处理会降低数据之间的差异，不一定适用 data4_use_log2 &lt;- log2(data4_use+1) dim(data4_use_log2) ## [1] 10461 1069 # 计算变异系数(标准差除以平均值)度量基因表达变化幅度 #cv &lt;- apply(data4_use_log2,1,sd)/rowMeans(data4_use_log2) # 根据变异系数排序 #data4_use_log2 &lt;- data4_use_log2[order(cv,decreasing = T),] # 计算中值绝对偏差 (MAD, median absolute deviation)度量基因表达变化幅度 # 在基因表达中，尽管某些基因很小的变化会导致重要的生物学意义， # 但是很小的观察值会引入很大的背景噪音，因此也意义不大。 mads &lt;- apply(data4_use_log2, 1, mad) data4_use_log2 &lt;- data4_use_log2[rev(order(mads)),] #筛选前3行 data_var3 &lt;- data4_use_log2[1:3,] # 转置矩阵使得每一行为一个样品，每一列为一组变量 data_var3_forPCA &lt;- t(data_var3) dim(data_var3_forPCA) ## [1] 1069 3 kable(corner(data_var3_forPCA, r=10,c=5), booktabs=TRUE, caption=&quot;A table of the 3 most variable genes&quot;) Table 3.5: A table of the 3 most variable genes EVE1 WNT11 ATP6V1G1 zf1_p7_S31_umi 6.877033 8.959107 6.616451 zf2_dis_S1238_umi 0.000000 0.000000 0.000000 zf1_p5_S91_umi 0.000000 3.735380 0.000000 zf2_dis_S322_umi 6.905890 8.089798 1.842033 zf2_dis_S1179_umi 8.703213 9.203594 5.708741 zf1_p6_S44_umi 5.640146 9.321526 3.903358 zf1_p5_S61_umi 7.493750 9.002163 0.000000 zf1_p6_S56_umi 6.859092 5.228501 5.606441 zf1_p5_S66_umi 5.396193 0.000000 0.000000 zf1_p5_S69_umi 0.000000 4.059102 2.637616 # 获得样品分组信息 sample &lt;- rownames(data_var3_forPCA) # 把样品名字按 &lt;_&gt; 分割，取出其第二部分作为样品的组名 # lapply(X, FUC) 对列表或向量中每个元素执行FUC操作，FUNC为自定义或R自带的函数 ## One better way to generate group group &lt;- unlist(lapply(strsplit(sample, &quot;_&quot;), function(x) x[2])) ##One way to generate group #sample_split &lt;- strsplit(sample,&quot;_&quot;) #group &lt;- matrix(unlist(sample_split), ncol=3, byrow=T)[,2] print(sample[1:4]) ## [1] &quot;zf1_p7_S31_umi&quot; &quot;zf2_dis_S1238_umi&quot; &quot;zf1_p5_S91_umi&quot; ## [4] &quot;zf2_dis_S322_umi&quot; print(group[1:4]) ## [1] &quot;p7&quot; &quot;dis&quot; &quot;p5&quot; &quot;dis&quot; data_var3_scatter &lt;- as.data.frame(data_var3_forPCA) data_var3_scatter$group &lt;- group kable(corner(data_var3_scatter, r=10,c=5), booktabs=TRUE, caption=&quot;A table of the 3 most variable genes&quot;) Table 3.6: A table of the 3 most variable genes EVE1 WNT11 ATP6V1G1 group zf1_p7_S31_umi 6.877033 8.959107 6.616451 p7 zf2_dis_S1238_umi 0.000000 0.000000 0.000000 dis zf1_p5_S91_umi 0.000000 3.735380 0.000000 p5 zf2_dis_S322_umi 6.905890 8.089798 1.842033 dis zf2_dis_S1179_umi 8.703213 9.203594 5.708741 dis zf1_p6_S44_umi 5.640146 9.321526 3.903358 p6 zf1_p5_S61_umi 7.493750 9.002163 0.000000 p5 zf1_p6_S56_umi 6.859092 5.228501 5.606441 p6 zf1_p5_S66_umi 5.396193 0.000000 0.000000 p5 zf1_p5_S69_umi 0.000000 4.059102 2.637616 p5 library(reshape2) library(ggplot2) data_var3_melt &lt;- melt(data_var3_scatter, id.vars=c(&quot;group&quot;)) kable(corner(data_var3_melt, r=10,c=5), booktabs=TRUE, caption=&quot;A table of the 3 most variable genes in melted format&quot;) Table 3.7: A table of the 3 most variable genes in melted format group variable value p7 EVE1 6.877033 dis EVE1 0.000000 p5 EVE1 0.000000 dis EVE1 6.905890 dis EVE1 8.703213 p6 EVE1 5.640146 p5 EVE1 7.493750 p6 EVE1 6.859092 p5 EVE1 5.396193 p5 EVE1 0.000000 ggplot(data_var3_melt, aes(factor(variable),value))+ylab(&quot;Gene expression&quot;)+ geom_violin(aes(fill=factor(group)), stat=&quot;ydensity&quot;, position=&quot;dodge&quot;, scale=&quot;width&quot;, trim=TRUE) +xlab(NULL) #ggplot(data_var3_melt, aes(factor(variable),value))+ylab(&quot;Gene expression&quot;)+ #geom_quasirandom(aes(color=factor(group))) +xlab(NULL) # 根据分组数目确定颜色变量 colorA &lt;- rainbow(length(unique(group))) # 根据每个样品的分组信息获取对应的颜色变量 colors &lt;- colorA[as.factor(group)] # 根据样品分组信息获得legend的颜色 colorl &lt;- colorA[as.factor(unique(group))] # 获得PCH symbol列表 pch_l &lt;- as.numeric(as.factor(unique(group))) # 产生每个样品的pch symbol pch &lt;- pch_l[as.factor(group)] scatterplot3d(data_var3_forPCA[,1:3], color=colors, pch=pch) legend(0,10, legend=levels(as.factor(group)), col=colorl, pch=pch_l, xpd=T, horiz=F, ncol=6) 我们看到图中的样品并没有按照预先设定的标签完全分开。当然我们也可以通过其他方法筛选变异最大的三个基因，最终的分类效果不会相差很大。因为不管怎么筛选，我们都只用到了3个基因的表达量。 假如我们把这个数据用PCA来分类，结果是怎样的呢？ # Pay attention to the format of PCA input # Rows are samples and columns are variables data4_use_log2_t &lt;- t(data4_use_log2) # Add group column for plotting data4_use_log2_label &lt;- as.data.frame(data4_use_log2_t) data4_use_log2_label$group &lt;- group # By default, prcomp will centralized the data using mean. # Normalize data for PCA by dividing each data by column standard deviation. # Often, we would normalize data. # Only when we care about the real number changes other than the trends, # `scale` can be set to TRUE. # We will show the differences of scaling and un-scaling effects. pca &lt;- prcomp(data4_use_log2_t, scale=T) # sdev: standard deviation of the principle components. # Square to get variance percentVar &lt;- pca$sdev^2 / sum( pca$sdev^2) # To check what&#39;s in pca print(str(pca)) ## List of 5 ## $ sdev : num [1:1069] 16.77 10.86 8.26 7.09 6.8 ... ## $ rotation: num [1:10461, 1:1069] -0.00907 -0.01099 -0.01725 -0.01002 -0.01326 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:10461] &quot;EVE1&quot; &quot;WNT11&quot; &quot;ATP6V1G1&quot; &quot;RGCC&quot; ... ## .. ..$ : chr [1:1069] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ... ## $ center : Named num [1:10461] 3.51 3.23 2.75 2.99 2.81 ... ## ..- attr(*, &quot;names&quot;)= chr [1:10461] &quot;EVE1&quot; &quot;WNT11&quot; &quot;ATP6V1G1&quot; &quot;RGCC&quot; ... ## $ scale : Named num [1:10461] 3.27 3.16 2.61 2.9 2.71 ... ## ..- attr(*, &quot;names&quot;)= chr [1:10461] &quot;EVE1&quot; &quot;WNT11&quot; &quot;ATP6V1G1&quot; &quot;RGCC&quot; ... ## $ x : num [1:1069, 1:1069] -11.63 -3.59 -1.72 -24.65 -9.21 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:1069] &quot;zf1_p7_S31_umi&quot; &quot;zf2_dis_S1238_umi&quot; &quot;zf1_p5_S91_umi&quot; &quot;zf2_dis_S322_umi&quot; ... ## .. ..$ : chr [1:1069] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;prcomp&quot; ## NULL 从图中可以看到，数据呈现了一定的分类模式 (当然这个分类结果也不理想，我们随后再进一步优化)。 library(ggfortify) autoplot(pca, data=data4_use_log2_label, colour=&quot;group&quot;) + xlab(paste0(&quot;PC1 (&quot;, round(percentVar[1]*100), &quot;% variance)&quot;)) + ylab(paste0(&quot;PC2 (&quot;, round(percentVar[2]*100), &quot;% variance)&quot;)) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + theme(legend.position=&quot;right&quot;) 采用3个主成分获得的分类效果优于2个主成分，因为这样保留的原始信息更多。 # 根据分组数目确定颜色变量 colorA &lt;- rainbow(length(unique(group))) # 根据每个样品的分组信息获取对应的颜色变量 colors &lt;- colorA[as.factor(group)] # 根据样品分组信息获得legend的颜色 colorl &lt;- colorA[as.factor(unique(group))] # 获得PCH symbol列表 pch_l &lt;- as.numeric(as.factor(unique(group))) # 产生每个样品的pch symbol pch &lt;- pch_l[as.factor(group)] pc &lt;- as.data.frame(pca$x) scatterplot3d(x=pc$PC1, y=pc$PC2, z=pc$PC3, pch=pch, color=colors, xlab=paste0(&quot;PC1 (&quot;, round(percentVar[1]*100), &quot;% variance)&quot;), ylab=paste0(&quot;PC2 (&quot;, round(percentVar[2]*100), &quot;% variance)&quot;), zlab=paste0(&quot;PC3 (&quot;, round(percentVar[3]*100), &quot;% variance)&quot;)) legend(-3,8, legend=levels(as.factor(group)), col=colorl, pch=pch_l, xpd=T, horiz=F, ncol=6) 3.13.4 PCA的实现原理 在上面的例子中，PCA分析不是简单地选取2个或3个变化最大的基因，而是先把原始的变量做一个评估，计算各个变量各自的变异度(方差)和两两变量的相关度（协方差），得到一个协方差矩阵。在这个协方差矩阵中，对角线的值为每一个变量的方差，其它值为每两个变量的协方差。随后对原变量的协方差矩阵对角化处理，即求解其特征值和特征向量。原变量与特征向量的乘积（对原始变量的线性组合）即为新变量（回顾下线性代数中的矩阵乘法）；新变量的协方差矩阵为对角协方差矩阵且对角线上的方差由大到小排列；然后从新变量中选择信息最丰富也就是方差最大的的前2个或前3个新变量也就是主成分用以可视化。下面我们一步步阐释这是怎么做的。 我们先回忆两个数学概念，方差和协方差。方差用来表示一组一维数据的离散程度。协方差表示2组一维数据的相关性。当协方差为0时，表示两组数据完全独立。当协方差为正时，表示一组数据增加时另外一组也会增加；当协方差为负时表示一组数据增加时另外一组数据会降低 （与相关系数类似）。如果我们有很多组一维数据，比如很多基因的表达数据，就会得到很多协方差，这就构成了协方差矩阵。 方差和协方差的计算公式如下： \\[ 方差 Var(X) = \\frac{\\sum_{i=1}^{n}(X_i-\\bar X)^2}{n-1} \\] \\[ 协方差 cov(X,Y) = \\frac{\\sum_{i=1}^{n}(X_i-\\bar X)(Y_i-\\bar Y)}{n-1} \\] 如果数据的均值为0，这个公式可以进一步简化。简化后的公式把计算协方差转变为了矩阵乘法运算。这也是为什么PCA需要中心化数据。 \\[ 方差 Var(X) = \\frac{\\sum_{i=1}^{n}{X_i}^2}{n-1} \\] \\[ 协方差 cov(X,Y) = \\frac{\\sum_{i=1}^{n}X_iY_i}{n-1} \\] \\[ 协方差矩阵 cov(X,Y) = \\frac{X_{n,m}^T Y_{n,m}}{n-1} \\] 假如我们有一个矩阵如下， mat &lt;- as.data.frame(matrix(rnorm(20,0,1), nrow=4)) colnames(mat) &lt;- paste0(&quot;Gene_&quot;, letters[1:5]) rownames(mat) &lt;- paste0(&quot;Samp_&quot;, 1:4) mat ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Samp_1 -0.8810526 -0.7222866 -1.2145358 -0.6408135 -1.15275814 ## Samp_2 -0.1260276 1.0726877 0.4718083 0.4420562 -0.18145479 ## Samp_3 -0.3534377 -0.6026698 -0.4808576 0.1586046 -0.02324687 ## Samp_4 0.2278085 0.6370309 -0.9845529 -1.1711133 0.10025161 平均值中心化 (mean centering)：中心化数据使其平均值为0 # mean-centering data for columns # Get mean-value matrix first mat_mean_norm &lt;- mat - rep(colMeans(mat),rep.int(nrow(mat),ncol(mat))) mat_mean_norm ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Samp_1 -0.59787527 -0.8184772 -0.66250129 -0.3379970 -0.8384561 ## Samp_2 0.15714975 0.9764972 1.02384278 0.7448727 0.1328473 ## Samp_3 -0.07026033 -0.6988604 0.07117686 0.4614211 0.2910552 ## Samp_4 0.51098584 0.5408404 -0.43251835 -0.8682968 0.4145537 # mean-centering using scale for columns scale(mat, center=T, scale=F) ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Samp_1 -0.59787527 -0.8184772 -0.66250129 -0.3379970 -0.8384561 ## Samp_2 0.15714975 0.9764972 1.02384278 0.7448727 0.1328473 ## Samp_3 -0.07026033 -0.6988604 0.07117686 0.4614211 0.2910552 ## Samp_4 0.51098584 0.5408404 -0.43251835 -0.8682968 0.4145537 ## attr(,&quot;scaled:center&quot;) ## Gene_a Gene_b Gene_c Gene_d Gene_e ## -0.28317738 0.09619057 -0.55203450 -0.30281647 -0.31430205 中位数中心化 (median centering)：如果数据变换范围很大或有异常值，中位数标准化效果会更好。 # median-centering data for columns mat_median_norm &lt;- mat - rep(apply(mat,2,median),rep.int(nrow(mat),ncol(mat))) mat_mean_norm ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Samp_1 -0.59787527 -0.8184772 -0.66250129 -0.3379970 -0.8384561 ## Samp_2 0.15714975 0.9764972 1.02384278 0.7448727 0.1328473 ## Samp_3 -0.07026033 -0.6988604 0.07117686 0.4614211 0.2910552 ## Samp_4 0.51098584 0.5408404 -0.43251835 -0.8682968 0.4145537 我们可以计算Gene_a的方差为 0.2160646 (var(mat$Gene_a))；Gene_a和Gene_b的协方差为0.3227558。 mat中5组基因的表达值的方差计算如下： apply(mat,2,var) ## Gene_a Gene_b Gene_c Gene_d Gene_e ## 0.2160646 0.8014552 0.5597668 0.5453087 0.3257416 mat中5组基因表达值的协方差计算如下： cov(mat) ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Gene_a 0.21606464 0.32275582 0.1103260 -0.05232345 0.23785016 ## Gene_b 0.32275582 0.80145524 0.4194519 0.07064335 0.27892752 ## Gene_c 0.11032604 0.41945189 0.5597668 0.46498426 0.17763576 ## Gene_d -0.05232345 0.07064335 0.4649843 0.54530868 0.05223111 ## Gene_e 0.23785016 0.27892752 0.1776358 0.05223111 0.32574162 如果均值为0，数值矩阵的协方差矩阵为矩阵的乘积 （实际上是矩阵的转置与其本身的乘积除以变量的维数减1）。 # Covariance matrix for Mean normalized matrix cov(mat_mean_norm) ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Gene_a 0.21606464 0.32275582 0.1103260 -0.05232345 0.23785016 ## Gene_b 0.32275582 0.80145524 0.4194519 0.07064335 0.27892752 ## Gene_c 0.11032604 0.41945189 0.5597668 0.46498426 0.17763576 ## Gene_d -0.05232345 0.07064335 0.4649843 0.54530868 0.05223111 ## Gene_e 0.23785016 0.27892752 0.1776358 0.05223111 0.32574162 # Covariance matrix for Mean normalized matrix # crossprod: matrix multiplication crossprod(as.matrix(mat_mean_norm)) / (nrow(mat_mean_norm)-1) ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Gene_a 0.21606464 0.32275582 0.1103260 -0.05232345 0.23785016 ## Gene_b 0.32275582 0.80145524 0.4194519 0.07064335 0.27892752 ## Gene_c 0.11032604 0.41945189 0.5597668 0.46498426 0.17763576 ## Gene_d -0.05232345 0.07064335 0.4649843 0.54530868 0.05223111 ## Gene_e 0.23785016 0.27892752 0.1776358 0.05223111 0.32574162 # Use %*% for matrix multiplication (slower) t(as.matrix(mat_mean_norm)) %*% as.matrix(mat_mean_norm) / (nrow(mat_mean_norm)-1) ## Gene_a Gene_b Gene_c Gene_d Gene_e ## Gene_a 0.21606464 0.32275582 0.1103260 -0.05232345 0.23785016 ## Gene_b 0.32275582 0.80145524 0.4194519 0.07064335 0.27892752 ## Gene_c 0.11032604 0.41945189 0.5597668 0.46498426 0.17763576 ## Gene_d -0.05232345 0.07064335 0.4649843 0.54530868 0.05223111 ## Gene_e 0.23785016 0.27892752 0.1776358 0.05223111 0.32574162 用矩阵形式书写如下，便于理解 \\[ \\mathbf{cov(mat)} = \\frac{1}{3} \\left[\\begin{array} {rrrr} -0.6 &amp; 0.16 &amp; -0.07 &amp; 0.51 \\\\ -0.82 &amp; 0.98 &amp; -0.7 &amp; 0.54 \\\\ -0.66 &amp; 1.02 &amp; 0.07 &amp; -0.43 \\\\ -0.34 &amp; 0.74 &amp; 0.46 &amp; -0.87 \\\\ -0.84 &amp; 0.13 &amp; 0.29 &amp; 0.41 \\\\ \\end{array}\\right] \\left[\\begin{array} {rrrrr} -0.6 &amp; -0.82 &amp; -0.66 &amp; -0.34 &amp; -0.84 \\\\ 0.16 &amp; 0.98 &amp; 1.02 &amp; 0.74 &amp; 0.13 \\\\ -0.07 &amp; -0.7 &amp; 0.07 &amp; 0.46 &amp; 0.29 \\\\ 0.51 &amp; 0.54 &amp; -0.43 &amp; -0.87 &amp; 0.41 \\\\ \\end{array}\\right] = \\left[\\begin{array} {rrrrr} 0.22 &amp; 0.32 &amp; 0.11 &amp; -0.05 &amp; 0.24 \\\\ 0.32 &amp; 0.8 &amp; 0.42 &amp; 0.07 &amp; 0.28 \\\\ 0.11 &amp; 0.42 &amp; 0.56 &amp; 0.46 &amp; 0.18 \\\\ -0.05 &amp; 0.07 &amp; 0.46 &amp; 0.55 &amp; 0.05 \\\\ 0.24 &amp; 0.28 &amp; 0.18 &amp; 0.05 &amp; 0.33 \\\\ \\end{array}\\right] \\] 根据前面的描述，原始变量的协方差矩阵表示原始变量自身的方差（协方差矩阵的主对角线位置）和原始变量之间的相关程度(非主对角线位置)。如果从这些数据中筛选主成分，则要选择方差大(主对角线值大)，且与其它已选变量之间相关性最小的变量（非主对角线值很小）。如果这些原始变量之间毫不相关，则它们的协方差矩阵在除主对角线处外其它地方的值都为0，这种矩阵成为对角矩阵。 而做PCA分析就是产生一组新的变量，使得新变量的协方差矩阵为对角阵，满足上面的要求。从而达到去冗余的目的。然后再选取方差大的变量，实现降维和去噪。 如果正向推导，这种组合可能会有很多种，一一计算会比较麻烦。那反过来看呢？ 我们不去寻找这种组合，而是计算如何使原变量的协方差矩阵变为对角阵。 数学推导中谨记的两个概念： 假设: 把未求解到的变量假设出来，用符号代替；这样有助于思考和演算 逆向：如果正向推导求不出，不妨倒着来；尽量多的利用已有信息 前面提到，新变量(\\(Y_{m,k}\\))是原始变量(\\(X_{m,n}\\))(原始变量的协方差矩阵为(\\(C_{n,n}\\)))的线性组合，那么假设我们找到了这么一个线性组合(命名为特征矩阵(\\(P_{n,k}\\)))，得到一组新变量\\(Y_{m,k}=X_{m,n}P_{n,k}\\)，并且新变量的协方差矩阵(\\(D_{k,k}\\))为对角阵。那么这个特征矩阵(\\(P_{n,k}\\))需要符合什么条件呢？ 从矩阵运算可以看出，最终的特征矩阵(\\(P_{n,k}\\))需要把原变量协方差矩阵(\\(C_{n,n}\\))转换为对角阵(因为新变量的协方差矩阵(\\(D_{k,k}\\))为对角阵)，并且对角元素从大到小排列（保证每个主成分的贡献度依次降低）。 现在就把求解新变量的任务转变为了求解原变量协方差矩阵的对角化问题了。在线性代数中，矩阵对角化的问题就是求解矩阵的特征值和特征向量的问题。 我们举一个例子讲述怎么求解特征值和特征向量。 假设\\(A_{n,n}\\)为n阶对称阵，如存在\\(\\lambda\\)和非零向量\\(x\\)，使得\\(Ax=\\lambda x\\)，则称\\(\\lambda\\)为矩阵\\(A_{n,n}\\)的特征值，非零向量\\(x\\)为为矩阵\\(A_{n,n}\\)对应于特征值\\(\\lambda\\)的特征向量。 根据这个定义可以得出\\((A_{n,n} - \\lambda E)x = 0\\)，由于\\(x\\)为非零向量，所以行列式\\(|A-\\lambda E| = 0\\)。 由此求解出n个根\\(\\lambda_{1}, \\lambda_{2}, ..., \\lambda_{3}\\)就是矩阵\\(A\\)的特征值。 回顾下行列式的计算： 行列式的值为行列式第一列的每一个数乘以它的余子式（余子式是行列式中除去当前元素所在行和列之后剩下的行列式）。 当行列式中存在线性相关的行或列或者有一行或一列元素全为0时，行列式的值为0。 上三角形行列式的值为其主对角线上元素的乘积。 互换行列式的两行或两列，行列式变号。 行列式的某一列（行）乘以同意书加到另一列（列）对应元素上去，行列式不变。 假如我们有一个矩阵 \\(\\mathbf{A} = \\left[\\begin{array} {cc} 3 &amp; -1 \\\\ -1 &amp; 3 \\end{array}\\right]\\)，如何计算它的特征值和特征向量呢？ 则\\(\\lambda\\)的值为2或4。 对\\(\\lambda_{1}=2\\)时，求解\\((A-2E)x=\\left|\\begin{array} {cc} 1 &amp; -1 \\\\ -1 &amp; 1 \\end{array}\\right| x= 0\\)，得\\(x=k\\left|\\begin{array}{c} 1 \\\\ 1 \\end{array}\\right|\\)，则对应于\\(\\lambda_{1}=2\\)时的特征向量\\(p_{1}=\\left|\\begin{array}{c} 1 \\\\ 1 \\end{array}\\right|\\) 对\\(\\lambda_{2}=4\\)时，求解\\((A-2E)x=\\left|\\begin{array} {cc} -1 &amp; -1 \\\\ -1 &amp; -1 \\end{array}\\right| x= 0\\)，得\\(x=k\\left|\\begin{array}{c} 1 \\\\ -1 \\end{array}\\right|\\)，则对应于\\(\\lambda_{2}=4\\)时的特征向量\\(p_{2}=\\left|\\begin{array}{c} 1 \\\\ -1 \\end{array}\\right|\\) 以上就完成了PCA的数学推导。 3.13.5 简单的PCA实现 我们使用前面用到的数据data3来演示下如何用R函数实现PCA的计算，并与R中自带的prcomp做个比较。 library(knitr) kable(headTail(data3), booktabs=T, caption=&quot;Expression profile for 3 genes in 100 samples&quot;) Table 3.8: Expression profile for 3 genes in 100 samples Gene1 Gene2 Gene3 Group a1 5.03 5.12 4.7 a a2 5.1 4.99 4.85 a a3 5.12 4.65 5.05 a a4 5.4 4.79 4.69 a … … … … NA b47 20.66 5.24 4.67 b b48 19.9 4.66 4.96 b b49 19.6 5.19 4.98 b b50 19.48 4.88 4.87 b 标准化数据 data3_center_scale &lt;- scale(data3[,1:3], center=T, scale=T) kable(headTail(data3_center_scale), booktabs=T, caption=&quot;Normalized expression for 3 genes in 100 samples&quot;) Table 3.9: Normalized expression for 3 genes in 100 samples Gene1 Gene2 Gene3 a1 -0.99 0.65 -1.05 a2 -0.98 -0.02 -1.02 a3 -0.98 -1.74 -0.98 a4 -0.94 -1.01 -1.05 … … … … b47 1.07 1.25 -1.05 b48 0.97 -1.68 -1 b49 0.93 1.03 -0.99 b50 0.91 -0.53 -1.01 计算协方差矩阵 data3_center_scale_cov &lt;- cov(data3_center_scale) kable(data3_center_scale_cov, booktabs=T, caption=&quot;Covariance matrix for 3 genes in 100 samples&quot;) Table 3.10: Covariance matrix for 3 genes in 100 samples Gene1 Gene2 Gene3 Gene1 1.0000000 0.2014046 -0.0004309 Gene2 0.2014046 1.0000000 0.1340104 Gene3 -0.0004309 0.1340104 1.0000000 求解特征值和特征向量 data3_center_scale_cov_eigen &lt;- eigen(data3_center_scale_cov) # 特征值，从大到小排序 data3_center_scale_cov_eigen$values ## [1] 1.2417159 1.0003974 0.7578867 # 特征向量, 每一列为对应特征值的特征向量 data3_center_scale_cov_eigen$vectors ## [,1] [,2] [,3] ## [1,] -0.5887262 0.5539568772 0.5886708 ## [2,] -0.7073970 -0.0006879892 -0.7068161 ## [3,] -0.3911407 -0.8325450768 0.3922725 产生新的矩阵 pc_select = 3 label = paste0(&quot;PC&quot;,c(1:pc_select)) data3_new &lt;- data3_center_scale %*% data3_center_scale_cov_eigen$vectors[,1:pc_select] colnames(data3_new) &lt;- label kable(headTail(data3_new), booktabs=T, caption=&quot;PCA generated matrix for the expression of 3 genes in 100 samples&quot;) Table 3.11: PCA generated matrix for the expression of 3 genes in 100 samples PC1 PC2 PC3 a1 0.53 0.32 -1.46 a2 0.99 0.3 -0.97 a3 2.19 0.27 0.27 a4 1.68 0.35 -0.25 … … … … b47 -1.1 1.47 -0.66 b48 1.01 1.37 1.37 b49 -0.89 1.34 -0.57 b50 0.23 1.35 0.51 比较原始数据和新产生的主成分对样品的聚类 #library(scatterplot3d) colorl &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;) # Extract same number of colors as the Group and same Group would have same color. colors &lt;- colorl[as.numeric(data3$Group)] # 1 row 2 columns par(mfrow=c(1,2)) scatterplot3d(data3[,1:3], color=colors, angle=55, pch=16, main=&quot;Original data&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) scatterplot3d(data3_new, color=colors,angle=55, pch=16, main=&quot;Principle components&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) #par(mfrow=c(1,1)) 利用prcomp进行主成分分析 pca_data3 &lt;- prcomp(data3[,1:3], center=TRUE, scale=TRUE) #Show whats in the result returned by prcomp str(pca_data3) ## List of 5 ## $ sdev : num [1:3] 1.114 1 0.871 ## $ rotation: num [1:3, 1:3] 0.588726 0.707397 0.391141 0.553957 -0.000688 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:3] &quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; ## .. ..$ : chr [1:3] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; ## $ center : Named num [1:3] 12.56 4.99 9.97 ## ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; ## $ scale : Named num [1:3] 7.577 0.198 5.029 ## ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; ## $ x : num [1:100, 1:3] -0.532 -0.989 -2.189 -1.682 -2.055 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:100] &quot;a1&quot; &quot;a2&quot; &quot;a3&quot; &quot;a4&quot; ... ## .. ..$ : chr [1:3] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; ## - attr(*, &quot;class&quot;)= chr &quot;prcomp&quot; # 新的数据，与前面计算的抑制 data3_pca_new &lt;- pca_data3$x kable(headTail(data3_pca_new), booktabs=T, caption=&quot;PCA generated matrix usig princomp for the expression of 3 genes in 100 samples&quot;) Table 3.12: PCA generated matrix usig princomp for the expression of 3 genes in 100 samples PC1 PC2 PC3 a1 -0.53 0.32 1.46 a2 -0.99 0.3 0.97 a3 -2.19 0.27 -0.27 a4 -1.68 0.35 0.25 … … … … b47 1.1 1.47 0.66 b48 -1.01 1.37 -1.37 b49 0.89 1.34 0.57 b50 -0.23 1.35 -0.51 # 特征向量，与我们前面计算的一致(特征向量的符号是任意的) pca_data3$rotation ## PC1 PC2 PC3 ## Gene1 0.5887262 0.5539568772 -0.5886708 ## Gene2 0.7073970 -0.0006879892 0.7068161 ## Gene3 0.3911407 -0.8325450768 -0.3922725 比较手动实现的PCA与prcomp实现的PCA的聚类结果 #library(scatterplot3d) colorl &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;) # Extract same number of colors as the Group and same Group would have same color. colors &lt;- colorl[as.numeric(data3$Group)] # 1 row 2 columns par(mfrow=c(1,2)) scatterplot3d(data3_new, color=colors,angle=55, pch=16, main=&quot;PCA by steps&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) scatterplot3d(data3_pca_new, color=colors,angle=55, pch=16, main=&quot;PCA by prcomp&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) #par(mfrow=c(1,1)) 自定义PCA计算函数 ct_PCA &lt;- function(data, center=TRUE, scale=TRUE){ data_norm &lt;- scale(data, center=center, scale=scale) data_norm_cov &lt;- crossprod(as.matrix(data_norm)) / (nrow(data_norm)-1) data_eigen &lt;- eigen(data_norm_cov) rotation &lt;- data_eigen$vectors label &lt;- paste0(&#39;PC&#39;, c(1:ncol(rotation))) colnames(rotation) &lt;- label sdev &lt;- sqrt(data_eigen$values) data_new &lt;- data_norm %*% rotation colnames(data_new) &lt;- label ct_pca &lt;- list(&#39;rotation&#39;=rotation, &#39;x&#39;=data_new, &#39;sdev&#39;=sdev) return(ct_pca) } 比较有无scale对聚类的影响，从图中可以看到，如果不对数据进行scale处理，样品的聚类结果更像原始数据，本身数值大的基因对主成分的贡献会大。如果关注的是每个变量自身的实际方差对样品分类的贡献，则不应该SCALE；如果关注的是变量的相对大小对样品分类的贡献，则应该SCALE，以防数值高的变量导入的大方差引入的偏见。 data3_pca_noscale_step = ct_PCA(data3[,1:3], center=TRUE, scale=FALSE) # 特征向量 data3_pca_noscale_step$rotation ## PC1 PC2 PC3 ## [1,] 0.9999860573 0.0004616146 0.005260423 ## [2,] 0.0052579118 0.0052820106 -0.999972227 ## [3,] -0.0004893874 0.9999859435 0.005279510 # 新变量 data3_pca_noscale_pc &lt;- data3_pca_noscale_step$x #library(scatterplot3d) colorl &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;) # Extract same number of colors as the Group and same Group would have same color. colors &lt;- colorl[as.numeric(data3$Group)] # 1 row 2 columns par(mfrow=c(2,2)) scatterplot3d(data3[,c(1,3,2)], color=colors, angle=55, pch=16, main=&quot;Original data&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) scatterplot3d(data3_pca_noscale_pc, color=colors,angle=55, pch=16, main=&quot;PCA (no scale)&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) scatterplot3d(data3_center_scale[,c(1,3,2)], color=colors, angle=55, pch=16, main=&quot;Original data (scale)&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) scatterplot3d(data3_new, color=colors,angle=55, pch=16, main=&quot;PCA (scale)&quot;) legend(&quot;top&quot;, legend=levels(data3$Group), col=colorl, pch=16, xpd=T, horiz=T) #par(mfrow=c(1,1)) 3.13.6 PCA结果解释 prcomp函数会返回主成分的标准差、特征向量和主成分构成的新矩阵。接下来，探索下不同主成分对数据差异的贡献和主成分与原始变量的关系。 主成分的平方为为特征值,其含义为每个主成分可以解释的数据差异，计算方式为 eigenvalues = (pca$sdev)^2 每个主成分可以解释的数据差异的比例为 percent_var = eigenvalues*100/sum(eigenvalues) 可以使用summary(pca)获取以上两条信息。 这两个信息可以判断主成分分析的质量： 成功的降维需要保证在前几个为数不多的主成分对数据差异的解释可以达到80-90%。 指导选择主成分的数目： 选择的主成分足以解释的总方差大于80% (方差比例碎石图) 从前面的协方差矩阵可以看到，自动定标(scale)的变量的方差为1 (协方差矩阵对角线的值)。待选择的主成分应该是那些方差大于1的主成分，即其解释的方差大于原始变量（特征值碎石图，方差大于1，特征值也会大于1，反之亦然）。 鉴定核心变量和变量间的隐性关系: 原始变量与主成分的相关性 Variable correlation with PCs (var.cor) = loadings * sdev 原始数据对主成分的贡献度 var.cor^2 / (total var.cor^2) 在测试数据中，scale后，三个主成分对数据差异的贡献度大都在30%左右，而未scale的数据，三个主成分对数据差异的贡献度相差很大。这是因为三个基因由于自身表达量级所引起的方差的差异导致它们各自对数据的权重差异，从而使主成分偏向于数值大的变量。 3.13.7 PCA应用于测试数据 前面用到一组比较大的测试数据集，并做了PCA分析，现在测试不同的处理对结果的影响。 首先回顾下我们用到的数据。 library(&quot;gridExtra&quot;) ## ## Attaching package: &#39;gridExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## combine # Pay attention to the format of PCA input # Rows are samples and columns are variables # data4_use_log2_t &lt;- t(data4_use_log2) # Add group column for plotting # data4_use_log2_label &lt;- as.data.frame(data4_use_log2_t) # data4_use_log2_label$group &lt;- group kable(corner(data4_use_log2_label), digits=3, caption=&quot;Single cell gene expression data&quot;) Table 3.13: Single cell gene expression data EVE1 WNT11 ATP6V1G1 RGCC LSM4 zf1_p7_S31_umi 6.877 8.959 6.616 0.000 0.000 zf2_dis_S1238_umi 0.000 0.000 0.000 4.209 2.772 zf1_p5_S91_umi 0.000 3.735 0.000 0.000 0.000 zf2_dis_S322_umi 6.906 8.090 1.842 5.405 3.503 zf2_dis_S1179_umi 8.703 9.204 5.709 2.678 5.174 比较对数运算和scale对样品分类的影响。 ct_pca_2d_plot &lt;- function(pca, data_with_label, labelName=&#39;group&#39;, title=&#39;PCA&#39;) { # sdev: standard deviation of the principle components. # Square to get variance percentVar &lt;- pca$sdev^2 / sum( pca$sdev^2) #data &lt;- data_with_label #data[labelName] &lt;- factor(unlist(data[labelName])) level &lt;- length(unique(unlist(data_with_label[labelName]))) shapes = (1:level)%%30 # maximum allow 30 types of symbols p = autoplot(pca, data=data_with_label, colour=labelName, shape=labelName) + scale_shape_manual(values=shapes) + xlab(paste0(&quot;PC1 (&quot;, round(percentVar[1]*100), &quot;% variance)&quot;)) + ylab(paste0(&quot;PC2 (&quot;, round(percentVar[2]*100), &quot;% variance)&quot;)) + theme_bw() + theme(legend.position=&quot;right&quot;) + labs(title=title) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) return(p) } # By default, prcomp will centralized the data using mean. # Normalize data for PCA by dividing each data by column standard deviation. # Often, we would normalize data. # Only when we care about the real number changes other than the trends, # `scale` can be set to TRUE. # We will show the differences of scaling and un-scaling effects. data4_use_t &lt;- t(data4_use) ori_scale_pca_test &lt;- prcomp(data4_use_t, scale=T) ori_no_scale_pca_test &lt;- prcomp(data4_use_t, scale=F) log_scale_pca_test &lt;- prcomp(data4_use_log2_t, scale=T) log_no_scale_pca_test &lt;- prcomp(data4_use_log2_t, scale=F) ori_scale_pca_plot = ct_pca_2d_plot(ori_scale_pca_test, data4_use_log2_label, title=&quot;Scaled original data&quot;) ori_no_scale_pca_plot = ct_pca_2d_plot(ori_no_scale_pca_test, data4_use_log2_label, title=&quot;Un-scaled original data&quot;) log_scale_pca_plot = ct_pca_2d_plot(log_scale_pca_test, data4_use_log2_label, title=&quot;Scaled log transformed data&quot;) log_no_scale_pca_plot = ct_pca_2d_plot(log_no_scale_pca_test, data4_use_log2_label, title=&quot;Un-scaled log transformed data&quot;) a__ &lt;- grid.arrange(ori_scale_pca_plot, ori_no_scale_pca_plot, log_scale_pca_plot, log_no_scale_pca_plot, ncol=2) 如果首先提取500个变化最大的基因，再执行PCA分析会怎样呢？ data4_use_mad &lt;- apply(data4_use, 1, mad) data4_use_mad_top500 &lt;- t(data4_use[rev(order(data4_use_mad))[1:500],]) data4_use_log2_mad &lt;- apply(data4_use_log2, 1, mad) data4_use_log2_mad_top500 &lt;- t(data4_use_log2[rev(order(data4_use_log2_mad))[1:500],]) ori_scale_pca_top500 &lt;- prcomp(data4_use_mad_top500, scale=T) ori_no_scale_pca_top500 &lt;- prcomp(data4_use_mad_top500, scale=F) log_scale_pca_top500 &lt;- prcomp(data4_use_log2_mad_top500, scale=T) log_no_scale_pca_top500 &lt;- prcomp(data4_use_log2_mad_top500, scale=F) ori_scale_pca_plot_t5 = ct_pca_2d_plot(ori_scale_pca_top500, data4_use_log2_label, title=&quot;Scaled original data&quot;) ori_no_scale_pca_plot_t5 = ct_pca_2d_plot(ori_no_scale_pca_top500, data4_use_log2_label, title=&quot;Un-scaled original data&quot;) log_scale_pca_plot_t5 = ct_pca_2d_plot(log_scale_pca_top500, data4_use_log2_label, title=&quot;Scaled log transformed data&quot;) log_no_scale_pca_plot_t5 = ct_pca_2d_plot(log_no_scale_pca_top500, data4_use_log2_label, title=&quot;Un-scaled log transformed data&quot;) a__ &lt;- grid.arrange(ori_scale_pca_plot_t5, ori_no_scale_pca_plot_t5, log_scale_pca_plot_t5, log_no_scale_pca_plot_t5, ncol=2) 3.13.8 PCA注意事项 一般说来，在PCA之前原始数据需要中心化（centering，数值减去平均值）。中心化的方法很多，除了平均值中心化（mean-centering）外，还包括其它更稳健的方法，比如中位数中心化等。 除了中心化以外，定标 (Scale, 数值除以标准差) 也是数据前处理中需要考虑的一点。如果数据没有定标，则原始数据中方差大的变量对主成分的贡献会很大。数据的方差与其量级成指数关系，比如一组数据(1,2,3,4)的方差是1.67，而(10,20,30,40)的方差就是167,数据变大10倍，方差放大了100倍。 但是定标(scale)可能会有一些负面效果，因为定标后变量之间的权重就是变得相同。如果我们的变量中有噪音的话，我们就在无形中把噪音和信息的权重变得相同，但PCA本身无法区分信号和噪音。在这样的情形下，我们就不必做定标。 一般而言，对于度量单位不同的指标或是取值范围彼此差异非常大的指标不直接由其协方差矩阵出发进行主成分分析，而应该考虑对数据的标准化。比如度量单位不同，有万人、万吨、万元、亿元，而数据间的差异性也非常大，小则几十大则几万，因此在用协方差矩阵求解主成分时存在协方差矩阵中数据的差异性很大。在后面提取主成分时发现，只提取了一个主成分，而此时并不能将所有的变量都解释到，这就没有真正起到降维的作用。此时就需要对数据进行定标(scale)，这样提取的主成分可以覆盖更多的变量，这就实现主成分分析的最终目的。但是对原始数据进行标准化后更倾向于使得各个指标的作用在主成分分析构成中相等。对于数据取值范围不大或是度量单位相同的指标进行标准化处理后，其主成分分析的结果与仍由协方差矩阵出发求得的结果有较大区别。这是因为对数据标准化的过程实际上就是抹杀原有变量离散程度差异的过程，标准化后方差均为1，而实际上方差是对数据信息的重要概括形式，也就是说，对原始数据进行标准化后抹杀了一部分重要信息，因此才使得标准化后各变量在主成分构成中的作用趋于相等。因此，对同度量或是取值范围在同量级的数据还是直接使用非定标数据求解主成分为宜。 中心化和定标都会受数据中离群值（outliers）或者数据不均匀（比如数据被分为若干个小组）的影响，应该用更稳健的中心化和定标方法。 PCA也存在一些限制，例如它可以很好的解除线性相关，但是对于高阶相关性就没有办法了，对于存在高阶相关性的数据，可以考虑Kernel PCA，通过Kernel函数将非线性相关转为线性相关，关于这点就不展开讨论了。另外，PCA假设数据各主特征是分布在正交方向上，如果在非正交方向上存在几个方差较大的方向，PCA的效果就大打折扣了。 3.13.9 参考资料 https://www.zhihu.com/question/20998460 PCA 教程1 PCA 文字化描述 pca1 ggplot2 axis scatterplot3D 稳健PCA http://www.nlpca.org/pca_principal_component_analysis.html Data centering Sample R markdown 矩阵特征值，对称矩阵的对角化 Detail usage and visualization of prcomp result ggplot2 side by side plot 3.14 生存分析 生存分析指根据试验或调查得到的数据对生物或人的生存时间进行分析和推断，研究生存时间和结局与众多影响因素间关系及其程度大小的方法，也称生存率分析或存活率分析。常用于肿瘤等疾病的标志物筛选、疗效及预后的考核。 简单地说，比较两组或多组人群随着时间的延续，存活个体的比例变化趋势。活着的个体越少的组危险性越大，对应的基因对疾病影响越大，对应的药物治疗效果越差。 生存分析适合于处理时间-事件数据，如下 生存时间数据有两种类型： 完全数据 (complete data)指被观测对象从观察起点到出现终点事件所经历的时间; 一般用状态值1或TRUE表示。 截尾数据 (consored data)或删失数据，指在出现终点事件前，被观测对象的观测过程终止了。由于被观测对象所提供的信息是不完全的，只知道他们的生存事件超过了截尾时间。截尾主要由于失访、退出和终止产生。一般用状态值0或FALSE表示。 TCGA中的临床数据标记也符合这个规律，在下面软件运行时也可修改状态值的含义, 但一般遵循这个规律。 生存概率 (survival probability)指某段时间开始时存活的个体至该时间结束时仍然存活的可能性大小。 生存概率=某人群活过某段时间例数/该人群同时间段期初观察例数。 生存率 (Survival rate)，用S(t)表示，指经历t个单位时间后仍存活的概率，若无删失数据，则为活过了t时刻仍然存活的例数/观察开始的总例数。如果有删失数据，分母则需要按时段进行校正。 生存分析一个常用的方法是寿命表法。 寿命表是描述一段时间内生存状况、终点事件和生存概率的表格，需计算累积生存概率即每一步生存概率的乘积 (也可能是原始生存概率)，可完成对病例随访资料在任意指定时点的生存状况评价。 3.14.1 R做生存分析 R中做生存分析需要用到包survival和survminer。输入数据至少两列，存活时间和生存状态，也就是测试数据中的Days.survial和vital_status列。如果需要比较不同组之间的差异，也需要提供个体的分组信息，如测试数据中的PAM50列。对应TCGA的数据，一般根据某个基因的表达量或突变有无对个体进行分组。 读入数据 library(survival) BRCA &lt;- read.table(&#39;data/BRCA.tsv&#39;, sep=&quot;\\t&quot;, header=T) head(BRCA) ## ID SampleType PAM50Call_RNAseq Days.survival pathologic_stage ## 1 TCGA-E9-A2JT-01 Tumor_type LumA 288 stage iia ## 2 TCGA-BH-A0W4-01 Tumor_type LumA 759 stage iia ## 3 TCGA-BH-A0B5-01 Tumor_type LumA 2136 stage iiia ## 4 TCGA-AC-A3TM-01 Tumor_type Unknown 762 stage iiia ## 5 TCGA-E9-A5FL-01 Tumor_type Unknown 24 stage iib ## 6 TCGA-AC-A3TN-01 Tumor_type Unknown 456 stage iib ## vital_status ## 1 0 ## 2 0 ## 3 0 ## 4 0 ## 5 0 ## 6 0 简单地看下每一列都有什么内容，方便对数据整体有个了解，比如有无特殊值。 summary(BRCA) ## ID SampleType PAM50Call_RNAseq Days.survival ## Length:1090 Length:1090 Length:1090 Min. : 0.0 ## Class :character Class :character Class :character 1st Qu.: 450.2 ## Mode :character Mode :character Mode :character Median : 848.0 ## Mean :1247.0 ## 3rd Qu.:1682.8 ## Max. :8605.0 ## pathologic_stage vital_status ## Length:1090 Min. :0.0000 ## Class :character 1st Qu.:0.0000 ## Mode :character Median :0.0000 ## Mean :0.1394 ## 3rd Qu.:0.0000 ## Max. :1.0000 计算寿命表 # Days.survival：跟踪到的存活时间 # vital_status: 跟踪到的存活状态 # ~1表示不进行分组 fit &lt;- survfit(Surv(Days.survival, vital_status)~1, data=BRCA) # 获得的survial列就是生存率 summary(fit) ## Call: survfit(formula = Surv(Days.survival, vital_status) ~ 1, data = BRCA) ## ## time n.risk n.event survival std.err lower 95% CI upper 95% CI ## 116 1021 1 0.999 0.000979 0.997 1.000 ## 158 1017 1 0.998 0.001386 0.995 1.000 ## 160 1016 1 0.997 0.001697 0.994 1.000 ## 172 1010 1 0.996 0.001962 0.992 1.000 ## 174 1008 1 0.995 0.002195 0.991 0.999 ## 197 1003 1 0.994 0.002406 0.989 0.999 ## 224 993 1 0.993 0.002604 0.988 0.998 ## 227 990 1 0.992 0.002788 0.987 0.998 ## 239 987 1 0.991 0.002961 0.985 0.997 ## 255 981 1 0.990 0.003125 0.984 0.996 ## 266 978 1 0.989 0.003282 0.983 0.996 ## 295 965 1 0.988 0.003435 0.981 0.995 ## 302 962 1 0.987 0.003581 0.980 0.994 ## 304 958 1 0.986 0.003723 0.979 0.993 ## 320 948 1 0.985 0.003862 0.977 0.993 ## 322 946 1 0.984 0.003995 0.976 0.992 ## 336 938 1 0.983 0.004127 0.975 0.991 ## 348 929 1 0.982 0.004256 0.973 0.990 ## 362 921 1 0.981 0.004382 0.972 0.989 ## 365 918 1 0.980 0.004506 0.971 0.989 ## 377 896 1 0.979 0.004632 0.970 0.988 ## 385 887 2 0.976 0.004877 0.967 0.986 ## 426 845 1 0.975 0.005006 0.965 0.985 ## 446 826 1 0.974 0.005137 0.964 0.984 ## 524 765 1 0.973 0.005286 0.962 0.983 ## 538 751 1 0.971 0.005435 0.961 0.982 ## 548 743 1 0.970 0.005583 0.959 0.981 ## 558 732 1 0.969 0.005731 0.958 0.980 ## 563 729 1 0.967 0.005875 0.956 0.979 ## 571 723 1 0.966 0.006017 0.954 0.978 ## 573 721 1 0.965 0.006156 0.953 0.977 ## 584 708 1 0.963 0.006297 0.951 0.976 ## 612 684 1 0.962 0.006443 0.949 0.975 ## 614 680 1 0.961 0.006587 0.948 0.974 ## 616 678 1 0.959 0.006728 0.946 0.972 ## 639 660 1 0.958 0.006873 0.944 0.971 ## 678 632 1 0.956 0.007027 0.943 0.970 ## 723 608 1 0.955 0.007189 0.941 0.969 ## 749 592 1 0.953 0.007356 0.939 0.968 ## 754 589 1 0.951 0.007519 0.937 0.966 ## 763 577 1 0.950 0.007685 0.935 0.965 ## 785 570 1 0.948 0.007850 0.933 0.964 ## 786 568 1 0.946 0.008012 0.931 0.962 ## 792 564 2 0.943 0.008327 0.927 0.960 ## 811 557 1 0.941 0.008483 0.925 0.958 ## 821 552 1 0.940 0.008637 0.923 0.957 ## 825 550 1 0.938 0.008789 0.921 0.955 ## 860 541 1 0.936 0.008942 0.919 0.954 ## 879 533 1 0.934 0.009096 0.917 0.952 ## 883 531 1 0.933 0.009248 0.915 0.951 ## 904 526 1 0.931 0.009399 0.913 0.950 ## 912 522 1 0.929 0.009548 0.911 0.948 ## 921 517 1 0.927 0.009697 0.909 0.947 ## 943 511 1 0.926 0.009847 0.906 0.945 ## 959 505 1 0.924 0.009996 0.904 0.944 ## 967 502 1 0.922 0.010144 0.902 0.942 ## 976 494 1 0.920 0.010294 0.900 0.940 ## 991 489 2 0.916 0.010590 0.896 0.937 ## 1004 480 1 0.914 0.010739 0.894 0.936 ## 1009 473 1 0.912 0.010889 0.891 0.934 ## 1032 464 1 0.910 0.011042 0.889 0.932 ## 1034 463 2 0.907 0.011339 0.885 0.929 ## 1048 453 1 0.905 0.011489 0.882 0.927 ## 1072 444 1 0.902 0.011642 0.880 0.926 ## 1093 439 1 0.900 0.011796 0.878 0.924 ## 1104 434 1 0.898 0.011950 0.875 0.922 ## 1127 426 1 0.896 0.012106 0.873 0.920 ## 1142 419 1 0.894 0.012265 0.870 0.918 ## 1148 418 1 0.892 0.012421 0.868 0.917 ## 1152 414 1 0.890 0.012576 0.866 0.915 ## 1174 404 1 0.888 0.012736 0.863 0.913 ## 1272 371 1 0.885 0.012925 0.860 0.911 ## 1275 370 1 0.883 0.013109 0.858 0.909 ## 1286 367 1 0.880 0.013293 0.855 0.907 ## 1324 356 1 0.878 0.013483 0.852 0.905 ## 1365 347 1 0.875 0.013680 0.849 0.903 ## 1388 343 1 0.873 0.013876 0.846 0.900 ## 1411 342 1 0.870 0.014068 0.843 0.898 ## 1430 338 1 0.868 0.014260 0.840 0.896 ## 1439 335 1 0.865 0.014451 0.837 0.894 ## 1508 322 1 0.862 0.014654 0.834 0.892 ## 1542 313 1 0.860 0.014864 0.831 0.889 ## 1556 305 2 0.854 0.015291 0.825 0.885 ## 1563 302 1 0.851 0.015500 0.821 0.882 ## 1642 283 1 0.848 0.015735 0.818 0.880 ## 1649 279 1 0.845 0.015969 0.814 0.877 ## 1673 277 1 0.842 0.016200 0.811 0.874 ## 1688 271 1 0.839 0.016436 0.807 0.872 ## 1692 269 1 0.836 0.016668 0.804 0.869 ## 1694 267 1 0.833 0.016897 0.800 0.867 ## 1699 266 1 0.830 0.017121 0.797 0.864 ## 1759 260 1 0.826 0.017350 0.793 0.861 ## 1781 258 1 0.823 0.017576 0.790 0.858 ## 1793 256 1 0.820 0.017799 0.786 0.856 ## 1812 254 1 0.817 0.018020 0.782 0.853 ## 1884 241 1 0.813 0.018261 0.778 0.850 ## 1900 239 1 0.810 0.018499 0.775 0.847 ## 1920 236 1 0.807 0.018736 0.771 0.844 ## 1927 233 1 0.803 0.018973 0.767 0.841 ## 1993 225 1 0.800 0.019221 0.763 0.838 ## 2009 223 1 0.796 0.019467 0.759 0.835 ## 2097 212 1 0.792 0.019734 0.754 0.832 ## 2127 208 1 0.788 0.020003 0.750 0.829 ## 2192 195 1 0.784 0.020305 0.746 0.825 ## 2207 192 1 0.780 0.020606 0.741 0.822 ## 2273 181 2 0.772 0.021261 0.731 0.814 ## 2296 174 1 0.767 0.021596 0.726 0.811 ## 2348 168 1 0.763 0.021945 0.721 0.807 ## 2361 167 1 0.758 0.022284 0.716 0.803 ## 2373 161 1 0.753 0.022638 0.710 0.799 ## 2417 156 1 0.749 0.023002 0.705 0.795 ## 2469 152 1 0.744 0.023372 0.699 0.791 ## 2483 150 1 0.739 0.023736 0.694 0.787 ## 2520 144 1 0.734 0.024119 0.688 0.782 ## 2534 143 1 0.728 0.024490 0.682 0.778 ## 2551 140 1 0.723 0.024861 0.676 0.774 ## 2573 137 1 0.718 0.025234 0.670 0.769 ## 2636 127 1 0.712 0.025661 0.664 0.764 ## 2712 118 1 0.706 0.026144 0.657 0.759 ## 2763 115 1 0.700 0.026628 0.650 0.754 ## 2798 112 1 0.694 0.027114 0.643 0.749 ## 2854 109 1 0.687 0.027602 0.635 0.744 ## 2866 107 1 0.681 0.028082 0.628 0.738 ## 2911 105 1 0.675 0.028554 0.621 0.733 ## 2965 102 1 0.668 0.029030 0.613 0.727 ## 3063 86 1 0.660 0.029713 0.604 0.721 ## 3262 66 1 0.650 0.030901 0.592 0.714 ## 3409 54 1 0.638 0.032590 0.577 0.705 ## 3418 53 1 0.626 0.034127 0.563 0.697 ## 3461 50 1 0.614 0.035668 0.548 0.688 ## 3462 49 2 0.589 0.038357 0.518 0.669 ## 3472 47 1 0.576 0.039532 0.504 0.659 ## 3492 46 1 0.563 0.040608 0.489 0.649 ## 3669 40 1 0.549 0.041965 0.473 0.638 ## 3736 38 1 0.535 0.043280 0.457 0.627 ## 3873 36 1 0.520 0.044555 0.440 0.615 ## 3926 35 1 0.505 0.045693 0.423 0.603 ## 3941 34 1 0.490 0.046703 0.407 0.591 ## 3945 33 1 0.476 0.047593 0.391 0.579 ## 3959 31 1 0.460 0.048467 0.374 0.566 ## 4267 24 1 0.441 0.050097 0.353 0.551 ## 4456 19 1 0.418 0.052562 0.326 0.535 ## 6456 10 1 0.376 0.061715 0.273 0.519 ## 6593 9 1 0.334 0.067535 0.225 0.497 ## 7455 6 1 0.279 0.075850 0.163 0.475 绘制生存曲线，横轴表示生存时间，纵轴表示生存概率，为一条梯形下降的曲线。下降幅度越大，表示生存率越低或生存时间越短。 library(survminer) ## ## Attaching package: &#39;survminer&#39; ## The following object is masked from &#39;package:survival&#39;: ## ## myeloma # conf.int：是否显示置信区间 # risk.table: 对应时间存活个体总结表格 ggsurvplot(fit, conf.int=T,risk.table=T) ## Ignoring unknown labels: ## • fill : &quot;Strata&quot; ## Ignoring unknown labels: ## • fill : &quot;Strata&quot; ## Ignoring unknown labels: ## • fill : &quot;Strata&quot; ## Ignoring unknown labels: ## • fill : &quot;Strata&quot; ## Ignoring unknown labels: ## • colour : &quot;Strata&quot; PAM50是通过50个基因的表达量把乳腺癌分为四种类型 (Luminal A, Luminal B, HER2-enriched, and Basal-like)作为预后的标志。根据PAM50属性对病人进行分组，评估比较两组之间生存率的差别。 # 这三步不是必须的，只是为了方便，选择其中的4个确定了的分组进行分析 # 同时为了简化图例，给列重命名一下，使得列名不那么长 BRCA_PAM50 &lt;- BRCA[grepl(&quot;Basal|Her2|LumA|LumB&quot;,BRCA$PAM50Call_RNAseq),] BRCA_PAM50 &lt;- droplevels(BRCA_PAM50) colnames(BRCA_PAM50)[colnames(BRCA_PAM50)==&quot;PAM50Call_RNAseq&quot;] &lt;- &#39;PAM50&#39; # 按PAM50分组 fit &lt;- survfit(Surv(Days.survival, vital_status)~PAM50, data=BRCA_PAM50) # 绘制曲线 ggsurvplot(fit, conf.int=F,risk.table=T, risk.table.col=&quot;strata&quot;, pval=T) 简化Stage信息，先只查看大的阶段 BRCA_PAM50$pathologic_stage &lt;- gsub(&#39;(i+v*).*&#39;, &quot;\\\\1&quot;, BRCA_PAM50$pathologic_stage) BRCA_PAM50$pathologic_stage &lt;- as.factor(BRCA_PAM50$pathologic_stage) colnames(BRCA_PAM50)[colnames(BRCA_PAM50)==&quot;pathologic_stage&quot;] &lt;- &#39;PS&#39; fit &lt;- survfit(Surv(Days.survival, vital_status)~PS, data=BRCA_PAM50) # 绘制曲线 ggsurvplot(fit, conf.int=F,risk.table=T, risk.table.col=&quot;strata&quot;, pval=T) 3.15 一步作图的优势 目前这部分已不再更新，具体见后面提到的在线绘图网站（在绘制每个图的同时，也提供了这个图的绘制代码） 一步作图相比于直接写R代码有什么好处呢？ 模块化好。数据处理和可视化分开；一步作图，只是作图，不做无关的处理，更随意。 易用性强。敲代码，总不如给改数来得快。 重用性强。假如我要做十几个分开的基因集合呢？一段段复制代码？改错了或忘记改某个地方了怎么办？ 快速出图。先快速出个原型，再接着调整。 获取地址 https://github.com/Tong-Chen/s-plot. 在线绘图 http://www.Samp.com/ImageGP/ s-plot可以绘制的图的类型还有一些，列举如下； Usage: s-plot options Function: This software is designed to simply the process of plotting and help researchers focus more on data rather than technology. Currently, the following types of plot are supported. #### Bars s-plot barPlot #### Lines s-plot lines #### Dots s-plot pca s-plot scatterplot3d s-plot scatterplot2 s-plot scatterplotColor s-plot scatterplotContour s-plot scatterplotLotsData s-plot scatterplotMatrix s-plot scatterplotDoubleVariable s-plot contourPlot s-plot density2d #### Distribution s-plot areaplot s-plot boxplot s-plot densityHistPlot #### Cluster s-plot hcluster_gg (latest) #### Heatmap s-plot heatmapS s-plot heatmapM s-plot heatmap.2 s-plot pheatmap s-plot prettyHeatmap #### Others s-plot volcano s-plot vennDiagram s-plot upsetView 3.16 不改脚本的热图绘制 绘图时通常会碰到两个头疼的问题： 1. 需要画很多的图，唯一的不同就是输出文件，其它都不需要修改。如果用R脚本，需要反复替换文件名，繁琐又容易出错。 每次绘图都需要不断的调整参数，时间久了不用，就忘记参数放哪了；或者调整次数过多，有了很多版本，最后不知道用哪个了。 为了简化绘图、维持脚本的一致，我用bash对R做了一个封装，然后就可以通过修改命令好参数绘制不同的图了。 先看一看怎么使用 首先把测试数据存储到文件中方便调用。数据矩阵存储在heatmap_data.xls文件中；行注释存储在heatmap_row_anno.xls文件中；列注释存储在heatmap_col_anno.xls文件中。 # tab键分割，每列不加引号 write.table(data, file=&quot;heatmap_data.xls&quot;, sep=&quot;\\t&quot;, row.names=T, col.names=T,quote=F) # 如果看着第一行少了ID列不爽，可以填补下 system(&quot;sed -i &#39;1 s/^/ID\\t/&#39; heatmap_data.xls&quot;) write.table(row_anno, file=&quot;heatmap_row_anno.xls&quot;, sep=&quot;\\t&quot;, row.names=T, col.names=T,quote=F) write.table(col_anno, file=&quot;heatmap_col_anno.xls&quot;, sep=&quot;\\t&quot;, row.names=T, col.names=T,quote=F) 然后用程序sp_pheatmap.sh绘图。 # -f: 指定输入的矩阵文件 # -d：指定是否计算Z-score，&lt;none&gt; (否), &lt;row&gt; (按行算), &lt;col&gt; (按列算) # -P: 行注释文件 # -Q: 列注释文件 ct@Samp:~/$ sp_pheatmap.sh -f heatmap_data.xls -d row -P heatmap_row_anno.xls \\ -Q heatmap_col_anno.xls 字有点小，是因为图太大了，把图的宽和高缩小下试试。 # -f: 指定输入的矩阵文件 # -d：指定是否计算Z-score，&lt;none&gt; (否), &lt;row&gt; (按行算), &lt;col&gt; (按列算) # -P: 行注释文件 # -Q: 列注释文件 # -u: 设置宽度，单位是inch # -v: 设置高度，单位是inch ct@Samp:~/$ sp_pheatmap.sh -f heatmap_data.xls -d row -P heatmap_row_anno.xls \\ -Q heatmap_col_anno.xls -u 8 -v 12 横轴的标记水平放置 # -A: 0, X轴标签选择0度 # -C: 自定义颜色，注意引号的使用，最外层引号与内层引号不同，引号之间无交叉 # -T: 指定给定的颜色的类型；如果给的是vector (如下面的例子), 则-T需要指定为vector; # 否则结果会很怪异，只有俩颜色。 # -t: 指定图形的题目，注意引号的使用；参数中包含空格或特殊字符等都要用引号引起来作为一个整体。 ct@Samp:~/$ sp_pheatmap.sh -f heatmap_data.xls -d row -P heatmap_row_anno.xls \\ -Q heatmap_col_anno.xls -u 8 -v 12 -A 0 -C &#39;c(&quot;white&quot;, &quot;blue&quot;)&#39; -T vector \\ -t &quot;Heatmap of gene expression profile&quot; sp_pheatmap.sh的参数还有一些，可以完成前面讲述过的所有热图的绘制，具体如下： ***CREATED BY Chen Tong (chentong_biology@163.com)*** ----Matrix file-------------- Name T0_1 T0_2 T0_3 T4_1 T4_2 TR19267|c0_g1|CYP703A2 1.431 0.77 1.309 1.247 0.485 TR19612|c1_g3|CYP707A1 0.72 0.161 0.301 2.457 2.794 TR60337|c4_g9|CYP707A1 0.056 0.09 0.038 7.643 15.379 TR19612|c0_g1|CYP707A3 2.011 0.689 1.29 0 0 TR35761|c0_g1|CYP707A4 1.946 1.575 1.892 1.019 0.999 TR58054|c0_g2|CYP707A4 12.338 10.016 9.387 0.782 0.563 TR14082|c7_g4|CYP707A4 10.505 8.709 7.212 4.395 6.103 TR60509|c0_g1|CYP707A7 3.527 3.348 2.128 3.257 2.338 TR26914|c0_g1|CYP710A1 1.899 1.54 0.998 0.255 0.427 ----Matrix file-------------- ----Row annorarion file -------------- ------1. At least two columns-------------- ------2. The first column should be the same as the first column in matrix (order does not matter)-------------- Name Clan Family TR19267|c0_g1|CYP703A2 CYP71 CYP703 TR19612|c1_g3|CYP707A1 CYP85 CYP707 TR60337|c4_g9|CYP707A1 CYP85 CYP707 TR19612|c0_g1|CYP707A3 CYP85 CYP707 TR35761|c0_g1|CYP707A4 CYP85 CYP707 TR58054|c0_g2|CYP707A4 CYP85 CYP707 TR14082|c7_g4|CYP707A4 CYP85 CYP707 TR60509|c0_g1|CYP707A7 CYP85 CYP707 TR26914|c0_g1|CYP710A1 CYP710 CYP710 ----Row annorarion file -------------- ----Column annorarion file -------------- ------1. At least two columns-------------- ------2. The first column should be the same as the first row in ---------matrix (order does not matter)-------------- Name Sample T0_1 T0 T0_2 T0 T0_3 T0 T4_1 T4 T4_2 T4 ----Column annorarion file -------------- Usage: sp_pheatmap.sh options Function: This script is used to do heatmap using package pheatmap. The parameters for logical variable are either TRUE or FALSE. OPTIONS: -f Data file (with header line, the first column is the rowname, tab seperated. Colnames must be unique unless you know what you are doing.)[NECESSARY] -t Title of picture[Default empty title] [&quot;Heatmap of gene expression profile&quot;] -a Display xtics. [Default TRUE] -A Rotation angle for x-axis value (anti clockwise) [Default 90] -b Display ytics. [Default TRUE] -H Hieratical cluster for columns. Default FALSE, accept TRUE -R Hieratical cluster for rows. Default TRUE, accept FALSE -c Clustering method, Default &quot;complete&quot;. Accept &quot;ward.D&quot;, &quot;ward.D2&quot;,&quot;single&quot;, &quot;average&quot; (=UPGMA), &quot;mcquitty&quot; (=WPGMA), &quot;median&quot; (=WPGMC) or &quot;centroid&quot; (=UPGMC) -C Color vector. Default pheatmap_default. Aceept a vector containing multiple colors such as &lt;&#39;c(&quot;white&quot;, &quot;blue&quot;)&#39;&gt; will be transferred to &lt;colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;), bias=1)(30)&gt; or an R function &lt;colorRampPalette(rev(brewer.pal(n=7, name=&quot;RdYlBu&quot;)))(100)&gt; generating a list of colors. -T Color type, a vetcor which will be transferred as described in &lt;-C&gt; [vector] or a raw vector [direct vector] or a function [function (default)]. -B A positive number. Default 1. Values larger than 1 will give more color for high end. Values between 0-1 will give more color for low end. -D Clustering distance method for rows. Default &#39;correlation&#39;, accept &#39;euclidean&#39;, &quot;manhattan&quot;, &quot;maximum&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot;. -I Clustering distance method for cols. Default &#39;correlation&#39;, accept &#39;euclidean&#39;, &quot;manhattan&quot;, &quot;maximum&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot;. -L First get log-value, then do other analysis. Accept an R function log2 or log10. [Default FALSE] -d Scale the data or not for clustering and visualization. [Default &#39;none&#39; means no scale, accept &#39;row&#39;, &#39;column&#39; to scale by row or column.] -m The maximum value you want to keep, any number larger willl be taken as this given maximum value. [Default Inf, Optional] -s The smallest value you want to keep, any number smaller will be taken as this given minimum value. [Default -Inf, Optional] -k Aggregate the rows using kmeans clustering. This is advisable if number of rows is so big that R cannot handle their hierarchical clustering anymore, roughly more than 1000. Instead of showing all the rows separately one can cluster the rows in advance and show only the cluster centers. The number of clusters can be tuned here. [Default &#39;NA&#39; which means no cluster, other positive interger is accepted for executing kmeans cluster, also the parameter represents the number of expected clusters.] -P A file to specify row-annotation with format described above. [Default NA] -Q A file to specify col-annotation with format described above. [Default NA] -u The width of output picture.[Default 20] -v The height of output picture.[Default 20] -E The type of output figures.[Default pdf, accept eps/ps, tex (pictex), png, jpeg, tiff, bmp, svg and wmf)] -r The resolution of output picture.[Default 300 ppi] -F Font size [Default 14] -p Preprocess data matrix to avoid &#39;STDERR 0 in cor(t(mat))&#39;. Lowercase &lt;p&gt;. [Default TRUE] -e Execute script (Default) or just output the script. [Default TRUE] -i Install the required packages. Normmaly should be TRUE if this is your first time run s-plot.[Default FALSE] 3.16.1 箱线图 - 一步绘制 首先把测试数据存储到文件中方便调用。数据矩阵存储在boxplot.normal.data、sampleGroup和boxplot.melt.data文件中 (TAB键分割，内容在文档最后。如果你手上有自己的数据，也可以拿来用)。 使用正常矩阵默认参数绘制箱线图 # -f: 指定输入的矩阵文件，第一列为行名字，第一行为header 列数不限，列名字不限；行数不限，行名字默认为文本 sp_boxplot.sh -f boxplot.normal.data 箱线图出来了，但有点小乱。 # -f: 指定输入的矩阵文件，第一列为行名字，第一行为header 列数不限，列名字不限；行数不限，行名字默认为文本 # -P: none, 去掉legend (uppercase P) # -b: X-axis旋转45度 # -V: TRUE 绘制小提琴图 sp_boxplot.sh -f boxplot.normal.data -P none -b 45 -V TRUE 绘制单个基因的小提琴图加抖动图 # -q: 指定某一行的名字，此处为基因名，绘制基因A的表达图谱 # -Q: 指定样本分组，绘制基因A在不同样品组的表达趋势 # -F Group: sampleGroup中第二列的名字，指代分组信息，根据需要修改 # -J TRUE: 绘制抖动图 jitter plot # -L: 设置X轴样品组顺序 # -c TRUE -C &quot;&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;&quot;: 指定每个箱线图的颜色 sp_boxplot.sh -f boxplot.normal.data -q A -Q sampleGroup -F Group -V TRUE -J TRUE \\ -L &quot;&#39;zygote&#39;,&#39;2cell&#39;,&#39;4cell&#39;&quot; -c TRUE -C &quot;&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;&quot; -P none 使用melted矩阵默认参数绘箱线图 # -f: 指定输入文件 # -m TRUE: 指定输入的矩阵为melted format # -d Expr：指定表达值所在的列 # -F Rep: 指定子类所在列，也就是legend # -a Group：指定X轴分组信息 # -j TRUE: jitter plot sp_boxplot.sh -f boxplot.melt.data -m TRUE -d Expr -F Rep -a Group -j TRUE # 如果没有子类，则-a和-F指定为同一值 # -R TRUE: 旋转boxplot sp_boxplot.sh -f boxplot.melt.data -m TRUE -d Expr -a Group -F Group -J TRUE -R TRUE 参数中最需要注意的是引号的使用： 外层引号与内层引号不能相同 凡参数值中包括了空格，括号，逗号等都用引号括起来作为一个整体。 #boxplot.normal.data Name 2cell_1 2cell_2 2cell_3 2cell_4 2cell_5 2cell_6 4cell_1 4cell_2 4cell_3 4cell_4 4cell_5 4cell_6 zygote_1 zygote_2 zygote_3 zygote_4 zygote_5 zygote_6 A 4 6 7 5 8 6 3.2 5.2 5.6 3.6 7.6 4.8 2 4 3 2 4 2.5 B 6 8 9 7 10 8 5.2 7.2 7.6 5.6 9.6 6.8 4 6 5 4 6 4.5 C 8 10 11 9 12 10 7.2 9.2 9.6 7.6 11.6 8.8 6 8 7 6 8 6.5 D 10 12 13 11 14 12 9.2 11.2 11.6 9.6 13.6 10.8 8 10 9 8 10 8.5 E 12 14 15 13 16 14 11.2 13.2 13.6 11.6 15.6 12.8 10 12 11 10 12 10.5 F 14 16 17 15 18 16 13.2 15.2 15.6 13.6 17.6 14.8 12 14 13 12 14 12.5 G 15 17 18 16 19 17 14.2 16.2 16.6 14.6 18.6 15.8 13 15 14 13 15 13.5 H 16 18 19 17 20 18 15.2 17.2 17.6 15.6 19.6 16.8 14 16 15 14 16 14.5 I 17 19 20 18 21 19 16.2 18.2 18.6 16.6 20.6 17.8 15 17 16 15 17 15.5 J 18 20 21 19 22 20 17.2 19.2 19.6 17.6 21.6 18.8 16 18 17 16 18 16.5 L 19 21 22 20 23 21 18.2 20.2 20.6 18.6 22.6 19.8 17 19 18 17 19 17.5 M 20 22 23 21 24 22 19.2 21.2 21.6 19.6 23.6 20.8 18 20 19 18 20 18.5 N 21 23 24 22 25 23 20.2 22.2 22.6 20.6 24.6 21.8 19 21 20 19 21 19.5 O 22 24 25 23 26 24 21.2 23.2 23.6 21.6 25.6 22.8 20 22 21 20 22 20.5 #boxplot.melt.data Gene Sample Group Expr Rep A zygote_1 zygote 2 1 A zygote_2 zygote 4 2 A zygote_3 zygote 3 3 A zygote_4 zygote 2 4 A zygote_5 zygote 4 5 A zygote_6 zygote 2.5 6 A 2cell_1 2cell 4 1 A 2cell_2 2cell 6 2 A 2cell_3 2cell 7 3 A 2cell_4 2cell 5 4 A 2cell_5 2cell 8 5 A 2cell_6 2cell 6 6 A 4cell_1 4cell 3.2 1 A 4cell_2 4cell 5.2 2 A 4cell_3 4cell 5.6 3 A 4cell_4 4cell 3.6 4 A 4cell_5 4cell 7.6 5 A 4cell_6 4cell 4.8 6 #sampleGroup Sample Group zygote_1 zygote zygote_2 zygote zygote_3 zygote zygote_4 zygote zygote_5 zygote zygote_6 zygote 2cell_1 2cell 2cell_2 2cell 2cell_3 2cell 2cell_4 2cell 2cell_5 2cell 2cell_6 2cell 4cell_1 4cell 4cell_2 4cell 4cell_3 4cell 4cell_4 4cell 4cell_5 4cell 4cell_6 4cell 3.16.2 线图 - 一步绘制 首先把测试数据存储到文件中方便调用。数据矩阵存储在line_data.xls和line_data_melt.xls文件中 (直接拷贝到文件中也可以，这里这么操作只是为了随文章提供个测试文件，方便使用。如果你手上有自己的数据，也可以拿来用)。 profile = &quot;Pos;H3K27ac;CTCF;Enhancer;H3K4me3;polII -5000;8.7;10.7;11.7;10;8.3 -4000;8.4;10.8;11.8;9.8;7.8 -3000;8.3;10.5;12.2;9.4;7 -2000;7.2;10.9;12.7;8.4;4.8 -1000;3.6;8.5;12.8;4.8;1.3 0;3.6;8.5;13.4;5.2;1.5 1000;7.1;10.9;12.4;8.1;4.9 2000;8.2;10.7;12.4;9.5;7.7 3000;8.4;10.4;12;9.8;7.9 4000;8.5;10.6;11.7;9.7;8.2 5000;8.5;10.6;11.7;10;8.2&quot; profile_text &lt;- read.table(text=profile, header=T, row.names=1, quote=&quot;&quot;,sep=&quot;;&quot;) # tab键分割，每列不加引号 write.table(profile_text, file=&quot;line_data.xls&quot;, sep=&quot;\\t&quot;, row.names=T, col.names=T,quote=F) # 如果看着第一行少了ID列不爽，可以填补下 #system(&quot;sed -i &#39;1 s/^/ID\\t/&#39; line_data.xls&quot;) profile = &quot;Pos;variable;value;set -5000;H3K27ac;8.71298;A -4000;H3K27ac;8.43246;A -3000;H3K27ac;8.25497;A -2000;H3K27ac;7.16265;A -1000;H3K27ac;3.55341;A 0;H3K27ac;3.5503;A 1000;H3K27ac;7.07502;A 2000;H3K27ac;8.24328;A 3000;H3K27ac;8.43869;A 4000;H3K27ac;8.48877;A -5000;CTCF;10.6913;A -4000;CTCF;10.7668;A -3000;CTCF;10.5441;A -2000;CTCF;10.8635;A -1000;CTCF;8.45751;A 0;CTCF;8.50316;A 1000;CTCF;10.9143;A 2000;CTCF;10.7022;A 3000;CTCF;10.4101;A 4000;CTCF;10.5757;A -5000;H3K27ac;8.71298;B -4000;H3K27ac;8.43246;B -3000;H3K27ac;8.25497;B -2000;H3K27ac;7.16265;B -1000;H3K27ac;3.55341;B 0;H3K27ac;3.5503;B 1000;H3K27ac;7.07502;B 2000;H3K27ac;8.24328;B 3000;H3K27ac;8.43869;B 4000;H3K27ac;8.48877;B -5000;CTCF;10.6913;B -4000;CTCF;10.7668;B -3000;CTCF;10.5441;B -2000;CTCF;10.8635;B -1000;CTCF;8.45751;B 0;CTCF;8.50316;B 1000;CTCF;10.9143;B 2000;CTCF;10.7022;B 3000;CTCF;10.4101;B 4000;CTCF;10.5757;B&quot; profile_text &lt;- read.table(text=profile, header=T, quote=&quot;&quot;,sep=&quot;;&quot;) # tab键分割，每列不加引号 write.table(profile_text, file=&quot;line_data_melt.xls&quot;, sep=&quot;\\t&quot;, row.names=T, col.names=T,quote=F) # 如果看着第一行少了ID列不爽，可以填补下 # system(&quot;sed -i &#39;1 s/^/ID\\t/&#39; line_data_melt.xls&quot;) 使用正常矩阵默认参数绘制个线图 # -f: 指定输入的矩阵文件，第一列为行名字，第一行为header 列数不限，列名字不限；行数不限，行名字默认为文本 # -A FALSE: 指定行名为数字 sp_lines.sh -f line_data.xls -A FALSE # -l: 设定图例的顺序 # -o TRUE: 局部拟合获得平滑曲线 # -A FALSE: 指定行名为数字 # -P: 设置legend位置，相对于原点的坐标 # -x, -y指定横纵轴标记 sp_lines.sh -f line_data.xls -l &quot;&#39;CTCF&#39;,&#39;Enhancer&#39;,&#39;polII&#39;,&#39;H3K4me3&#39;,&#39;H3K27ac&#39;&quot; \\ -P &#39;c(0.8,0.3)&#39; -o TRUE -A FALSE -x &#39;Up and down 5 kb of TSS&#39; -y &#39;Relative density&#39; # -A FALSE: 指定行名为数字 # -V &#39;c(-1000, 500)&#39;: 设置垂线的位置 # -D: 设置垂线的文本标记，参数为引号引起来的vector，注意引号的嵌套 # -I: 设置横轴的标记的位置 # -b: 设置横轴标记的文字 sp_lines.sh -f line_data.xls -A FALSE -V &#39;c(-1000,500)&#39; -D &quot;c(&#39;+1 kb&#39;,&#39;-0.5 kb&#39;)&quot; \\ -I &quot;c(-5000,0,5000)&quot; -b &quot;c(&#39;-5 kb&#39;, &#39;TSS&#39;, &#39;+5 kb&#39;)&quot; 使用melted矩阵默认参数绘制个线图 (除需要改变文件格式，指定-m TRUE, -a xvariable外其它与正常矩阵一样) # -f: 指定输入文件 # -m TRUE: 指定输入的矩阵为melted format, 三列，第一列为Pos (给-a) # 第二列为variable (给-H，-H默认即为variable) # 第三列为value，名字不可修改 # -A FALSE: 指定行名为数字 # -P &#39;c(0.8,0.2)&#39;: 设置legend位置，相对于原点的坐标 sp_lines.sh -f line_data_melt.xls -a Pos -m TRUE -A FALSE -P &#39;c(0.8,0.2)&#39; 完整的图 # -C: 自定义线的颜色 sp_lines.sh -f line_data_melt.xls -a Pos -m TRUE -A FALSE -P &#39;c(0.8,0.2)&#39; -o TRUE \\ -V &#39;c(-1000,500)&#39; -D &quot;c(&#39;+1 kb&#39;,&#39;-0.5 kb&#39;)&quot; \\ -I &quot;c(-5000,0,4000)&quot; -b &quot;c(&#39;-5 kb&#39;, &#39;TSS&#39;, &#39;+4 kb&#39;)&quot; \\ -x &#39;Up 5 kb and down 4 kb of TSS&#39; -y &#39;Relative density&#39; -C &quot;&#39;pink&#39;, &#39;blue&#39;&quot; 参数中最需要注意的是引号的使用： 外层引号与内层引号不能相同 凡参数值中包括了空格，括号，逗号等都用引号括起来作为一个整体。 完整参数列表如下： ct@Samp:~ $sp_lines.sh ***CREATED BY Chen Tong (chentong_biology@163.com)*** Usage: /MPATHB/self/s-plot/sp_lines.sh options Function: This script is used to draw a line or multiple lines using ggplot2. You can specify whether or not smooth your line or lines. Two types of input files are supported, normal matrix or melted matrix format. Column separator for both types of input files is **tab**. Here is an example of normal matrix format. The first column will be treated as X-axis variables and other columns represents each type of lines. The number of columns is unlimited and names of columns is unlimited. **Set** column is not needed. If given, &lt;facet_plot&gt; (multiple plots in one page) could be displayed. ------------------------------------------------------------ Pos H3K27ac CTCF Enhancer H3K4me3 polII -5000 8.71298 10.69130 11.7359 10.02510 8.26866 -4000 8.43246 10.76680 11.8442 9.76927 7.78358 -3000 8.25497 10.54410 12.2470 9.40346 6.96859 -2000 7.16265 10.86350 12.6889 8.35070 4.84365 -1000 3.55341 8.45751 12.8372 4.84680 1.26110 0 3.55030 8.50316 13.4152 5.17401 1.50022 1000 7.07502 10.91430 12.3588 8.13909 4.88096 2000 8.24328 10.70220 12.3888 9.47255 7.67968 3000 8.43869 10.41010 11.9760 9.80665 7.94148 4000 8.48877 10.57570 11.6562 9.71986 8.17849 ------------------------------------------------------ ------------With SET------------------------------------------ Pos H3K27ac CTCF Enhancer H3K4me3 polII Set -5000 8.71298 10.69130 11.7359 10.02510 8.26866 1 -4000 8.43246 10.76680 11.8442 9.76927 7.78358 1 -3000 8.25497 10.54410 12.2470 9.40346 6.96859 1 -2000 7.16265 10.86350 12.6889 8.35070 4.84365 1 -1000 3.55341 8.45751 12.8372 4.84680 1.26110 1 0 3.55030 8.50316 13.4152 5.17401 1.50022 1 1000 7.07502 10.91430 12.3588 8.13909 4.88096 1 2000 8.24328 10.70220 12.3888 9.47255 7.67968 1 3000 8.43869 10.41010 11.9760 9.80665 7.94148 1 4000 8.48877 10.57570 11.6562 9.71986 8.17849 1 -5000 8.71298 10.69130 11.7359 10.02510 8.26866 2 -4000 8.43246 10.76680 11.8442 9.76927 7.78358 2 -3000 8.25497 10.54410 12.2470 9.40346 6.96859 2 -2000 7.16265 10.86350 12.6889 8.35070 4.84365 2 -1000 3.55341 8.45751 12.8372 4.84680 1.26110 2 0 3.55030 8.50316 13.4152 5.17401 1.50022 2 1000 7.07502 10.91430 12.3588 8.13909 4.88096 2 2000 8.24328 10.70220 12.3888 9.47255 7.67968 2 3000 8.43869 10.41010 11.9760 9.80665 7.94148 2 4000 8.48877 10.57570 11.6562 9.71986 8.17849 2 ------------------------------------------------------------- For matrix format, example command lines include: * Attribute of X-axis value (first column of matrix) is &lt;number&gt; s-plot lines -f matrix.file -A FALSE * Attribute of X-axis value (first column of matrix) is &lt;text&gt; s-plot lines -f matrix.file * Attribute of X-axis value (first column of matrix) is numbers, change legned order (default alphabet order) s-plot lines -f matrix.file -l &quot;&#39;polII&#39;, &#39;CTCF&#39;, &#39;Enhancer&#39;, &#39;H3K27ac&#39;, &#39;H3K4me3&#39;&quot; * Attribute of X-axis value (first column of matrix) is numbers, change legned order (default alphabet order), smooth lines to look better (Pay attention to whether this will change the data trend) s-plot lines -f matrix.file -l &quot;&#39;polII&#39;, &#39;CTCF&#39;, &#39;Enhancer&#39;, &#39;H3K27ac&#39;, &#39;H3K4me3&#39;&quot; -o TRUE * Attribute of X-axis value (first column of matrix) is numbers, with &lt;Set&gt; (Set is column name) column s-plot lines -f matrix.file -F &quot;+facet_grid(Set ~ ., scale=&#39;free_y&#39;)&quot; FILEFORMAT when -m is true #The name &quot;value&quot; shoud **not** be altered. #variable can be altered using -H #Actually this format is the melted result of last format. -------------------------------------------------------------- Pos variable value -5000 H3K27ac 8.71298 -4000 H3K27ac 8.43246 -3000 H3K27ac 8.25497 -2000 H3K27ac 7.16265 -1000 H3K27ac 3.55341 0 H3K27ac 3.55030 1000 H3K27ac 7.07502 2000 H3K27ac 8.24328 3000 H3K27ac 8.43869 4000 H3K27ac 8.48877 -5000 CTCF 10.69130 -4000 CTCF 10.76680 -3000 CTCF 10.54410 -2000 CTCF 10.86350 -1000 CTCF 8.45751 0 CTCF 8.50316 1000 CTCF 10.91430 2000 CTCF 10.70220 3000 CTCF 10.41010 4000 CTCF 10.57570 ------------------------------------------------------------- * Attribute of X-axis value (melt format) is &lt;number&gt; s-plot lines -f matrix.file -m TRUE -a Pos -A FALSE * Attribute of X-axis value (first column of matrix) is &lt;text&gt; s-plot lines -f matrix.file -m TRUE -a Pos * If the name of the second column is &lt;type&gt; not &lt;variable&gt;, one should specify with &lt;-H&gt;. s-plot lines -f matrix.file -A FALSE -m TRUE -a Pos -H type * Attribute of X-axis value (first column of matrix) is numbers, change legned order (default alphabet order) s-plot lines -f matrix.file -m TRUE -a Pos -l &quot;&#39;polII&#39;, &#39;CTCF&#39;, &#39;Enhancer&#39;, &#39;H3K27ac&#39;, &#39;H3K4me3&#39;&quot; * Attribute of X-axis value (first column of matrix) is numbers, change legned order (default alphabet order), smooth lines to look better (Pay attention to whether this will change the data trend) s-plot lines -f matrix.file -m TRUE -a Pos -l &quot;&#39;polII&#39;, &#39;CTCF&#39;, &#39;Enhancer&#39;, &#39;H3K27ac&#39;, &#39;H3K4me3&#39;&quot; -o TRUE * Attribute of X-axis value (first column of matrix) is numbers, with &lt;Set&gt; (Set is column name) column s-plot lines -f matrix.file -F &quot;+facet_grid(Set ~ ., scale=&#39;free_y&#39;)&quot; OPTIONS: -f Data file (with header line, the first column would be be treated as rownames for normal matrix. No rownames for melted format. Columns are tab seperated) [NECESSARY] -m When true, it will skip melt preprocesses. But the format must be the same as listed before. [Default FALSE, accept TRUE] -a Name for x-axis variable [Only needed when &lt;-m&gt; is &lt;TRUE&gt;. For the melted data, &#39;Pos&#39; should be given here. For normal matrix, default the first column will be used, program will assign an value &#39;xvariable&#39; to represent it. ]] -A Are x-axis variables numbers. [Default &lt;TRUE&gt;, meaning X-axis label is &lt;text&gt;. &lt;FALSE&gt; means X-axis label is &lt;numerical&gt;.] -H Name for legend variable. [Default variable, this should only be set when -m is TRUE] -J Name for color variable. [Default same as -H, this should only be set when -m is TRUE] -l Set orders of legend variable. [Default column order for normal matrix, accept a string like &quot;&#39;CTCF&#39;,&#39;H3K27ac&#39;,&#39;Enhancer&#39;&quot; to set your own order. Pay attention to the usage of two types of quotes. ***When -m is TRUE, default order would be alphabet order.********* ] -P Legend position[Default right. Accept top, bottom, left, none, or &#39;c(0.08,0.8)&#39;.] -L Levels for x-axis variable, suitable when x-axis is not treated as numerical. [Default the order of first column for normal matrix. Accept a string like &quot;&#39;g&#39;,&#39;a&#39;,&#39;j&#39;,&#39;x&#39;,&#39;s&#39;,&#39;c&#39;,&#39;o&#39;,&#39;u&#39;&quot; to set your own oder. This will only be considered when -A is TRUE. ***When -m is used, this default order would be alphabet order.********* ] -o Smooth lines or not. [Default FALSE means no smooth. Accept TRUE to smooth lines.] -O The smooth method you want to use. [smoothing method (function) to use, eg. lm, glm, gam, loess,rlm. For datasets with n &lt; 1000 default is &#39;loess&#39;. For datasets with 1000 or more observations defaults to &#39;gam&#39;. ] -V Add vertical lines.[Default FALSE, accept a series of numbers in following format &quot;c(1,2,3,4,5)&quot; or other R code that can generate a vector.] -D Add labels to vlines. [Default same as -V. Accept a series of numbers in following format &quot;c(1,2,3,4,5)&quot; or other R code that can generate a vector as labels. Or one can give &#39;1&#39; to disallow labels] -j Add horizontal lines.[Default FALSE, accept a series of numbers in following format &quot;c(1,2,3,4,5)&quot; or other R code that can generate a vector] -d Add labels to hline. [Default same as -j Accept a series of numbers in following format &quot;c(1,2,3,4,5)&quot; or other R code that can generate a vector as labels. Or one can give &#39;1&#39; to disallow labels] -I Manually set the position of xtics. [Default FALSE, accept a series of numbers in following format &quot;c(1,2,3,4,5)&quot; or other R code that can generate a vector to set the position of xtics] -b Manually set the value of xtics when -I is specified. [Default the content of -I when -I is specified, accept a series of numbers in following format &quot;c(1,2,3,4,5)&quot; or other R code that can generate a vector to set the position of xtics] -X Display xtics. [Default TRUE] -Y Display ytics. [Default TRUE] -R Rotation angle for x-axis labels (anti clockwise) [Default 0] -B line size. [Default 1. Accept a number.] -t Title of picture[Default empty title] -x xlab of picture[Default empty xlab] -y ylab of picture[Default empty ylab] -c Manually set colors for each line.[Default FALSE, meaning using ggplot2 default.] -C Color for each line. When -c is TRUE, one has two options: 1. Supplying a function to generate colors, like &quot;rainbow(11)&quot; or &quot;rainbow(11, alpha=0.6)&quot;, rainbow is an R color palletes, 11 is the number of colors you want to get, 0.6 is the alpha value. The R palletes include &lt;heat.colors&gt;, &lt;terrain.colors&gt;, &lt;topo.colors&gt;, &lt;cm.colors&gt;. 2. Supplying a list of colors in given format, the number of colors should be equal to the number of bars like &quot;&#39;red&#39;,&#39;pink&#39;,&#39;blue&#39;,&#39;cyan&#39;,&#39;green&#39;,&#39;yellow&#39;&quot; or &quot;rgb(255/255,0/255,0/255),rgb(255/255,0/255,255/255), rgb(0/255,0/255,255/255),rgb(0/255,255/255,255/255), rgb(0/255,255/255,0/255),rgb(255/255,255/255,0/255)&quot; One can use R fucntion &lt;colors()&gt; to list all available colors. -s Scale y axis [Default null. Accept TRUE. This function is depleted. But if the supplied number after -S is not 0, this parameter will be set to TRUE] -F The formula for facets.[Default no facets, &quot;+facet_grid(level ~ .)&quot; means divide by levels of &#39;level&#39; vertically. &quot;+facet_grid(. ~ level)&quot; means divide by levels of &#39;level&#39; horizontally. &quot;+facet_grid(lev1 ~ lev2)&quot; means divide by lev1 vertically and lev2 horizontally. &quot;+facet_wrap(~level, ncol=2)&quot; means wrap horizontally with 2 columns. #Pay attention to the single quote for parameters in function for scale. Example: &quot;+facet_wrap(~Size,ncol=6,scale=&#39;free&#39;)&quot; Example: &quot;+facet_grid(Size ~ .,scale=&#39;free_y&#39;)&quot; ] -G If facet is given, you may want to specifize the order of variable in your facet, default alphabetical order. [Accept sth like (one level one sentence, separate by&#39;;&#39;) &#39;data$size &lt;- factor(data$size, levels=c(&quot;l1&quot;, &quot;l2&quot;,...,&quot;l10&quot;), ordered=T)&#39; ] -v If scale is TRUE, give the following &#39;scale_y_log10()&#39;[default], &#39;coord_trans(y=&quot;log10&quot;)&#39;, or other legal command for ggplot2 or simply &#39;log2&#39;.] -S A number to add if scale is used. [Default 0. If a non-zero number is given, -s would be set to TRUE.] -p Other legal R codes for gggplot2 could be given here. [Begin with &#39;+&#39; ] -w The width of output picture (cm).[Default 20] -u The height of output picture (cm).[Default 12] -E The type of output figures.[Default pdf, accept eps/ps, tex (pictex), png, jpeg, tiff, bmp, svg and wmf)] -r The resolution of output picture.[Default 300 ppi] -z Is there a header. Must be TRUE. [Default TRUE] -e Execute or not[Default TRUE] -i Install depended packages[Default FALSE] 3.16.3 一网打进散点图绘制 假如有一个输入数据如下所示(存储于文件scatterplot.xls中) Samp Gene1 Gene2 Color Size GC_quality Base_quality a 1 1 grp1 10 PASS PASS b 2 2 grp1 10 PASS PASS c 1 3 grp1 10 WARN PASS d 3 1 grp2 15 WARN WARN e 2 2 grp2 15 PASS WARN f 3 3 grp3 5 PASS PASS g 2 1 grp3 5 WARN PASS 想绘制样品在这两个Gene为轴的空间的分布，并标记样品的属性，只需要运行如下命令 # -f: 指定输入文件，列数不限，顺序不限; 第一行为列名字，第一列无特殊要求，必选 # -X: 指定哪一列为X轴信息，必选 # -Y: 指定哪一列为Y轴信息，必选 # -c: 指定用哪一列标记颜色，可选 # -s: 指定哪一列标记大小，一般为数字列，可选 # -S: 指定哪一列标记形状，可选 # -L: 指定哪一列用来作为文本标记 # -w, -u: 指定图的长宽 sp_scatterplot2.sh -f scatterplot.xls -X Gene1 -Y Gene2 -c Color -s Size \\ -S GC_quality -L Samp -w 10 -u 10 如果横纵轴为字符串，且有重复, 则需指定参数-J TRUE以错开重叠的点，具体如下 # -O: 指定X轴变量的顺序, 默认是字母顺序 # 其它列或其它属性的顺序也可以用相应的方式指示，具体看程序的帮助提示 # -c Gene1: 用特定基因的表达对点着色，单细胞分析图中常用 # -J TRUE: 见上 # -Z FALSE：默认使用geom_text_repel添加点的标记，及其智能，不会出现标签过多覆盖的情况 # 但对jitterplot，会有些冲突，所以在`-J TRUE`且出来的图中点的标签不符合预期时，设定 # 次参数为FALSE，使用geom_text标记点。 sp_scatterplot2.sh -f scatterplot.xls -X GC_quality -Y Base_quality \\ -O &quot;&#39;WARN&#39;, &#39;PASS&#39;&quot; -c Gene1 -w 10 -u 10 -J TRUE -L Samp -Z FALSE 只有想不到，没有做不到，sp_scatterplot2.sh还可以完成更多你想做的散点图，而且只需调参数，无需改代码，简单可重用。 3.17 参考资料 http://rpubs.com/xuefliang/153247 http://www.sthda.com/english/wiki/survminer-r-package-survival-data-analysis-and-visualization https://stackoverflow.com/questions/52446477/r-hclust-common-order-for-multiple-trees https://www.biostars.org/p/237067/ "],["cytoscape.html", "4 网络图 4.1 参考", " 4 网络图 Cytoscape已成为网络图绘制的核心工具，基因表达调控网络、蛋白互作网络、miRNA-gene调节关系、分析流程、组织架构等任何与网络、结构、层级有关系的事情都可以用Cytoscape来绘制。前期的教程中有Cytoscape的基本使用，早期录制的Cytoscape视频教程, 含安装和基本使用，更新录制的Cytoscape视频教程等。 这次主要以实际操作的形式来讲述Cytoscape的使用，内容以PPT教案为主。 下面是补充内容。 本次三个视频，截取不同的角度 (更多Cytoscape视频在B站: https://space.bilibili.com/362709786)。 4.0.1 基本操作 利用一个简单的组织构建图展示Cytoscape的基本使用，导入网络、导入节点属性，更改点的形状、颜色，在点上插入图片、绘制饼图、柱状图、加入颜色条纹，点的手动对齐、横向分布等。 网络文件和节点属性文件都是正常矩阵格式，若有中文需使用UTF-8编码；若非EXCEL文件，不能有xls后缀。 https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&amp;v=20161117&amp;vid=p0541x250n9&amp;auto=0 4.0.2 miRNA-mRNA调控网络 Cytoscape可用于绘制基因共表达网络，这儿选取miRNA-gene调控网络 (含miRNA-gene表达相关性数据)做为例子，涉及到根据表达变化倍数对每个点进行着色、根据表达相关性对线进行着色、miRNA和靶基因采用不同的形状表示、微调获得合适的展示图形、结果导出PDF格式、导出图例等。 https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&amp;v=20161117&amp;vid=z0541oby69q&amp;auto=0 4.0.3 不同的布局的调试和修改 网络绘制根据网络图的大小、展示的用意可以选择合适的布局。Cytoscape提供了多种布局算法，具体见http://manual.cytoscape.org/en/stable/Navigation_and_Layout.html。 下面列出几种示例 4.0.3.1 Attribute Circle Layout 属性环展示方式所有的节点都在环上，适用于点比较少的时候。环上点的顺序可以根据某一列来调整。 4.0.3.2 Group Attributes Layout 先按某一列的值对点进行分组，每个分组的点成为一个独立的环。在区分上下调基因时，可以按这个来分类，看不同类的基因的调控关系。 4.0.3.3 Prefuse Force Directed Layout 通常也可以获得比较好的结果，相连的点邻接，其它点较远。同时可以根据某一列设置边的强度作为连线的长度。 4.0.3.4 Compound Spring Embedder Layout 复杂网络适用这个，尤其是连线特别多时。 4.0.3.5 Edge-weighted Spring-Embedded Layout 所有的边视为连接2个节点的弹簧。每一个弹簧有一个松弛状态下的期望长度 (resting length)和压缩强度。算法会迭代所有的弹簧，并进行仿真模拟获得每个弹簧的最佳长度。是比较常用的一种，其获得结果也是一个环，但对空间的利用比下面两种要好。 4.0.3.6 yFiles Organic Layout 也是一种Spring-embeded的算法，可以展示网络图的聚类结构。 https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&amp;v=20161117&amp;vid=w05410fbsys&amp;auto=0 4.1 参考 Cytoscape的基本使用 早期录制的Cytoscape视频教程, 含安装和基本使用 http://blog.genesino.com/2012/04/cytoscape-basic-usage/ http://manual.cytoscape.org/en/stable/Navigation_and_Layout.html https://www.slideshare.net/keiono/introduction-to-biological-network-analysis-and-visualization-with-cytoscape-part1 新出炉的Cytoscape视频教程 "],["AI.html", "5 图形排版 5.1 参考", " 5 图形排版 点击查看系列AI组图排版短视频 成果发表是科研过程中不可缺的一部分，发表成果又少不了图形展示。文章图表排版是否整齐规范、协调一致、重点突出对一篇文章的发表也是有不少贡献的。此外做科研的人都爱看脸，文章中的图表是重要的颜面之一。生信宝典系列文章中，R作图也是受到最多欢迎的一部分。 读文献时，看到文章中的图，就一直好奇是怎么拼出来的，尤其是怎么保证图形中字体的大小一致的。如果是统一用R画图，也许可以实现这一点，设置一样的字体、一样的长宽，这样只要图形缩放比例一致，字体理论上也一致。或者使用cowplot, gridExtra, ggpubr等工具也可以组合多个图倒一起 (像前面的示例)。但不同的图有不同的边缘设置，实际操作起来，却也不总是顺利。高手们，比如推出生信宝典傻瓜系列的海哥擅用PPT进行修改排版，我学了下，没学会。后来查阅资料，发现有这么一款工具很强大，Adobe Illustrator简称AI，翻译成汉语就是人工智能。 著名的Adobe公司出品，应该都不陌生。试用后（买不起，也只能用试用版；如果有钱，还是推荐购买正版，维护原作者的权益），发现果然很强大。 5.0.1 矢量图和标量图 矢量图是使用直线和曲线来描述图形, 这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等, 它们都是通过数学公式计算获得的。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。常见的矢量图有PDF, SVG, EPS等格式。如果图形中有文字, 并且文字可以复制, 则可初步判断为矢量图。 矢量图的任何一个地方都可以挑出来修改，某个边框不好看，删掉；线条的粗细不统一，设置成一样的；某条线的颜色想重点突出下，单独修改 (这部分最好还是在画图时就修改好，会更协调，当然AI也没问题)；图中有了多余的元素，删掉；添加文字、设置成统一字体、统一大小更没问题；画个简单的模式图，没问题；不同的子图拼在一起，没问题；自此，再也不愁文章的拼图了。 与矢量图相对应的就是标量图了, 常见的png, jpg, gif格式等, 是由像素点构成, 放大到一定程度会出现马赛克效果。图中的文字不可复制, 元素不可拆分。 5.0.2 矢量图的制作 常规图： Excel, 生成的图可以直接拷贝到AI里面修改 R, Perl, Python等程序语言输出pdf, eps格式的图 (详见公众号中R作图系列) 常用工具的出图 二代测序出图 UCSC – PDF; IGV – SVG; epigenomegateway - SVG; 在高通量数据可视化文章中也有介绍 Motif Weblogo - eps 作图软件 Graphpad 5.0.3 矢量图编辑工具 主要有 Gimp, Adobe illustrator, Inkscape, image magik, photoshop, latex。适用之后, 从稳定性还是易用性来讲, Adobe illustrator是最好的一款。但是是收费软件, 在线会有一些试用版, 供测试时用。 5.0.4 作图基本原则 图形中文字的字体保持统一, 一般使用Helevetica或Arial 符号一般使用Symbol字体, 常见符号有 ′, β等 Panel的字号(A,B,C,D)一般比其余的文字大一号, 上下左右对齐 文字特别密集的地方字体可适当缩小, 原则是看着协调 图和图之间的距离在空间允许的情况下尽可能的大 一篇文稿所有柱状图理论上柱子的宽度保持一致 柱状图的Error bar宽度一致 坐标轴上的刻度尺宽度, 长度一致 坐标轴的宽度、颜色一致 胶图的泳道对齐 5.0.5 作图中的要点注意 标准化, 便于位置调整 从最开始作图, 到文章投稿、修改、定稿, 中间会不断调整, 子图会根据文章需要不断删减, 调整位置。因此标准化之后, 就可以很简单的互换位置就可以了 每个子图的长宽尽量一致 每个相似子图内部元素的特征一致, 比如柱子的宽度 (6 mm), 柱子之间的距离, 坐标轴的刻度的宽度 (0.7 mm), 误差线的宽度 (1 mm), P-value连接线宽度 (6 mm), 胶图泳道的宽度等 合理利用对齐工具, 左右对齐、横向分布、纵向分布等, 即保证对齐效果, 又免去人为调整的繁琐 在选择单个元素时尽量使用直接选择工具 作图要做到自己满意, 自己对自己负责；当你觉得一个地方不合适需要调整时, 一定要及时修改；如果怕麻烦现在没调整, 过几天别人发现或自己觉得不舒服也还是会再调整的。所有要做好充足的准备和充足的工作 保留备份, 保留备份, 保留备份.每次大的修改都要保留原始版本, 因为不知道明天是否还会改回来 5.0.6 Adobe Illustrator中的基本概念和操作描述 编组：性质相似或者需要同时修改的部分可以编为一组，方便处理。双击一组内容，就可以进入编组内部，对编组的每个元素修改；并且编组外的元素处于屏蔽状态，操作起来不会受到干扰。 剪切蒙版：如果想剪切掉图中的某一部分，可以绘制一个矩形、圆形或任意不规则形状覆盖住需要保留的部分，然后同时选中这两个元素（绘制的形状框在被剪切的图之上），按右键，选择剪切蒙版，就可以完成剪切操作。而在修改图时，也可以不断的释放剪切蒙版，方便对不同图层的操作。 直接选择工具：可以无视编组和剪切蒙版，对选中并且只是选中的部分进行操作。这在删除多余的内容和边框时会经常用到。 魔棒工具： 选择类似属性的组分，统一操作。 吸管工具：给一个组分赋予另一个组分的属性。 对齐工具：用于组分的对齐和分布，在设置坐标轴的标记文字时很有用，省去了一个个手动对齐的操作。只要对齐两端，按一下按钮中间的内容就自动与刻度线对齐了。 其它的就靠大家不断的尝试、体验、操作了。多选、多点、多查，慢慢就都熟练了。 另外翻阅到之前准备文章期间做的图形排版教程。当时每天都在不断的调整图和排版, 心得体会比现在更多些, 也录制了视频, 但是无声版, 录制完之后为EXE格式。如果您已观看过文章用图的修改和排版视频教程, 也自己操作过, 有了一定基础, 还想进一步的了解, 可以看看这份无声版的记录是否能有些帮助。 5.0.7 视频教程 (更多视频在B站：https://space.bilibili.com/362709786) 第一个视频以绘制的线图为例，展示如果修改、调整矢量图的每个部分。ggplot2出品的矢量图整体逻辑比较清晰，一层层的叠加，修改起来也比较方便，没有太多难点；关键是熟悉用到的按钮的使用方式和快捷键的操作。 https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&amp;v=20161117&amp;vid=m0548j1ufql&amp;auto=0 第二个视频以UCSC绘制的测序峰图为例，展示如何对稍微复杂一些的图进行修改、删除多余内容。 https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&amp;v=20161117&amp;vid=z0548i168ie&amp;auto=0 第三个视频是剪切蒙版的使用和针对其它不同类型图的特殊操作。 https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&amp;v=20161117&amp;vid=e0548h4prm2&amp;auto=0 5.0.8 动图教程 左边是修改前的, 右边是成品或近成品截图。 AI编辑线图.exe 2. AI_柱状图.exe AI_UCSC.exe AI_设计.exe 图形导出 可以导出为PDF、TIFF格式；最好用PhotoShop导出, 分辨率高, 文件小。 视频文件统一下载地址：链接: https://pan.baidu.com/s/1dFcWadV 密码: (b4mw) 5.1 参考 教师节献礼 - 文章用图的修改和排版 简单强大的在线绘图 文章用图的修改和排版(二) 论文图表基本规范 "],["batch.html", "6 高通量数据中批次效应的鉴定和处理 6.1 什么是批次效应？ 6.2 批次效应会有什么影响？ 6.3 怎么确认数据有无受到批次效应影响 6.4 怎么避免批次效应呢？ 6.5 如何在差异基因鉴定过程中移除批次效应 6.6 检查有无缺失的包并安装，加载所有包 6.7 不考虑批次因素直接进行差异基因分析 6.8 考虑已知的批次因素进行差异基因分析 6.9 批次效应未知时如何判断和在差异基因鉴定过程中移除批次效应 6.10 直接校正表达矩阵", " 6 高通量数据中批次效应的鉴定和处理 6.1 什么是批次效应？ 批次效应表示样品在不同的批次处理和测量时引入的与生物状态不相关的系统性的技术偏差。很多因素都可能导致批次效应的产生，如不同实验条件、不同操作者、不同公司的试剂、不同批的试剂、实验开展的时间、检测设备、不同的测序批次等。 6.2 批次效应会有什么影响？ 2014年生信领域的大牛Michael P Snyder在PNAS上发表了一篇文章Comparison of the transcriptional landscapes between human and mouse tissues，比较了人和小鼠不同组织和器官中表达谱的异同。研究发现不同物种之间组织特异表达的基因是一致的，但很多基因在同一物种不同组织的表达相似度大于它们在不同物种同一组织的表达相似度。“我”来引申下 （原文并没有这么直接说），大体可以理解为小鼠的脑与小鼠的肾脏的相似性大于小鼠的脑与人的脑的相似性。“我”得出的这个结论是有一些颠覆认知的，如果这样，用小鼠做为模式动物是否会对人的研究给出相似性的推导？ 这篇PNAS文章发出后，芝加哥大学的Yoav Gilad在F1000上发表了一篇文章A reanalysis of mouse ENCODE comparative gene expression data来讨论这个不同于以往认知的研究项目的设计和分析的合理性。 首先作者从FASTQ数据的序列名字的ID中提取出对应测序数据来源的测序仪设备ID和测序通道信息，发现所有数据来源于5个批次，如下图所示，只有最后一个批次同时包含了人和小鼠的器官，其它批次都只包含了人的器官或小鼠的器官。 重现者Yoav Gilad等通过对数据进行重分析，重现了类似于原文中的结果。不论是PCA还是Heatmap的结果，都展示出来源于同一物种的组织或器官倾向于聚类到一起。 重现者Yoav Gilad等采用ComBat移除批次带来的影响，再次绘制PCA和Heatmap，结果显示表达谱按组织类型而非物种聚在了一起。 大家有兴趣可以在https://f1000research.com/articles/4-121看看Yoav Gilad的具体操作和PNAS一作Yoav Gilad等人的讨论，通过学习双方在这段公案中辩论的出发点和落脚点，相信对数据分析也会有更多认识，这个我们后续也会涉及。 6.3 怎么确认数据有无受到批次效应影响 通过样品的层级聚类热图+样品属性信息的注释来展示样品聚类结果有无受批次效应的影响。如下面右图中可见WT_1样品在聚类分支上与其它样品处于不同的分支，而从列注释图可以看到WT_1的seqPlatform和batch信息与其它样品不同，这是给我们的一个提示可能存在批次效应影响。 通常我们在整合多套数据集进行展示时也会加上数据来源信息以展示自己的分析结果未受批次等因素影响。如下图每一列是一个样品，每一行是一个菌群；列注释中有一行为Dataset指示样品来源于 2 个数据集，并且聚类结果没有明显受到数据集来源的影响（四个大的聚类分支中样品来源分布没有明显偏好性）； 通过主成分分析PCA查看有无批次效应的影响。如下左图，样品在PC1和PC2组成的空间中按数据集而非样本类型聚在一起，表示数据来源对样本检测结果的影响超出了样本类型的影响，提示存在批次效应。如右图，批次效应移除后，在PC1轴上样品基本按正常-癌旁-肿瘤分布，表示当前样品差异的主要影响因素是样本类型。这时可以绘制样品在更多PC轴上的分布，如PC1-PC3、PC1-PC4等构成的空间中样品差异的主要因素是什么，也可以进一步判断批次效应移除的程度怎样。 通过样本整体表达分布查看有无批次影响。不同来源的样本一般是各自进行标准化（尤其是芯片数据），合并在一起后，可以简单的从整体表达分布来查看是否存在明显的偏移。如下左图存在明显的偏移，则提示有批次效应的存在。校正后，如右图，看上去样本的整体表达分布均一了。但是否批次影响就被移除了，却很难据此下结论。 通过部分基因集的表达变化查看有无批次效应影响。不同来源的数据一起标准化之后，如果标准化效果好的话，样品整体表达分布也会是均一的（如下面左数第二幅图）。但从中随机抽取数百基因却发现其表达收到了批次的影响（如下面左数第三幅图，只展示了数个基因），而且聚类结果也把两组正常样品分到了各自来源相对应的分支上。 6.4 怎么避免批次效应呢？ 合理的实验设计和一致的实验操作是避免批次效应的最好方式。如下图所示如何通过合理的设计来避免检测批次带来的影响。 如左上角图示，若样本量数目不多，可在同一台设备（同一个芯片、同一个测序仪、同一个测序 lane）检测这是最好的方式，不存在检测批次。 如右上角图示，是最差的实验设计方式，不同组的样本分批检测。这种方式无法确定最终检测出的样品差异是生物差异还是设备差异还是二者共同带来的差异。这种检测方式会放大样品的差异，引入较多假阳性结果。如果只是看这种图，相信大家其实都不会这么设计。但换个角度来看，我们 5 月份采一批样去测序，10 月份采一批样去测序，在比较 5 月份样品与 10 月份样品差异时，我们实际的实验设计方式跟这个实验设计也没什么不同。或者做病例对照时，健康人样品好收集，一起测序；疾病样品一起搜集一起测序，也是类似的设计方式。前文所述的一段公案也类似这个设计。 如左下角所示，平衡设计则是最好的实验设计方式。假如实验中存在三个样品组，如对照组、基因敲除组、基因过表达组，每组 9 个重复，则每次检测时都同时包含每组的 3 个重复，这样获得的数据则可以放在一起校正后分析。或者至少对照组的样本在每次测序中都能有 2-3 个重复，最后在数据校正时通过调平对照组数据的检测结果来校正其它样品的检测结果。在前文的留言中，也确实有意识比较好的老师，做了类似设计，值得学习。 如右下角所示，也是芯片检测基因表达的一个常规方式，每个芯片检测一个样本。不论是生物重复还是不同生物条件之间都会受到检测芯片的影响，不同重复之间的批次影响可以评估，但不同条件下的批次影响则难以评估。芯片这么检测是可以的，但测序时每个测序批次会包含很多不同类型的样品，且测序检测影响因素更多，这一设计会引入较大技术偏差。 上面也只是从检测方式的角度设计出一个合理的试验模式降低批次效应的影响，但除了检测方式，还会有很多不可控的因素也会影响到批次，如不同操作人、不同操作时间等客观因素，还有如配对设计实验中不同的个体自身也是批次的因素。 所以需要有个方式去检测和尽量降低批次效应带来的数据偏差的影响。 6.5 如何在差异基因鉴定过程中移除批次效应 在我们之前的文章DESeq2差异基因分析和批次效应移除中也提到了用如下方式构建设计矩阵，以便在差异基因分析过程中移除批次效应的影响。 ddsFullCountTable &lt;- DESeqDataSetFromMatrix(countData = data, colData = sample, design= ~ batch + conditions) dds &lt;- DESeq(ddsFullCountTable) 下面我们以一个具体例子实战（配对样品处理前后基因表达的变化）和检验下效果。为了演示批次效应的影响，大部分代码做了封装，我们只关心核心的地方。如果自己对封装的代码感兴趣，可以自行查看函数源码。 6.6 检查有无缺失的包并安装，加载所有包 site = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN&quot; if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;, repos = site) options(BioC_mirror=&quot;https://mirrors.tuna.tsinghua.edu.cn/bioconductor&quot;) installed_packages = data.frame(installed.packages()) a = rownames(installed_packages) # 安装指定版本的ggbeeswarm if (!&quot;ggbeeswarm&quot; %in% a){ install.packages(&quot;https://cran.r-project.org/src/contrib/Archive/ggbeeswarm/ggbeeswarm_0.6.0.tar.gz&quot;, repos = NULL, type = &quot;source&quot;) } else { if (installed_packages[&quot;ggbeeswarm&quot;,&quot;Version&quot;] != &quot;0.6.0&quot;) { install.packages(&quot;https://cran.r-project.org/src/contrib/Archive/ggbeeswarm/ggbeeswarm_0.6.0.tar.gz&quot;, repos = NULL, type = &quot;source&quot;) } } install_bioc &lt;- c(&quot;tidyverse&quot;, &quot;DESeq2&quot;, &quot;RColorBrewer&quot;, &quot;ggplot2&quot;, &quot;org.Hs.eg.db&quot;, &quot;reshape2&quot;, &quot;stringr&quot;, &quot;beeswarm&quot;, &quot;vipor&quot;, &quot;gplots&quot;,&quot;tidyr&quot;,&quot;amap&quot;,&quot;BiocParallel&quot;,&quot;sva&quot;, &quot;ggfortify&quot;,&quot;patchwork&quot;, &quot;ggrepel&quot;, &quot;VennDiagram&quot;,&quot;grid&quot;, &quot;limma&quot;, &quot;devtools&quot;,&quot;rmarkdown&quot;,&quot;dplyr&quot;,&quot;conflicted&quot;) for (i in install_bioc) { if (!i %in% a){ BiocManager::install(i, update = F, site_repository=site) a = rownames(installed.packages()) } } if (!&quot;ImageGP&quot; %in% a){ # devtools::install_github(&quot;Tong-Chen/ImageGP&quot;) devtools::install_git(&quot;https://gitee.com/ct5869/ImageGP.git&quot;) } # 若缺少ImageGP包，则安装 # BiocManager::install(&quot;Tong-Chen/ImageGP&quot;, update=F) suppressMessages(library(DESeq2)) suppressMessages(library(&quot;RColorBrewer&quot;)) suppressMessages(library(&quot;gplots&quot;)) suppressMessages(library(&quot;amap&quot;)) suppressMessages(library(&quot;ggplot2&quot;)) suppressMessages(library(&quot;BiocParallel&quot;)) suppressMessages(library(&quot;ImageGP&quot;)) suppressMessages(library(sva)) suppressMessages(library(ggfortify)) suppressMessages(library(patchwork)) # https://cran.r-project.org/src/contrib/Archive/ggbeeswarm/ggbeeswarm_0.6.0.tar.gz suppressMessages(library(ggbeeswarm)) suppressMessages(library(ggrepel)) suppressMessages(library(VennDiagram)) suppressMessages(library(grid)) suppressMessages(library(limma)) suppressMessages(library(dplyr)) suppressMessages(library(conflicted)) conflict_prefer(&quot;select&quot;, &quot;dplyr&quot;) ## [conflicted] Will prefer ## dplyr::select over any other package. 输入文件1： reads count矩阵 (Count_matrix.txt)，格式如下： ENSG untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 trt_N61311 trt_N052611 trt_N080611 trt_N061011 ENSG00000223972 1 0 0 0 0 1 0 0 ENSG00000227232 13 25 23 24 12 12 22 22 ENSG00000278267 0 5 3 4 2 4 3 1 输入文件2： 实验设计信息表 (metadata): conditions为处理条件（untrt是对照, trt是加药处理 ），individual标记样品的个体来源 (4个个体：N61311、N052611、N080611、N061011)。 Samp conditions individual untrt_N61311 untrt N61311 untrt_N052611 untrt N052611 untrt_N080611 untrt N080611 untrt_N061011 untrt N061011 trt_N61311 trt N61311 trt_N052611 trt N052611 trt_N080611 trt N080611 trt_N061011 trt N061011 6.7 不考虑批次因素直接进行差异基因分析 初始化，定义输入、输出和参数 # Prefix for all output file dir.create(&quot;result/batch&quot;, recursive = T) output_prefix = &quot;result/batch/STAR.simpler&quot; # pipelineStar.sh或其它方式生成的reads count 文件，行为基因，列为样品 file = &quot;Count_matrix.xls&quot; # 分组信息表 metadata = &quot;metadata.txt&quot; # 分组信息所在列名字 covariate = NULL # covariate = &quot;batch&quot; design=&quot;conditions&quot; # 输入数据类型，salmon结果或reads count 矩阵 type=&quot;readscount&quot; # 差异基因参数 padj=0.05 log2FC=1 数据读入和标准化 dds &lt;- readscount2deseq(file, metadata, design=design, covariate = covariate) ## [1] &quot;Read in 32799 genes&quot; ## [1] &quot;23936 genes remained after filtering of genes with all counts less than 4 in all samples.&quot; ## [1] &quot;Perform DESeq on given datasets.&quot; ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing normexpr &lt;- deseq2normalizedExpr(dds, output_prefix=output_prefix, rlog=F, vst=T, design=design) ## [1] &quot;Output normalized counts&quot; ## [1] &quot;Output vst transformed normalized counts&quot; 检查数据标准化效果: 标准化后基因在不同样品的表达分布越均一越好。从下图看不出存在批次效应的影响。 # normalizedExpr2DistribBoxplot(normexpr, # saveplot=paste(output_prefix, &quot;DESeq2.normalizedExprDistrib.pdf&quot;, sep=&quot;.&quot;)) normalizedExpr2DistribBoxplot(normexpr) 样本聚类查看样品相似性，trt组和untrt组区分明显 (聚类采用的不同基因数目、聚类参数都可能影响聚类结果) # clusterSampleHeatmap2(normexpr$vst, # cor_file=paste(output_prefix, &quot;DESeq2.sampleCorrelation.txt&quot;, sep=&quot;.&quot;), # saveplot=paste(output_prefix, &quot;DESeq2.sampleCorrelation.pdf&quot;, sep=&quot;.&quot;)) # 根据前5000个表达变化幅度最大的基因进行聚类分析 clusterSampleHeatmap2(normexpr$vst[1:5000,], cor_file=paste(output_prefix, &quot;DESeq2.sampleCorrelation.txt&quot;, sep=&quot;.&quot;)) ## [1] &quot;Performing sample clustering&quot; clusterSampleUpperTriPlot(normexpr$vst[1:500,], cor_file=paste(output_prefix, &quot;DESeq2.sampleCorrelation.txt&quot;, sep=&quot;.&quot;)) ## [1] &quot;Performing sample clustering&quot; 主成分分析PCA查看样品相似性，发现在PC1轴上，样品按处理条件区分开；在PC2轴上，样品按个体区分开，不同的个体是影响样品基因表达差异的一个重要因素。 metadata = as.data.frame(colData(dds)) sp_pca(normexpr$vst[1:2000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) 先鉴定出差异基因，获得差异基因文件STAR.simpler.DESeq2.all.DE.txt和其它可视化图表（暂时忽略）。 multipleGroupDEgenes(dds, design=design, output_prefix=output_prefix, padj=padj, log2FC=log2FC, normalized_counts=normexpr) ## [1] &quot;DE genes between untrt trt&quot; ## [1] &quot;conditions&quot; &quot;untrt&quot; &quot;trt&quot; ## Saving 17.8 x 12.7 cm image 6.8 考虑已知的批次因素进行差异基因分析 初始化，定义输入、输出和参数 （注意covariate变量使用individual列作为了批次信息） # Prefix for all output file dir.create(&quot;result/batch&quot;) output_prefix = &quot;result/batch/STAR.simpler.batch&quot; # pipelineStar.sh生成的reads count 文件，行为基因，列为样品 file = &quot;Count_matrix.xls&quot; # 分组信息表 metadata = &quot;metadata.txt&quot; # 分组信息所在列名字 # covariate = NULL # ********* covariate = &quot;individual&quot; design=&quot;conditions&quot; # 输入数据类型，salmon结果或reads count 矩阵 type=&quot;readscount&quot; # 差异基因参数 padj=0.05 log2FC=1 数据读入和标准化，并检查数据标准化效果: 标准化后基因在不同样品的表达分布越均一越好 （此图略过，与上面的表达分布图一致）。 dds &lt;- readscount2deseq(file, metadata, design=design, covariate = covariate) ## [1] &quot;Read in 32799 genes&quot; ## [1] &quot;23936 genes remained after filtering of genes with all counts less than 4 in all samples.&quot; ## [1] &quot;Perform DESeq on given datasets.&quot; ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing normexpr &lt;- deseq2normalizedExpr(dds, output_prefix=output_prefix, rlog=F, vst=T, design=design) ## [1] &quot;Output normalized counts&quot; ## [1] &quot;Output vst transformed normalized counts&quot; normalizedExpr2DistribBoxplot(normexpr) 样本聚类查看样品相似性，trt组和untrt组区分明显 (此部分结果略过，与上面的聚类结果一致) # clusterSampleHeatmap2(normexpr$vst, # cor_file=paste(output_prefix, &quot;DESeq2.sampleCorrelation.txt&quot;, sep=&quot;.&quot;), # saveplot=paste(output_prefix, &quot;DESeq2.sampleCorrelation.pdf&quot;, sep=&quot;.&quot;)) # 根据前5000个表达变化幅度最大的基因进行聚类分析 clusterSampleHeatmap2(normexpr$vst[1:5000,], cor_file=paste(output_prefix, &quot;DESeq2.sampleCorrelation.txt&quot;, sep=&quot;.&quot;)) ## [1] &quot;Performing sample clustering&quot; clusterSampleUpperTriPlot(normexpr$vst[1:5000,], cor_file=paste(output_prefix, &quot;DESeq2.sampleCorrelation.txt&quot;, sep=&quot;.&quot;)) ## [1] &quot;Performing sample clustering&quot; 主成分分析PCA查看样品相似性，发现在PC1轴上，样品按处理条件区分开；在PC2轴上，样品按个体区分开，表明不同的个体可能会对后续的差异基因分析造成影响。这个结果也与我们前面不考虑批次因素的结果是一样的。 metadata = as.data.frame(colData(dds)) sp_pca(normexpr$vst[1:5000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) 是不是批次变量加错了呢，还是添加的批次变量未生效？可以说都不是，操作没问题，只是DESeq2处理时只在差异分析模型中考虑批次效应信息，而不会直接校正表达矩阵。那我们先看下加了批次后差异分析的结果怎样，后续我们再讲如何校正表达矩阵。 鉴定出差异基因，获得差异基因文件STAR.simpler.batch.DESeq2.all.DE.txt和其它可视化图表（暂时忽略）。 multipleGroupDEgenes(dds, design=design, output_prefix=output_prefix, padj=padj, log2FC=log2FC, normalized_counts=normexpr) ## [1] &quot;DE genes between untrt trt&quot; ## [1] &quot;conditions&quot; &quot;untrt&quot; &quot;trt&quot; ## Saving 17.8 x 12.7 cm image 6.8.1 比较批次校正前后差异基因变化 校正后，差异基因数目变多了，上调多了99个，下调多了61个。不过数目变化，也说明不了太多问题。 de_before_batch = sp_readTable(&quot;result/batch/STAR.simpler.DESeq2.all.DE.txt&quot;, header=F) de_before_batch$V2 = paste(&quot;Before_batch&quot;,de_before_batch$V2,sep=&quot;_&quot;) table(de_before_batch$V2) ## ## Before_batch_untrt._higherThan_.trt Before_batch_untrt._lowerThan_.trt ## 398 466 de_after_batch = sp_readTable(&quot;result/batch/STAR.simpler.batch.DESeq2.all.DE.txt&quot;, header=F) de_after_batch$V2 = paste(&quot;After_known_batch&quot;,de_after_batch$V2,sep=&quot;_&quot;) table(de_after_batch$V2) ## ## After_known_batch_untrt._higherThan_.trt ## 497 ## After_known_batch_untrt._lowerThan_.trt ## 527 画个Venn图，看下哪些基因是新增的差异基因，哪些基因批次校正后没差异了。 all_de = rbind(de_before_batch, de_after_batch) # 随机查看6行，信息代表更全面 all_de[sample(1:nrow(all_de),6),] ## V1 V2 ## 1877 ENSG00000272744 After_known_batch_untrt._lowerThan_.trt ## 777 ENSG00000197594 Before_batch_untrt._lowerThan_.trt ## 701 ENSG00000162998 Before_batch_untrt._lowerThan_.trt ## 1779 ENSG00000074660 After_known_batch_untrt._lowerThan_.trt ## 1061 ENSG00000137331 After_known_batch_untrt._higherThan_.trt ## 484 ENSG00000185813 Before_batch_untrt._lowerThan_.trt # 结果存储到文件中 sp_writeTable(all_de, file=&quot;result/batch/Compare_de_gene_beofore_and_after_batch.txt&quot;, keep_rownames = F, col.names = F) sp_vennDiagram(all_de, label1=&quot;Before_batch_untrt._higherThan_.trt&quot;, label2=&quot;After_known_batch_untrt._higherThan_.trt&quot;) 采用在线工具https://www.bic.ac.cn/Evenn/#/ 来做，准备在线工具所需的文件，一个两列格式的文件：第一列为基因名，第二列为基因的上下调状态。拷贝文件数据到网站数据输入处： 从Venn图可以看出，批次校正后既有新增的差异基因，又丢失了之前的一部分差异基因，那么哪个方式更合理呢？ 选择1个批次校正后检测为上调的基因和1个批次校正后检测为下调的基因，观察下其表达模式。从下图可以看出，这些基因具有明显的个体表达一致性。ENSG00000163394基因在每个个体来源的样本中处理后表达都上调了近4倍，但是其本底表达在不同个体中却差异较大。如其在N080611个体（蓝色线）中表达整体偏低，药物处理后表达虽然有上调但表达值却低于其在N061011个体（绿色线）处理前的表达。从这两个例子可以看出，考虑到每个个体的基准表达水平不同，最终获得的差异倍数会有较高的方差。批次校正后解决了样品个体来源基因本底表达差异的影响，获得的差异基因倍数方差会变小，所以检测出更多差异基因，理论上也是更可靠的方式。（这个在之前文章典型医学设计实验GEO数据分析 (step-by-step) - Limma差异分析、火山图、功能富集也有阐述。） ENSG00000163394 = data.frame(Expr=normexpr$vst[&quot;ENSG00000163394&quot;,]) sp_writeTable(ENSG00000163394, file=&quot;result/ENSG00000163394.txt&quot;) p1 &lt;- sp_boxplot(ENSG00000163394, melted=T, metadata=metadata, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, xvariable_order = c(&quot;untrt&quot;,&quot;trt&quot;), manual_color_vector = &quot;Set2&quot;) ## [1] 1273 ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; ENSG00000221866 = data.frame(Expr=normexpr$vst[&quot;ENSG00000221866&quot;,]) p2 &lt;- sp_boxplot(ENSG00000221866, melted=T, metadata=metadata, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, xvariable_order = c(&quot;untrt&quot;,&quot;trt&quot;), manual_color_vector = &quot;Set2&quot;) ## [1] 1273 ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; p1 + p2 + plot_layout(guide = &#39;collect&#39;) 我们再选2个批次校正前鉴定为有差异、批次校正后鉴定为无差异的基因观察下其表达模式。这两个基因的表达模式没看出存在个体本底的一致变化差异。处理前后在不同个体中变化幅度不一，可能是被动变化。但这些基因一定是没有差异吗？我个人也下不出结论，后续得结合其功能再做判断了。 ENSG00000109689 = data.frame(Expr=normexpr$vst[&quot;ENSG00000109689&quot;,]) p1 &lt;- sp_boxplot(ENSG00000109689, melted=T, metadata=metadata, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, xvariable_order = c(&quot;untrt&quot;,&quot;trt&quot;), manual_color_vector = &quot;Set2&quot;, title=&quot;ENSG00000109689&quot;) ## [1] 1273 ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; ENSG00000137124 = data.frame(Expr=normexpr$vst[&quot;ENSG00000137124&quot;,]) p2 &lt;- sp_boxplot(ENSG00000137124, melted=T, metadata=metadata, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, xvariable_order = c(&quot;untrt&quot;,&quot;trt&quot;), manual_color_vector = &quot;Set2&quot;, title=&quot;ENSG00000137124&quot;) ## [1] 1273 ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; p1 + p2 + plot_layout(guide = &#39;collect&#39;) DESeq2，edgeR和limma在考虑批次因素鉴定差异基因时基本操作是一致的，上面我们也完成和比较了已知批次的数据的差异基因鉴定。 后续还有2个问题： DESeq2不校正表达矩阵自身的值，如果需要用到批次校正后的表达矩阵怎么做？ 如果不知道数据是否来源于同一个个体或是否有其他批次因素的影响，怎么处理？ 6.9 批次效应未知时如何判断和在差异基因鉴定过程中移除批次效应 前面文章讲述了批次信息已知时，在差异基因分析中考虑批次效应的影响可以移除部分基因在个体中不同本底表达水平差异的影响，获得的差异基因倍数方差会变小，可以检测出更多差异基因，理论上也是更可靠的方式。那么如果批次信息未知或记录不完善时怎么处理呢？ 这里我们就用到了另一个 R 包sva帮助从数据中预测可能存在的混杂因素包括但不限于批次效应的影响。下面我们实际看下这个包鉴定出的混杂因素与批次效应变量之间是否存在关联？利用预测出的混杂因素作为批次信息校正后结果会有什么变化？ 6.9.1 预测混杂因素(cofounding factors)并在差异基因分析中移除这些因素 初始化，定义输入、输出和参数 # Prefix for all output file output_prefix = &quot;result/batch/STAR.simpler.sva_batch&quot; # pipelineStar.sh或其它方式生成的reads count 文件，行为基因，列为样品 file = &quot;Count_matrix.xls&quot; # 分组信息表 metadata = &quot;metadata.txt&quot; # 分组信息所在列名字 covariate = NULL # covariate = &quot;batch&quot; design=&quot;conditions&quot; # 输入数据类型，salmon结果或reads count 矩阵 type=&quot;readscount&quot; # 差异基因参数 padj=0.05 log2FC=1 数据读入和标准化 dds &lt;- readscount2deseq(file, metadata, design=design, covariate = covariate) ## [1] &quot;Read in 32799 genes&quot; ## [1] &quot;23936 genes remained after filtering of genes with all counts less than 4 in all samples.&quot; ## [1] &quot;Perform DESeq on given datasets.&quot; ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing normexpr &lt;- deseq2normalizedExpr(dds, output_prefix=output_prefix, rlog=F, vst=T, design=design) ## [1] &quot;Output normalized counts&quot; ## [1] &quot;Output vst transformed normalized counts&quot; 6.9.2 预测可能存在的混杂因素 下面的方式也可以 (svaseq 是在 sva 的基础上对数据做了一个 log 转换；如果处理的是芯片数据，通常已经做过 log 换，直接使用 sva 即可)。 # 获取标准化后的表达矩阵 dat &lt;- normexpr$vst # 根据关键生物表型构建设计矩阵 mod &lt;- model.matrix(as.formula(paste0(&quot;~ &quot;, design)), colData(dds)) # 构建对照设计矩阵 mod0 &lt;- model.matrix(~ 1, colData(dds)) # 指定混杂因素的数目为 2，也可以让 sva 自己预测 svseq2 &lt;- sva(dat, mod, mod0) ## Number of significant surrogate variables is: 3 ## Iteration (out of 5 ):1 2 3 4 5 svs &lt;- svseq2$sv colnames(svs) &lt;- paste0(&quot;SV&quot;,1:ncol(svs)) svs ## SV1 SV2 SV3 ## [1,] -0.158515434 -0.4622145 0.32822946 ## [2,] -0.013810298 -0.1806797 -0.55487160 ## [3,] -0.381566045 0.4357423 0.08352428 ## [4,] 0.567268826 0.1737819 0.16589595 ## [5,] -0.181616074 -0.4695836 0.38642058 ## [6,] 0.004300293 -0.1796549 -0.61360292 ## [7,] -0.398059133 0.4960287 0.06242022 ## [8,] 0.561997865 0.1865798 0.14198402 添加预测出的Surrogate variable属性到dds对象 colData(dds) &lt;- cbind(colData(dds), svs) design(dds) &lt;- as.formula(paste(&quot;~&quot;, paste(colnames(svs), collapse = &quot;+&quot;), &quot;+&quot;, design)) # 基于预测出的混杂因素再次进行分析 dds &lt;- DESeq(dds) ## using pre-existing size factors ## estimating dispersions ## found already estimated dispersions, replacing these ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing 6.9.3 可视化展示预测出的Surrogate variable属性与已知的批次信息的关系 plot_data &lt;- as.data.frame(colData(dds)) plot_data$Sample &lt;- rownames(plot_data) head(plot_data) ## conditions individual sizeFactor SV1 SV2 ## untrt_N61311 untrt N61311 1.0211325 -0.158515434 -0.4622145 ## untrt_N052611 untrt N052611 1.1803986 -0.013810298 -0.1806797 ## untrt_N080611 untrt N080611 1.1796083 -0.381566045 0.4357423 ## untrt_N061011 untrt N061011 0.9232642 0.567268826 0.1737819 ## trt_N61311 trt N61311 0.8939275 -0.181616074 -0.4695836 ## trt_N052611 trt N052611 0.6709229 0.004300293 -0.1796549 ## SV3 Sample ## untrt_N61311 0.32822946 untrt_N61311 ## untrt_N052611 -0.55487160 untrt_N052611 ## untrt_N080611 0.08352428 untrt_N080611 ## untrt_N061011 0.16589595 untrt_N061011 ## trt_N61311 0.38642058 trt_N61311 ## trt_N052611 -0.61360292 trt_N052611 sp_writeTable(plot_data, file=&quot;result/batch/metadata2.txt&quot;) 从下图可以看出，预测出的混杂因素SV1, SV2与样品来源的个体信息 (individual)还是比较一致的。 p1 &lt;- ggplot(plot_data, aes(x=SV1, y=SV2, color=conditions, shape=individual)) + geom_point() + geom_text_repel(aes(label=Sample), show.legend = F) p2 &lt;- ggplot(plot_data, aes(x=SV1, y=SV3, color=conditions, shape=individual)) + geom_point() + geom_text_repel(aes(label=Sample), show.legend = F) p1+p2 6.9.4 基于预测出的混杂因素再次进行差异分析 获得差异基因文件STAR.simpler.sva_batch.DESeq2.all.DE.txt和其它可视化图表（暂时忽略）。 multipleGroupDEgenes(dds, design=design, output_prefix=output_prefix, padj=padj, log2FC=log2FC, normalized_counts=normexpr) ## [1] &quot;DE genes between untrt trt&quot; ## [1] &quot;conditions&quot; &quot;untrt&quot; &quot;trt&quot; ## Saving 17.8 x 12.7 cm image 6.9.5 比较批次校正前、已知批次校正后和预测的批次校正后差异基因变化 根据已知批次信息校正后差异基因数目变多了，上调了99个，下调多了61个。根据预测的混杂因素校正后，上调多了96个，下调多了55个。从数目上看，根据已知批次和预测的混杂因素获得的差异基因是基本已知的。 de_before_batch = sp_readTable(&quot;result/batch/STAR.simpler.DESeq2.all.DE.txt&quot;, header=F) de_before_batch$V2 = paste(&quot;Before_batch&quot;,de_before_batch$V2,sep=&quot;_&quot;) table(de_before_batch$V2) ## ## Before_batch_untrt._higherThan_.trt Before_batch_untrt._lowerThan_.trt ## 398 466 de_after_known_batch = sp_readTable(&quot;result/batch/STAR.simpler.batch.DESeq2.all.DE.txt&quot;, header=F) de_after_known_batch$V2 = paste(&quot;After_known_batch&quot;,de_after_known_batch$V2,sep=&quot;_&quot;) table(de_after_known_batch$V2) ## ## After_known_batch_untrt._higherThan_.trt ## 497 ## After_known_batch_untrt._lowerThan_.trt ## 527 de_after_sva_batch = sp_readTable(&quot;result/batch/STAR.simpler.sva_batch.DESeq2.all.DE.txt&quot;, header=F) de_after_sva_batch$V2 = paste(&quot;After_sva_batch&quot;,de_after_sva_batch$V2,sep=&quot;_&quot;) table(de_after_sva_batch$V2) ## ## After_sva_batch_untrt._higherThan_.trt After_sva_batch_untrt._lowerThan_.trt ## 500 516 画个Venn图，看下哪些基因是新增的差异基因，哪些基因批次校正后没差异了。 all_de = rbind(de_before_batch, de_after_known_batch, de_after_sva_batch) # 随机查看6行，信息代表更全面 all_de[sample(1:nrow(all_de),6),] ## V1 V2 ## 1255 ENSG00000278029 After_known_batch_untrt._higherThan_.trt ## 50 ENSG00000012048 Before_batch_untrt._higherThan_.trt ## 2330 ENSG00000055813 After_sva_batch_untrt._higherThan_.trt ## 1276 ENSG00000181350 After_known_batch_untrt._higherThan_.trt ## 330 ENSG00000187634 Before_batch_untrt._higherThan_.trt ## 222 ENSG00000126785 Before_batch_untrt._higherThan_.trt # 结果存储到文件中 sp_writeTable(all_de, file=&quot;result/batch/Compare_de_gene_beofore_and_after_known_sva_batch.txt&quot;, keep_rownames = F, col.names = F) 一个方式是采用代码，直接出图 suppressMessages(library(VennDiagram)) suppressMessages(library(grid)) sp_vennDiagram(all_de, label3=&quot;Before_batch_untrt._higherThan_.trt&quot;, label1=&quot;After_known_batch_untrt._higherThan_.trt&quot;, label2=&quot;After_sva_batch_untrt._higherThan_.trt&quot;) 这里还是采用在线工具https://www.bic.ac.cn/EVenn/#/ 来做，能直接获得每个子集的基因，准备在线工具所需的文件，一个两列格式的文件：第一列为基因名，第二列为基因的上下调状态。 拷贝文件数据到网站数据输入处 （操作就不演示了看上一篇文章）： 从untrt上调基因Venn图可以看出，校正已知批次信息后既有新增的untrt上调差异基因，又丢失了之前的一部分untrt上调差异基因；校正预测的混杂因素后，大部分新增差异基因都与已知批次信息校正后的结果一致，但新增untrt上调差异基因少。 从untrt下调基因Venn图可以看出，校正预测的混杂因素后，新增39个差异基因；批次校正前鉴定为存在差异的40个基因在校正后被认为是非差异显著基因。 下面还是从这些基因的表达模式上看是否可以找到一些线索？ 下图比对绘出了7种不同类型untrt上调的差异基因中随机选取1个绘制的表达模式比较图。 untrt_up_genes &lt;- &quot;Name;Type ENSG00000159674;SVA_batch_specific ENSG00000220563;SVA_batch_uncorrect_common ENSG00000109689;Uncorrect_specific ENSG00000162407;Known_batch_uncorrect_common ENSG00000184254;Known_batch_specific ENSG00000163394;Known_batch_SVA_batch_common ENSG00000178695;All_common&quot; untrt_up_genes &lt;- read.table(text=untrt_up_genes, sep=&quot;;&quot;, header=T, row.names=NULL) untrt_up_genes_expr &lt;- merge(untrt_up_genes, normexpr$vst, by.x=&quot;Name&quot;, by.y=0, all.x=T) untrt_up_genes_expr_long &lt;- reshape2::melt(untrt_up_genes_expr, id_vars=c(&quot;Name&quot;,&quot;Type&quot;), variable.name=&quot;Sample&quot;, value.name = &quot;Expr&quot;) ## Using Name, Type as id variables head(untrt_up_genes_expr_long) ## Name Type Sample Expr ## 1 ENSG00000109689 Uncorrect_specific untrt_N61311 10.591770 ## 2 ENSG00000159674 SVA_batch_specific untrt_N61311 13.704637 ## 3 ENSG00000162407 Known_batch_uncorrect_common untrt_N61311 14.753902 ## 4 ENSG00000163394 Known_batch_SVA_batch_common untrt_N61311 9.829457 ## 5 ENSG00000178695 All_common untrt_N61311 12.205745 ## 6 ENSG00000184254 Known_batch_specific untrt_N61311 9.598665 # metadata$Sample = rownames(metadata) ImageGP:::sp_writeTable(untrt_up_genes_expr_long, file=&quot;1&quot;, keep_rownames =F) sp_boxplot(untrt_up_genes_expr_long, melted=T, metadata=plot_data, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, facet_variable = &quot;Type&quot;, facet_scales=&quot;free_y&quot;, legend.position = c(0.7,0.15), x_label=&quot;&quot;,manual_color_vector = &quot;Set2&quot;) + theme(legend.direction = &quot;horizontal&quot;) ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; All_common代表了差异倍数特别大的基因，不论是否校正都可以检测出差异；不同类型批次信息校正后被检测视为差异的基因都有表达的本底差异；Uncorrect_specific的基因本底表达无固定模式。 下图比对绘出了7种不同类型untrt下调的差异基因表达分布，基本结论与上图类似。 untrt_down_genes &lt;- &quot;Name;Type ENSG00000188257;SVA_batch_specific ENSG00000117479;SVA_batch_uncorrect_common ENSG00000137124;Uncorrect_specific ENSG00000254109;Known_batch_uncorrect_common ENSG00000113578;Known_batch_specific ENSG00000221866;Known_batch_SVA_batch_common ENSG00000152583;All_common&quot; untrt_down_genes &lt;- read.table(text=untrt_down_genes, sep=&quot;;&quot;, header=T, row.names=NULL) untrt_down_genes_expr &lt;- merge(untrt_down_genes, normexpr$vst, by.x=&quot;Name&quot;, by.y=0, all.x=T) untrt_down_genes_expr_long &lt;- reshape2::melt(untrt_down_genes_expr, id_vars=c(&quot;Name&quot;,&quot;Type&quot;), variable.name=&quot;Sample&quot;, value.name = &quot;Expr&quot;) ## Using Name, Type as id variables head(untrt_down_genes_expr_long) ## Name Type Sample Expr ## 1 ENSG00000113578 Known_batch_specific untrt_N61311 6.964600 ## 2 ENSG00000117479 SVA_batch_uncorrect_common untrt_N61311 7.927545 ## 3 ENSG00000137124 Uncorrect_specific untrt_N61311 8.895369 ## 4 ENSG00000152583 All_common untrt_N61311 7.026723 ## 5 ENSG00000188257 SVA_batch_specific untrt_N61311 6.857589 ## 6 ENSG00000221866 Known_batch_SVA_batch_common untrt_N61311 7.795699 metadata$Sample = rownames(metadata) sp_boxplot(untrt_down_genes_expr_long, melted=T, metadata=plot_data, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, facet_variable = &quot;Type&quot;, facet_scales=&quot;free_y&quot;, legend.position = c(0.7,0.15), x_label=&quot;&quot;,manual_color_vector = &quot;Set2&quot;) + theme(legend.direction = &quot;horizontal&quot;) ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; 额外的一个信息是SVA_batch_speific中红色和绿色个体本底表达区分不明显。这可能是基于SVA预测的混杂因素与已知的批次因素校正后结果有差异的一个原因 (这两个个体的SV值很接近)。 另外一个导致SVA预测的批次与已知的批次效应校正后结果不同的原因也可能是我们只让SVA预测了2个混杂因素。留下2个去探索的问题，欢迎留言或投稿讨论： 如果不设置只返回两个混杂因素，实际SVA会判断出存在3个混杂因素，全部混杂因素都考虑进去结果会有什么变化呢？ 上面是取了单个基因查看其表达模式，还可以进一步比较不同子集的基因表达水平、差异倍数、FDR、差异倍数方差的整体分布，分析受影响的主要是哪些类型的基因？ 6.10 直接校正表达矩阵 处理批次因素最好的方式还是如前面所述将其整合到差异基因鉴定模型中，降低批次因素带来的模型残差的自由度。但一些下游分析，比如数据可视化，也需要直接移除效应影响的数据来展示，这时可以使用ComBat或removeBatchEffect函数来处理。 输入数据，标准化且log转换后的数据 STAR.simpler.DESeq2.normalized.vst.txt id untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 trt_N61311 trt_N052611 trt_N080611 trt_N061011 ENSG00000115414 18.02 18.62 17.83 18.45 17.95 18.54 18.15 18.50 ENSG00000011465 17.79 18.36 17.96 18.52 17.79 18.23 17.84 18.47 ENSG00000091986 17.15 17.74 16.41 17.59 17.27 17.79 16.88 17.76 ENSG00000103888 15.56 16.90 15.88 16.42 15.94 17.43 17.38 17.05 包含已知批次信息和预测的批次信息的样本属性文件 metadata2 Samp conditions individual sizeFactor SV1 SV2 SV3 untrt_N61311 untrt N61311 1.0211325 -0.10060313 -0.4943517 -0.31643389 untrt_N052611 untrt N052611 1.1803986 0.01827734 -0.1701068 0.58841464 untrt_N080611 untrt N080611 1.1796083 -0.42949195 0.3756338 -0.08929556 untrt_N061011 untrt N061011 0.9232642 0.53452392 0.2413738 -0.17649091 trt_N61311 trt N61311 0.8939275 -0.12535603 -0.4956603 -0.36550102 trt_N052611 trt N052611 0.6709229 0.03588273 -0.151201 0.5914179 trt_N080611 trt N080611 1.3967665 -0.46668403 0.4413431 -0.07016903 trt_N061011 trt N061011 0.9462307 0.53345114 0.2529692 -0.16194213 6.10.1 读入标准化后的表达矩阵和样品信息表 expr_File &lt;- &quot;result/batch/STAR.simpler.DESeq2.normalized.vst.txt&quot; expr_mat &lt;- sp_readTable(expr_File, row.names=1) head(expr_mat) ## untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 ## ENSG00000096060 8.377527 8.647174 9.193881 7.929484 ## ENSG00000109906 5.835168 5.852500 5.601434 6.188280 ## ENSG00000211445 9.931563 11.412991 10.507340 10.939324 ## ENSG00000112936 8.351378 8.341983 9.781321 8.241310 ## ENSG00000152583 7.026723 7.284537 7.285092 7.309670 ## ENSG00000101347 10.705358 10.857668 10.479317 10.892392 ## trt_N61311 trt_N052611 trt_N080611 trt_N061011 ## ENSG00000096060 12.353764 12.508120 11.965273 12.10153 ## ENSG00000109906 9.797577 9.461018 8.932876 10.26135 ## ENSG00000211445 14.101096 15.127159 13.509829 14.68201 ## ENSG00000112936 12.421820 10.489734 12.339928 11.14178 ## ENSG00000152583 11.194267 10.831855 10.498043 11.18172 ## ENSG00000101347 14.221389 14.836149 13.630472 15.04158 metadata &lt;- &quot;result/batch/metadata2.txt&quot; metadata &lt;- sp_readTable(metadata, row.names=1) head(metadata) ## conditions individual sizeFactor SV1 SV2 ## untrt_N61311 untrt N61311 1.0211325 -0.158515434 -0.4622145 ## untrt_N052611 untrt N052611 1.1803986 -0.013810298 -0.1806797 ## untrt_N080611 untrt N080611 1.1796083 -0.381566045 0.4357423 ## untrt_N061011 untrt N061011 0.9232642 0.567268826 0.1737819 ## trt_N61311 trt N61311 0.8939275 -0.181616074 -0.4695836 ## trt_N052611 trt N052611 0.6709229 0.004300293 -0.1796549 ## SV3 Sample ## untrt_N61311 0.32822946 untrt_N61311 ## untrt_N052611 -0.55487160 untrt_N052611 ## untrt_N080611 0.08352428 untrt_N080611 ## untrt_N061011 0.16589595 untrt_N061011 ## trt_N61311 0.38642058 trt_N61311 ## trt_N052611 -0.61360292 trt_N052611 6.10.2 使用ComBat校正 ComBat校正时考虑生物分组信息 biological_group = &quot;conditions&quot; batch = &quot;individual&quot; metadata[[biological_group]] &lt;- factor(metadata[[biological_group]]) metadata[[batch]] &lt;- factor(metadata[[batch]]) # 模型中引入关注的生物变量和其它非批次变量，保留生物差异和非批次差异 modcombat = model.matrix(as.formula(paste(&#39;~&#39;, biological_group, sep=&quot; &quot;)), data= metadata) # ComBat需要的是matrix expr_mat_batch_correct &lt;- ComBat(dat=as.matrix(expr_mat), batch=metadata[[batch]], mod=modcombat) ## Found 2538 genes with uniform expression within a single batch (all zeros); these will not be adjusted for batch. ## Found4batches ## Adjusting for1covariate(s) or covariate level(s) ## Standardizing Data across genes ## Fitting L/S model and finding priors ## Finding parametric adjustments ## Adjusting the Data expr_mat_batch_correct &lt;- as.data.frame(expr_mat_batch_correct) expr_mat_batch_correct[1:3,1:4] ## untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 ## ENSG00000096060 8.417951 8.481407 8.847812 8.318834 ## ENSG00000109906 5.784193 5.918108 5.987956 5.773905 ## ENSG00000211445 10.478496 10.723636 10.890187 10.676246 6.10.2.1 校正后的PCA PCA结果显示在PC1轴代表的差异变大了，PC2轴代表的差异变小了，不同来源的样本在PC2轴的分布没有规律了 (或者说成镜像分布了)。 sp_pca(expr_mat_batch_correct[1:5000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) ComBat校正时不考虑分组信息，也可以获得一个合理的结果，但是一部分组间差异被抹去了。 # ComBat需要的是matrix expr_mat_batch_correct2 &lt;- ComBat(dat=as.matrix(expr_mat), batch=metadata[[batch]], mod=NULL) ## Found 2538 genes with uniform expression within a single batch (all zeros); these will not be adjusted for batch. ## Found4batches ## Adjusting for0covariate(s) or covariate level(s) ## Standardizing Data across genes ## Fitting L/S model and finding priors ## Finding parametric adjustments ## Adjusting the Data expr_mat_batch_correct2 &lt;- as.data.frame(expr_mat_batch_correct2) sp_pca(expr_mat_batch_correct2[1:5000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) 关于运行ComBat时是否应该添加关注的生物分组信息，即mod变量，存在一些争议。反对添加mod的人的担心是这么处理后，是否会强化生物分组之间的差异。支持添加mod的人是担心如果不添加mod那么去除批次时可能也会去除样本组之间的差异，尤其是实验设计不合理时。 如果是非平衡实验，类似我们在实验设计部分时提到的方案2，则没有办法添加mod变量，程序会报出Design matrix is not full rank类似的错误，这时是不能区分差异是来源于批次还是来源于样本，强行移除批次时，也会移除一部分或者全部样本分组带来的差异。这个在第一篇帖子处有两位朋友的留言讨论可以参考。 ComBat只能处理批次信息为l离散型分组变量的数据，不能处理sva预测出的连续性混杂因素。 6.10.3 使用limma校正 如果批次信息有多个或者不是分组变量而是类似SVA预测出的数值混杂因素，则需使用limma的removeBatchEffect (这里使用的是SVA预测出的全部3个混杂因素进行的校正。)。 样品在PC1和PC2组成的空间的分布与ComBat结果类似，只是PC1能解释的差异略小一些。 SV = metadata[,c(&quot;SV1&quot;,&quot;SV2&quot;,&quot;SV3&quot;)] expr_mat_batch_correct_limma1 &lt;- removeBatchEffect(expr_mat, covariates = SV, design=modcombat) sp_pca(expr_mat_batch_correct_limma1[1:5000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) removeBatchEffect运行时也可以不提供生物分组信息。 expr_mat_batch_correct_limma1 &lt;- removeBatchEffect(expr_mat, covariates = SV) sp_pca(expr_mat_batch_correct_limma1[1:5000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) removeBatchEffect也可以跟ComBat一样，对给定的已知一个或多个定性批次信息进行校正。 expr_mat_batch_correct_limma2 &lt;- removeBatchEffect(expr_mat, batch=metadata[[batch]], design=modcombat) sp_pca(expr_mat_batch_correct_limma2[1:5000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) 不指定目标分组变量，结果也不受影响。 expr_mat_batch_correct_limma2 &lt;- removeBatchEffect(expr_mat, batch=metadata[[batch]]) sp_pca(expr_mat_batch_correct_limma2[1:5000,], metadata, color_variable=&quot;conditions&quot;, shape_variable = &quot;individual&quot;) + aes(size=1) + guides(size = &quot;none&quot;) 6.10.4 查看校正完后基因的表达情况 untrt_down_genes &lt;- &quot;Name;Type ENSG00000144649;SVA_batch_specific ENSG00000187134;SVA_batch_uncorrect_common ENSG00000137124;Uncorrect_specific ENSG00000151690;Known_batch_uncorrect_common ENSG00000180914;Known_batch_specific ENSG00000221866;Known_batch_SVA_batch_common ENSG00000152583;All_common&quot; untrt_down_genes &lt;- read.table(text=untrt_down_genes, sep=&quot;;&quot;, header=T, row.names=NULL) untrt_down_genes_expr &lt;- merge(untrt_down_genes, expr_mat_batch_correct, by.x=&quot;Name&quot;, by.y=0, all.x=T) untrt_down_genes_expr_long &lt;- reshape2::melt(untrt_down_genes_expr, id_vars=c(&quot;Name&quot;,&quot;Type&quot;), variable.name=&quot;Sample&quot;, value.name = &quot;Expr&quot;) ## Using Name, Type as id variables head(untrt_down_genes_expr_long) ## Name Type Sample Expr ## 1 ENSG00000137124 Uncorrect_specific untrt_N61311 9.005546 ## 2 ENSG00000144649 SVA_batch_specific untrt_N61311 7.067120 ## 3 ENSG00000151690 Known_batch_uncorrect_common untrt_N61311 9.464342 ## 4 ENSG00000152583 All_common untrt_N61311 7.057427 ## 5 ENSG00000180914 Known_batch_specific untrt_N61311 8.081169 ## 6 ENSG00000187134 SVA_batch_uncorrect_common untrt_N61311 12.356100 #metadata$Sample = rownames(metadata) sp_boxplot(untrt_down_genes_expr_long, melted=T, metadata=plot_data, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, facet_variable = &quot;Type&quot;, facet_scales=&quot;free_y&quot;, legend.position = c(0.7,0.1), x_label=&quot;&quot;,manual_color_vector = &quot;Set2&quot;) + theme(legend.direction = &quot;horizontal&quot;) ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; untrt_down_genes &lt;- &quot;Name;Type ENSG00000144649;SVA_batch_specific ENSG00000187134;SVA_batch_uncorrect_common ENSG00000137124;Uncorrect_specific ENSG00000151690;Known_batch_uncorrect_common ENSG00000180914;Known_batch_specific ENSG00000221866;Known_batch_SVA_batch_common ENSG00000152583;All_common&quot; untrt_down_genes &lt;- read.table(text=untrt_down_genes, sep=&quot;;&quot;, header=T, row.names=NULL) untrt_down_genes_expr &lt;- merge(untrt_down_genes, expr_mat_batch_correct_limma1, by.x=&quot;Name&quot;, by.y=0, all.x=T) untrt_down_genes_expr_long &lt;- reshape2::melt(untrt_down_genes_expr, id_vars=c(&quot;Name&quot;,&quot;Type&quot;), variable.name=&quot;Sample&quot;, value.name = &quot;Expr&quot;) ## Using Name, Type as id variables head(untrt_down_genes_expr_long) ## Name Type Sample Expr ## 1 ENSG00000137124 Uncorrect_specific untrt_N61311 9.021158 ## 2 ENSG00000144649 SVA_batch_specific untrt_N61311 6.991157 ## 3 ENSG00000151690 Known_batch_uncorrect_common untrt_N61311 9.527425 ## 4 ENSG00000152583 All_common untrt_N61311 7.054087 ## 5 ENSG00000180914 Known_batch_specific untrt_N61311 8.214962 ## 6 ENSG00000187134 SVA_batch_uncorrect_common untrt_N61311 12.282890 # metadata$Sample = rownames(metadata) sp_boxplot(untrt_down_genes_expr_long, melted=T, metadata=plot_data, xvariable = &quot;conditions&quot;, yvariable = &quot;Expr&quot;, jitter_bp = T, group_variable_for_line = &quot;individual&quot;, facet_variable = &quot;Type&quot;, facet_scales=&quot;free_y&quot;, legend.position = c(0.7,0.1), x_label=&quot;&quot;,manual_color_vector = &quot;Set2&quot;) + theme(legend.direction = &quot;horizontal&quot;) ## [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; "],["questions06.html", "7 问题答疑 7.1 ggplot2绘图如何根据一个变量即区分颜色又区分深浅？ 7.2 ggplot2绘图点的形状不够用怎么办？", " 7 问题答疑 7.1 ggplot2绘图如何根据一个变量即区分颜色又区分深浅？ 群里有这么一个问题： 请问用ggplot2绘制气泡图的时候，根据数字的正负设置红蓝两种颜色，根据数字的大小可以设置颜色的深浅吗？如何实现？可以用哪个函数，谢谢大家 先构造一个正弦曲线数据集，数值有正有负。 x &lt;- seq(0,2*pi,0.05) y &lt;- sin(x) data &lt;- data.frame(X=x,y=y) library(ggplot2) ggplot(data, aes(x=x, y=y)) + geom_point() 怎么来设置颜色呢？color=y&gt;0: 根据正负设置颜色（0这里归类为负）；alpha=abs(y)根据数值绝对值设置透明度，模拟颜色饱和度。 ggplot(data, aes(x=x, y=y)) + geom_point(aes(color=y&gt;0, alpha=abs(y))) + scale_color_manual(values=c(&quot;blue&quot;,&quot;red&quot;)) 先构造一个数据集(这里用泊松分布数据集做个演示)，绘制个散点图： ggplot(data, aes(x=x, y=y)) + geom_point(aes(color=y&gt;0.05, alpha=y)) 7.2 ggplot2绘图点的形状不够用怎么办？ 群里有这么一个问题： 请问老师，fviz_pca_ind 做pca，当设置geom.ind = “point”，group&gt;6时，就不能显示第7，8组的点，应该如何处理（在不设置为文本的情况下），只改变点的几何形状和颜色 fviz_pca_ind是factoextra里面用来可视化PCA结果的一个参数，具体见PCA主成分分析实战和可视化 | 附R代码和测试数据。 这个问题是ggplot2绘制形状时的通用问题，默认只支持6种形状。我们生成个测试数据看下效果： x &lt;- 1:50 y &lt;- dpois(x, lambda = 10) data &lt;- data.frame(X=x,y=y) data$type &lt;- as.factor(x) library(ggplot2) ggplot(data, aes(x=x, y=y)) + geom_point(aes(shape=type)) 图效果如下。同时给出了一段提示： Warning: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 50. Consider specifying shapes manually if you must have them. Warning: Removed 44 rows containing missing values (geom_point). 就是说我们需要自己手动指定形状。 ggplot2默认支持下面122种形状。 # 代码来自 http://sape.inf.usi.ch/quick-reference/ggplot2/shape d=data.frame(p=c(0:25,32:127)) ggplot() + scale_y_continuous(name=&quot;&quot;) + scale_x_continuous(name=&quot;&quot;) + scale_shape_identity() + geom_point(data=d, mapping=aes(x=p%%16, y=p%/%16, shape=p), size=5, fill=&quot;red&quot;) + geom_text(data=d, mapping=aes(x=p%%16, y=p%/%16+0.25, label=p), size=3) 那怎么利用起来呢？需要转换计算下能用的符号编号，这里选取0:14, 33-127 (15-25是其它形状加了颜色或变了大小，可能会对设置的大小或颜色属性有影响，先暂时忽略了; 32没看出来是什么形状)。 下面根据设定的符号列的因子数，通过取余数的方式获取这些数字，然后传递给scale_shape_manual函数。 shape_level &lt;- nlevels(data[[&quot;type&quot;]]) if (shape_level &lt; 15){ shapes = (0:shape_level) %% 15 } else{ shapes = c(0:14,c((15:shape_level) %% 110 + 18)) } ggplot(data, aes(x=x, y=y)) + geom_point(aes(shape=type)) + scale_shape_manual(values=shapes) 回到上面的问题，因为没有给代码和数据，这里也就只能意思一下了。 # type 需要改成自己映射到形状的列名 shape_level &lt;- length(levels(data[[&quot;type&quot;]])) if (shape_level &lt; 15){ shapes = (0:shape_level) %% 15 } else{ shapes = c(0:14,c((15:shape_level) %% 110 + 18)) } fviz_pca_ind(....) + scale_shape_manual(values=shapes) "],["推荐一个-r-中很好用的条件判断语句.html", "8 推荐一个 R 中很好用的条件判断语句 8.1 ifelse 标记差异基因 8.2 dplyr::case-when 标记差异基因 8.3 dplyr::if_else 会更快一点 8.4 case-when只保留差异基因的名字 8.5 case-when每隔 1 个基因保留 1 个 8.6 dplyr::if_else速度最快！", " 8 推荐一个 R 中很好用的条件判断语句 text &lt;- &quot;Gene log2FoldChange padj a 1 0.1 b 2 0.05 d 3 0.001 e -2 0.0002 G 0 0.0001&quot; res_output &lt;- read.table(text=text, row.names=NULL, header=T) padj_thresh = 0.05 log2FC = 1 groupA = &#39;trt&#39; groupB = &#39;untrt&#39; 8.1 ifelse 标记差异基因 不想安装额外的包，可以用 ifelse，要稍微复杂一点。 res_output$level &lt;- ifelse(res_output$padj&lt;=padj_thresh, ifelse(res_output$log2FoldChange&gt;=log2FC, paste(groupA,&quot;UP&quot;), ifelse(res_output$log2FoldChange&lt;=(-1)*(log2FC), paste(groupB,&quot;UP&quot;), &quot;NoDiff&quot;)) , &quot;NoDiff&quot;) 或 res_output$level &lt;- ifelse(res_output$padj&lt;=padj_thresh &amp; res_output$log2FoldChange&gt;=log2FC, paste(groupA,&quot;UP&quot;), ifelse(res_output$padj&lt;=padj_thresh &amp; res_output$log2FoldChange&lt;=(-1)*(log2FC), paste(groupB,&quot;UP&quot;), &quot;NoDiff&quot;)) 8.2 dplyr::case-when 标记差异基因 比之前简洁了一些，可读性强 library(dplyr) res_output %&gt;% dplyr::mutate(level = case_when( (padj&lt;=padj_thresh) &amp; (log2FoldChange&gt;=log2FC) ~ paste(groupA,&quot;UP&quot;), (padj&lt;=padj_thresh) &amp; (log2FoldChange&lt;=(-1)*log2FC) ~ paste(groupB, &quot;UP&quot;), TRUE ~ &quot;NoDiff&quot; )) ## Gene log2FoldChange padj level ## 1 a 1 1e-01 NoDiff ## 2 b 2 5e-02 trt UP ## 3 d 3 1e-03 trt UP ## 4 e -2 2e-04 untrt UP ## 5 G 0 1e-04 NoDiff 8.3 dplyr::if_else 会更快一点 速度快一点，但可读性弱了一些。 res_output %&gt;% dplyr::mutate(level = if_else(res_output$padj&lt;=padj_thresh &amp; res_output$log2FoldChange&gt;=log2FC, paste(groupA,&quot;UP&quot;), if_else(res_output$padj&lt;=padj_thresh &amp; res_output$log2FoldChange&lt;=(-1)*(log2FC), paste(groupB,&quot;UP&quot;), &quot;NoDiff&quot;))) ## Gene log2FoldChange padj level ## 1 a 1 1e-01 NoDiff ## 2 b 2 5e-02 trt UP ## 3 d 3 1e-03 trt UP ## 4 e -2 2e-04 untrt UP ## 5 G 0 1e-04 NoDiff 8.4 case-when只保留差异基因的名字 library(dplyr) res_output %&gt;% dplyr::mutate(diff_gene = case_when( (padj&lt;=padj_thresh) &amp; (log2FoldChange&gt;=log2FC) ~ Gene, (padj&lt;=padj_thresh) &amp; (log2FoldChange&lt;=(-1)*log2FC) ~ Gene, TRUE ~ &quot;&quot; )) ## Gene log2FoldChange padj level diff_gene ## 1 a 1 1e-01 NoDiff ## 2 b 2 5e-02 trt UP b ## 3 d 3 1e-03 trt UP d ## 4 e -2 2e-04 untrt UP e ## 5 G 0 1e-04 NoDiff 8.5 case-when每隔 1 个基因保留 1 个 临时生成列时操作起来更方便了 library(dplyr) res_output %&gt;% dplyr::mutate(rank=1:n(), keep_gene = case_when( rank %% 2 == 1 ~ Gene, TRUE ~ &quot;&quot; )) ## Gene log2FoldChange padj level rank keep_gene ## 1 a 1 1e-01 NoDiff 1 a ## 2 b 2 5e-02 trt UP 2 ## 3 d 3 1e-03 trt UP 3 d ## 4 e -2 2e-04 untrt UP 4 ## 5 G 0 1e-04 NoDiff 5 G 8.6 dplyr::if_else速度最快！ dplyr::if_else速度最快！ suppressPackageStartupMessages(library(tidyverse)) microbenchmark::microbenchmark( case_when(1:1000 &lt; 100 ~ &quot;low&quot;, TRUE ~ &quot;high&quot;), if_else(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;), ifelse(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;) ) #&gt; Unit: microseconds #&gt; expr min lq mean #&gt; case_when(1:1000 &lt; 100 ~ &quot;low&quot;, TRUE ~ &quot;high&quot;) 384.786 418.629 953.4921 #&gt; if_else(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;) 61.943 67.686 128.9811 #&gt; ifelse(1:1000 &lt; 3, &quot;low&quot;, &quot;high&quot;) 256.797 264.796 391.7180 #&gt; median uq max neval #&gt; 631.9420 708.4480 33149.364 100 #&gt; 90.0435 127.9885 2496.182 100 #&gt; 327.9695 460.8810 2354.246 100 Ref: https://community.rstudio.com/t/case-when-why-not/2685/2 如果不想安装额外包，用ifelse；如果是单个条件，用dplyr::if_else；如果多个条件，用dplyr::case_when (更可读)。 "],["visual1.html", "9 易生信-数据可视化 9.1 加载需要的包 9.2 读入数据 9.3 热图绘制 9.4 箱线图和统计比较 9.5 通路内基因的比较 9.6 ggstatsplot绘图和统计分析", " 9 易生信-数据可视化 9.1 加载需要的包 library(dplyr) library(ggpubr) library(tidyr) library(ggplot2) library(pheatmap) library(ggstatsplot) ## You can cite this package as: ## Patil, I. (2021). Visualizations with statistical details: The &#39;ggstatsplot&#39; approach. ## Journal of Open Source Software, 6(61), 3167, doi:10.21105/joss.03167 library(Hmisc) 9.2 读入数据 9.2.1 Duplicate row names expr &lt;- read.table(&quot;analysis.simplier.DESeq2.normalized.symbol.txt&quot;, row.names=1, header=T, sep=&quot;\\t&quot;) 9.2.2 行名唯一化处理 这里使用make.names转换行名为唯一，实际需要先弄清楚为什么会有重复名字。 expr &lt;- read.table(&quot;analysis.simplier.DESeq2.normalized.symbol.txt&quot;, row.names=NULL, header=T, sep=&quot;\\t&quot;) head(expr) ## id untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 trt_N61311 ## 1 FN1 245667.66 427435.1 221687.51 371144.2 240187.24 ## 2 DCN 212953.14 360796.2 258977.30 408573.1 210002.18 ## 3 CEMIP 40996.34 137783.1 53813.92 91066.8 62301.12 ## 4 CCDC80 137229.15 232772.2 86258.13 212237.3 136730.76 ## 5 IGFBP5 77812.65 288609.2 210628.87 168067.4 96021.74 ## 6 COL1A1 146450.41 127367.3 152281.50 140861.1 62358.64 ## trt_N052611 trt_N080611 trt_N061011 ## 1 450103.21 280226.19 376518.23 ## 2 316009.14 225547.39 393843.74 ## 3 223111.85 212724.84 157919.47 ## 4 226070.89 124634.56 236237.81 ## 5 217439.21 162677.38 168387.36 ## 6 53800.47 69160.97 51044.06 有哪些基因名是重复出现的？ expr$id[duplicated(expr$id)] ## [1] &quot;MATR3&quot; &quot;PKD1P1&quot; &quot;HSPA14&quot; &quot;OR7E47P&quot; &quot;POLR2J3&quot; ## [6] &quot;ATXN7&quot; &quot;TMSB15B&quot; &quot;LINC-PINT&quot; &quot;TBCE&quot; &quot;SNX29P2&quot; ## [11] &quot;SCO2&quot; &quot;POLR2J4&quot; &quot;CCDC39&quot; &quot;RGS5&quot; &quot;BMS1P21&quot; ## [16] &quot;RF00017&quot; &quot;GOLGA8M&quot; &quot;RF00017&quot; &quot;DNAJC9-AS1&quot; &quot;CYB561D2&quot; ## [21] &quot;RF00017&quot; &quot;IPO5P1&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [26] &quot;SPATA13&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [31] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [36] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [41] &quot;RF00019&quot; &quot;RF00019&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [46] &quot;RF00019&quot; &quot;BMS1P4&quot; &quot;RF00019&quot; &quot;RF00019&quot; &quot;RF00017&quot; ## [51] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [56] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [61] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00019&quot; &quot;RF00017&quot; ## [66] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00019&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [71] &quot;LINC01238&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [76] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [81] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF02271&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [86] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;LINC01297&quot; &quot;RF00019&quot; ## [91] &quot;RF00017&quot; &quot;RF00012&quot; &quot;RF00019&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [96] &quot;RF00019&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;ZNF503&quot; ## [101] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [106] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF02271&quot; &quot;RF00019&quot; ## [111] &quot;RF00019&quot; &quot;RF00017&quot; &quot;RF00019&quot; &quot;RF02271&quot; &quot;RF00017&quot; ## [116] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00019&quot; &quot;RF00019&quot; ## [121] &quot;RF00017&quot; &quot;RF00019&quot; &quot;ITFG2-AS1&quot; &quot;RF00019&quot; &quot;RF00019&quot; ## [126] &quot;RF00017&quot; &quot;RF00019&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [131] &quot;RF00019&quot; &quot;RF00017&quot; &quot;RF00012&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [136] &quot;RAET1E-AS1&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [141] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00012&quot; ## [146] &quot;RF02271&quot; &quot;RF00019&quot; &quot;LINC01422&quot; &quot;RF02271&quot; &quot;RF00017&quot; ## [151] &quot;RF00019&quot; &quot;RF00019&quot; &quot;RF00019&quot; &quot;RF00019&quot; &quot;RF00017&quot; ## [156] &quot;LINC01481&quot; &quot;RF00017&quot; &quot;SNHG28&quot; &quot;RF00019&quot; &quot;RF00019&quot; ## [161] &quot;RF00019&quot; &quot;RF00019&quot; &quot;LINC00484&quot; &quot;LINC00941&quot; &quot;ALG1L9P&quot; ## [166] &quot;RF00017&quot; &quot;DUXAP8&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; ## [171] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;RMRP&quot; &quot;RF00017&quot; ## [176] &quot;RF00017&quot; &quot;RF00017&quot; &quot;RF00017&quot; &quot;DIABLO&quot; 名字唯一化处理 make.names(c(&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;), unique=T) ## [1] &quot;a&quot; &quot;a.1&quot; &quot;b&quot; &quot;b.1&quot; &quot;b.2&quot; expr_names &lt;- make.names(expr$id, unique = T) rownames(expr) &lt;- expr_names expr &lt;- expr[,-1] head(expr) ## untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 trt_N61311 ## FN1 245667.66 427435.1 221687.51 371144.2 240187.24 ## DCN 212953.14 360796.2 258977.30 408573.1 210002.18 ## CEMIP 40996.34 137783.1 53813.92 91066.8 62301.12 ## CCDC80 137229.15 232772.2 86258.13 212237.3 136730.76 ## IGFBP5 77812.65 288609.2 210628.87 168067.4 96021.74 ## COL1A1 146450.41 127367.3 152281.50 140861.1 62358.64 ## trt_N052611 trt_N080611 trt_N061011 ## FN1 450103.21 280226.19 376518.23 ## DCN 316009.14 225547.39 393843.74 ## CEMIP 223111.85 212724.84 157919.47 ## CCDC80 226070.89 124634.56 236237.81 ## IGFBP5 217439.21 162677.38 168387.36 ## COL1A1 53800.47 69160.97 51044.06 9.3 热图绘制 library(pheatmap) top6 &lt;- head(expr) pheatmap(top6) ### 提取差异基因绘制热图 {#visual6} 读入差异基因列表 de_gene &lt;- read.table(&quot;analysis.DESeq2.all.DE.symbol&quot;, row.names=NULL, header=F, sep=&quot;\\t&quot;) head(de_gene) ## V1 V2 ## 1 ARHGEF2 untrt._higherThan_.trt ## 2 KCTD12 untrt._higherThan_.trt ## 3 SLC6A9 untrt._higherThan_.trt ## 4 GXYLT2 untrt._higherThan_.trt ## 5 RAB7B untrt._higherThan_.trt ## 6 NEK10 untrt._higherThan_.trt 提取Top3 差异的基因 library(dplyr) top6_de_gene &lt;- de_gene %&gt;% group_by(V2) %&gt;% dplyr::slice(1:3) top6 &lt;- expr[which(rownames(expr) %in% top6_de_gene$V1),] head(top6) ## untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 trt_N61311 ## KCTD12 4700.79369 3978.0401 4416.15169 4792.34174 936.69481 ## MAOA 438.54451 452.9934 516.63033 258.73279 4628.00860 ## ARHGEF2 3025.62334 3105.7830 3094.51304 2909.99043 1395.39850 ## SPARCL1 58.15705 102.5827 80.00997 82.59042 2220.50867 ## PER1 170.61639 156.3692 194.97497 123.47689 1728.38117 ## SLC6A9 360.66314 413.8797 365.47650 443.71982 63.90538 ## trt_N052611 trt_N080611 trt_N061011 ## KCTD12 633.4462 979.77576 641.49582 ## MAOA 4429.7201 4629.66529 3778.17351 ## ARHGEF2 1441.9916 1464.59769 1501.51509 ## SPARCL1 1750.9879 1374.90745 2194.58930 ## PER1 1230.2575 1120.00650 1333.91208 ## SLC6A9 56.8962 86.82929 95.33916 metadata &lt;- read.table(&quot;sampleFile&quot;, header=T, row.names=1) pheatmap(top6, annotation_col = metadata) 按行标准化 pheatmap(top6, annotation_col = metadata, scale=&quot;row&quot;, cluster_cols = F) 9.4 箱线图和统计比较 head(top6) ## untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 trt_N61311 ## KCTD12 4700.79369 3978.0401 4416.15169 4792.34174 936.69481 ## MAOA 438.54451 452.9934 516.63033 258.73279 4628.00860 ## ARHGEF2 3025.62334 3105.7830 3094.51304 2909.99043 1395.39850 ## SPARCL1 58.15705 102.5827 80.00997 82.59042 2220.50867 ## PER1 170.61639 156.3692 194.97497 123.47689 1728.38117 ## SLC6A9 360.66314 413.8797 365.47650 443.71982 63.90538 ## trt_N052611 trt_N080611 trt_N061011 ## KCTD12 633.4462 979.77576 641.49582 ## MAOA 4429.7201 4629.66529 3778.17351 ## ARHGEF2 1441.9916 1464.59769 1501.51509 ## SPARCL1 1750.9879 1374.90745 2194.58930 ## PER1 1230.2575 1120.00650 1333.91208 ## SLC6A9 56.8962 86.82929 95.33916 矩阵转置 top6_t &lt;- as.data.frame(t(top6)) top6_t ## KCTD12 MAOA ARHGEF2 SPARCL1 PER1 SLC6A9 ## untrt_N61311 4700.7937 438.5445 3025.623 58.15705 170.6164 360.66314 ## untrt_N052611 3978.0401 452.9934 3105.783 102.58269 156.3692 413.87971 ## untrt_N080611 4416.1517 516.6303 3094.513 80.00997 194.9750 365.47650 ## untrt_N061011 4792.3417 258.7328 2909.990 82.59042 123.4769 443.71982 ## trt_N61311 936.6948 4628.0086 1395.398 2220.50867 1728.3812 63.90538 ## trt_N052611 633.4462 4429.7201 1441.992 1750.98786 1230.2575 56.89620 ## trt_N080611 979.7758 4629.6653 1464.598 1374.90745 1120.0065 86.82929 ## trt_N061011 641.4958 3778.1735 1501.515 2194.58930 1333.9121 95.33916 与样本属性信息合并 top6_t_with_group &lt;- merge(metadata, top6_t,by=0) head(top6_t_with_group) ## Row.names conditions individual KCTD12 MAOA ARHGEF2 SPARCL1 ## 1 trt_N052611 trt N052611 633.4462 4429.7201 1441.992 1750.98786 ## 2 trt_N061011 trt N061011 641.4958 3778.1735 1501.515 2194.58930 ## 3 trt_N080611 trt N080611 979.7758 4629.6653 1464.598 1374.90745 ## 4 trt_N61311 trt N61311 936.6948 4628.0086 1395.398 2220.50867 ## 5 untrt_N052611 untrt N052611 3978.0401 452.9934 3105.783 102.58269 ## 6 untrt_N061011 untrt N061011 4792.3417 258.7328 2909.990 82.59042 ## PER1 SLC6A9 ## 1 1230.2575 56.89620 ## 2 1333.9121 95.33916 ## 3 1120.0065 86.82929 ## 4 1728.3812 63.90538 ## 5 156.3692 413.87971 ## 6 123.4769 443.71982 colnames(top6_t_with_group)[1] = &quot;Sample&quot; head(top6_t_with_group) ## Sample conditions individual KCTD12 MAOA ARHGEF2 SPARCL1 ## 1 trt_N052611 trt N052611 633.4462 4429.7201 1441.992 1750.98786 ## 2 trt_N061011 trt N061011 641.4958 3778.1735 1501.515 2194.58930 ## 3 trt_N080611 trt N080611 979.7758 4629.6653 1464.598 1374.90745 ## 4 trt_N61311 trt N61311 936.6948 4628.0086 1395.398 2220.50867 ## 5 untrt_N052611 untrt N052611 3978.0401 452.9934 3105.783 102.58269 ## 6 untrt_N061011 untrt N061011 4792.3417 258.7328 2909.990 82.59042 ## PER1 SLC6A9 ## 1 1230.2575 56.89620 ## 2 1333.9121 95.33916 ## 3 1120.0065 86.82929 ## 4 1728.3812 63.90538 ## 5 156.3692 413.87971 ## 6 123.4769 443.71982 9.4.1 单基因箱线图 library(ggpubr) ggboxplot(top6_t_with_group, x = &quot;conditions&quot;, y = &quot;KCTD12&quot;, title = &quot;KCTD12&quot;, ylab = &quot;Expression&quot;, color = &quot;conditions&quot;, palette = &quot;jco&quot;) # palette # npg, lancet, 9.4.2 多基因箱线图 (combine) ggboxplot(top6_t_with_group, x = &quot;conditions&quot;, y = c(&quot;KCTD12&quot;,&quot;MAOA&quot;,&quot;PER1&quot;,&quot;SLC6A9&quot;), ylab = &quot;Expression&quot;, combine=T, color = &quot;conditions&quot;, palette = &quot;jco&quot;) 9.4.3 多基因箱线图 (merge) ggboxplot(top6_t_with_group, x = &quot;conditions&quot;, y = c(&quot;KCTD12&quot;,&quot;MAOA&quot;,&quot;PER1&quot;,&quot;SLC6A9&quot;), ylab = &quot;Expression&quot;, merge=&quot;flip&quot;, color = &quot;conditions&quot;, palette = &quot;nature&quot;) ## Ignoring unknown labels: ## • fill : &quot;&quot; ## • linetype : &quot;&quot; ## • shape : &quot;&quot; 9.4.4 数据对数转换后绘制箱线图 top6_t_with_group_log = top6_t_with_group %&gt;% purrr::map_if(is.numeric, log1p) %&gt;% as.data.frame head(top6_t_with_group_log) ## Sample conditions individual KCTD12 MAOA ARHGEF2 SPARCL1 ## 1 trt_N052611 trt N052611 6.452752 8.396317 7.274474 7.468506 ## 2 trt_N061011 trt N061011 6.465360 8.237261 7.314896 7.694206 ## 3 trt_N080611 trt N080611 6.888344 8.440456 7.290018 7.226869 ## 4 trt_N61311 trt N61311 6.843425 8.440098 7.241652 7.705942 ## 5 untrt_N052611 untrt N052611 8.288796 6.118083 8.041343 4.640370 ## 6 untrt_N061011 untrt N061011 8.474983 5.559653 7.976249 4.425929 ## PER1 SLC6A9 ## 1 7.115791 4.058652 ## 2 7.196621 4.567875 ## 3 7.021982 4.475395 ## 4 7.455519 4.172930 ## 5 5.058595 6.027989 ## 6 4.824120 6.097444 ggboxplot(top6_t_with_group_log, x = &quot;conditions&quot;, y = c(&quot;KCTD12&quot;,&quot;MAOA&quot;,&quot;PER1&quot;,&quot;SLC6A9&quot;), ylab = &quot;Expression&quot;, merge=&quot;flip&quot;, fill = &quot;conditions&quot;, palette = &quot;Set3&quot;) ## Ignoring unknown labels: ## • colour : &quot;&quot; ## • linetype : &quot;&quot; ## • shape : &quot;&quot; 9.4.5 用ggplot2实现ggpubr head(top6_t_with_group) ## Sample conditions individual KCTD12 MAOA ARHGEF2 SPARCL1 ## 1 trt_N052611 trt N052611 633.4462 4429.7201 1441.992 1750.98786 ## 2 trt_N061011 trt N061011 641.4958 3778.1735 1501.515 2194.58930 ## 3 trt_N080611 trt N080611 979.7758 4629.6653 1464.598 1374.90745 ## 4 trt_N61311 trt N61311 936.6948 4628.0086 1395.398 2220.50867 ## 5 untrt_N052611 untrt N052611 3978.0401 452.9934 3105.783 102.58269 ## 6 untrt_N061011 untrt N061011 4792.3417 258.7328 2909.990 82.59042 ## PER1 SLC6A9 ## 1 1230.2575 56.89620 ## 2 1333.9121 95.33916 ## 3 1120.0065 86.82929 ## 4 1728.3812 63.90538 ## 5 156.3692 413.87971 ## 6 123.4769 443.71982 top6_t_with_group_melt &lt;- gather(top6_t_with_group, key=&quot;Gene&quot;, value=&quot;Expr&quot;, -conditions, -Sample) top6_t_with_group_melt ## Sample conditions Gene Expr ## 1 trt_N052611 trt individual N052611 ## 2 trt_N061011 trt individual N061011 ## 3 trt_N080611 trt individual N080611 ## 4 trt_N61311 trt individual N61311 ## 5 untrt_N052611 untrt individual N052611 ## 6 untrt_N061011 untrt individual N061011 ## 7 untrt_N080611 untrt individual N080611 ## 8 untrt_N61311 untrt individual N61311 ## 9 trt_N052611 trt KCTD12 633.446156631623 ## 10 trt_N061011 trt KCTD12 641.495823400197 ## 11 trt_N080611 trt KCTD12 979.775760302651 ## 12 trt_N61311 trt KCTD12 936.69481220158 ## 13 untrt_N052611 untrt KCTD12 3978.04010747298 ## 14 untrt_N061011 untrt KCTD12 4792.34174092359 ## 15 untrt_N080611 untrt KCTD12 4416.1516874711 ## 16 untrt_N61311 untrt KCTD12 4700.79369380424 ## 17 trt_N052611 trt MAOA 4429.72011060544 ## 18 trt_N061011 trt MAOA 3778.17351003238 ## 19 trt_N080611 trt MAOA 4629.66529040409 ## 20 trt_N61311 trt MAOA 4628.00860200842 ## 21 untrt_N052611 untrt MAOA 452.993366254371 ## 22 untrt_N061011 untrt MAOA 258.732786794907 ## 23 untrt_N080611 untrt MAOA 516.630329311547 ## 24 untrt_N61311 untrt MAOA 438.544507027083 ## 25 trt_N052611 trt ARHGEF2 1441.99162090614 ## 26 trt_N061011 trt ARHGEF2 1501.51509498614 ## 27 trt_N080611 trt ARHGEF2 1464.59768716888 ## 28 trt_N61311 trt ARHGEF2 1395.39849893799 ## 29 untrt_N052611 untrt ARHGEF2 3105.78298812572 ## 30 untrt_N061011 untrt ARHGEF2 2909.99043109019 ## 31 untrt_N080611 untrt ARHGEF2 3094.51304122032 ## 32 untrt_N61311 untrt ARHGEF2 3025.6233363497 ## 33 trt_N052611 trt SPARCL1 1750.98785915805 ## 34 trt_N061011 trt SPARCL1 2194.58930391866 ## 35 trt_N080611 trt SPARCL1 1374.9074458069 ## 36 trt_N61311 trt SPARCL1 2220.50866953382 ## 37 untrt_N052611 untrt SPARCL1 102.582688954068 ## 38 untrt_N061011 untrt SPARCL1 82.5904194503166 ## 39 untrt_N080611 untrt SPARCL1 80.0099713726754 ## 40 untrt_N61311 untrt SPARCL1 58.1570455959873 ## 41 trt_N052611 trt PER1 1230.25754726245 ## 42 trt_N061011 trt PER1 1333.91208461272 ## 43 trt_N080611 trt PER1 1120.00649866401 ## 44 trt_N61311 trt PER1 1728.38116769035 ## 45 untrt_N052611 untrt PER1 156.369203700759 ## 46 untrt_N061011 untrt PER1 123.476891690872 ## 47 untrt_N080611 untrt PER1 194.974974658647 ## 48 untrt_N61311 untrt PER1 170.616393438453 ## 49 trt_N052611 trt SLC6A9 56.8961953886688 ## 50 trt_N061011 trt SLC6A9 95.3391636485024 ## 51 trt_N080611 trt SLC6A9 86.829285341317 ## 52 trt_N61311 trt SLC6A9 63.905375488457 ## 53 untrt_N052611 untrt SLC6A9 413.87970872618 ## 54 untrt_N061011 untrt SLC6A9 443.719821991366 ## 55 untrt_N080611 untrt SLC6A9 365.476499952657 ## 56 untrt_N61311 untrt SLC6A9 360.663136119816 library(ggplot2) ggplot(top6_t_with_group_melt, aes(x=Gene, y=Expr)) + geom_boxplot(aes(color=conditions)) + theme_classic() 9.4.6 配色 序列型颜色板适用于从低到高排序明显的数据，浅色数字小，深色数字大。 library(RColorBrewer) display.brewer.all(type = &quot;seq&quot;) 离散型颜色板适合带“正、负”的，对极值和中间值比较注重的数据。 display.brewer.all(type = &quot;div&quot;) 分类型颜色板比较适合区分分类型的数据。 display.brewer.all(type = &quot;qual&quot;) 9.4.7 箱线图加统计分析 my_comparisons &lt;- list(c(&quot;trt&quot;, &quot;untrt&quot;)) ggboxplot(top6_t_with_group, x = &quot;conditions&quot;, y = &quot;PER1&quot;, title = &quot;PER1&quot;, ylab = &quot;Expression&quot;, add = &quot;jitter&quot;, # Add jittered points #add = &quot;dotplot&quot;, fill = &quot;conditions&quot;, palette = &quot;Paired&quot;) + stat_compare_means(comparisons = my_comparisons) 标记点来源的样本 my_comparisons &lt;- list(c(&quot;trt&quot;, &quot;untrt&quot;)) ggboxplot(top6_t_with_group, x = &quot;conditions&quot;, y = &quot;PER1&quot;, title = &quot;PER1&quot;, ylab = &quot;Expression&quot;, add = &quot;jitter&quot;, # Add jittered points add.params = list(size = 0.1, jitter = 0.2), # Point size and the amount of jittering label = &quot;Sample&quot;, # column containing point labels label.select = list(top.up = 2, top.down = 2),# Select some labels to display font.label = list(size = 9, face = &quot;italic&quot;), # label font repel = TRUE, # Avoid label text overplotting fill = &quot;conditions&quot;, palette = &quot;Paired&quot;) + stat_compare_means(comparisons = my_comparisons) 修改统计检验方法 my_comparisons &lt;- list(c(&quot;trt&quot;, &quot;untrt&quot;)) ggboxplot(top6_t_with_group_log, x = &quot;conditions&quot;, y = &quot;PER1&quot;, title = &quot;PER1&quot;, ylab = &quot;Expression&quot;, add = &quot;jitter&quot;, # Add jittered points add.params = list(size = 0.1, jitter = 0.2), # Point size and the amount of jittering label = &quot;Sample&quot;, # column containing point labels label.select = list(top.up = 2, top.down = 2),# Select some labels to display font.label = list(size = 9, face = &quot;italic&quot;), # label font repel = TRUE, # Avoid label text overplotting fill = &quot;conditions&quot;, palette = &quot;Paired&quot;) + stat_compare_means(comparisons = my_comparisons, method = &quot;t.test&quot;, paired = T) 小提琴图 ggviolin(top6_t_with_group, x = &quot;conditions&quot;, y = c(&quot;KCTD12&quot;,&quot;MAOA&quot;), ylab = &quot;Expression&quot;, merge=&quot;flip&quot;, color = &quot;conditions&quot;, palette = &quot;jco&quot;, add = &quot;boxplot&quot; # add = &quot;median_iqr&quot; ) ## Ignoring unknown labels: ## • fill : &quot;&quot; ## • linetype : &quot;&quot; ## • shape : &quot;&quot; 点带图（适合数据比较多） ggstripchart(top6_t_with_group, x = &quot;conditions&quot;, y = c(&quot;KCTD12&quot;,&quot;MAOA&quot;), ylab = &quot;Expression&quot;, combine=T, color = &quot;conditions&quot;, palette = &quot;jco&quot;, size = 0.1, jitter = 0.2, add.params = list(color = &quot;gray&quot;), # add = &quot;boxplot&quot; add = &quot;median_iqr&quot;) 9.5 通路内基因的比较 pathway &lt;- read.table(&quot;h.all.v6.2.symbols.gmt.forGO&quot;, sep=&quot;\\t&quot;, row.names=NULL, header=T) head(pathway) ## ont gene ## 1 HALLMARK_TNFA_SIGNALING_VIA_NFKB JUNB ## 2 HALLMARK_TNFA_SIGNALING_VIA_NFKB CXCL2 ## 3 HALLMARK_TNFA_SIGNALING_VIA_NFKB ATF3 ## 4 HALLMARK_TNFA_SIGNALING_VIA_NFKB NFKBIA ## 5 HALLMARK_TNFA_SIGNALING_VIA_NFKB TNFAIP3 ## 6 HALLMARK_TNFA_SIGNALING_VIA_NFKB PTGS2 通路提取 # HALLMARK_HYPOXIA, HALLMARK_DNA_REPAIR, HALLMARK_P53_PATHWAY target_pathway &lt;- pathway[pathway$ont %in% c(&quot;HALLMARK_HYPOXIA&quot;, &quot;HALLMARK_DNA_REPAIR&quot;, &quot;HALLMARK_P53_PATHWAY&quot;),] target_pathway &lt;- droplevels.data.frame(target_pathway) summary(target_pathway) ## ont gene ## Length:550 Length:550 ## Class :character Class :character ## Mode :character Mode :character head(target_pathway) ## ont gene ## 201 HALLMARK_HYPOXIA PGK1 ## 202 HALLMARK_HYPOXIA PDK1 ## 203 HALLMARK_HYPOXIA GBE1 ## 204 HALLMARK_HYPOXIA PFKL ## 205 HALLMARK_HYPOXIA ALDOA ## 206 HALLMARK_HYPOXIA ENO2 表达矩阵提取 expr_with_gene &lt;- expr expr_with_gene$gene &lt;- rownames(expr_with_gene) target_pathway_with_expr &lt;- left_join(target_pathway, expr_with_gene) ## Joining with `by = join_by(gene)` summary(target_pathway_with_expr) ## ont gene untrt_N61311 untrt_N052611 ## Length:550 Length:550 Min. : 0.0 Min. : 0.0 ## Class :character Class :character 1st Qu.: 254.2 1st Qu.: 240.8 ## Mode :character Mode :character Median : 781.3 Median : 784.1 ## Mean : 2528.6 Mean : 2895.1 ## 3rd Qu.: 1852.4 3rd Qu.: 1727.2 ## Max. :212953.1 Max. :360796.2 ## NA&#39;s :36 NA&#39;s :36 ## untrt_N080611 untrt_N061011 trt_N61311 trt_N052611 ## Min. : 0.0 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 235.0 1st Qu.: 237.9 1st Qu.: 248.2 1st Qu.: 211.0 ## Median : 734.9 Median : 764.2 Median : 766.6 Median : 723.2 ## Mean : 2549.2 Mean : 2864.9 Mean : 2531.8 Mean : 2783.3 ## 3rd Qu.: 1932.4 3rd Qu.: 1870.0 3rd Qu.: 1872.4 3rd Qu.: 1832.2 ## Max. :258977.3 Max. :408573.1 Max. :210002.2 Max. :316009.1 ## NA&#39;s :36 NA&#39;s :36 NA&#39;s :36 NA&#39;s :36 ## trt_N080611 trt_N061011 ## Min. : 0.0 Min. : 0.0 ## 1st Qu.: 250.6 1st Qu.: 227.9 ## Median : 739.3 Median : 746.0 ## Mean : 2840.3 Mean : 3043.6 ## 3rd Qu.: 1825.8 3rd Qu.: 1925.1 ## Max. :225547.4 Max. :393843.7 ## NA&#39;s :36 NA&#39;s :36 移除通路中未检测到表达的基因 target_pathway_with_expr &lt;- na.omit(target_pathway_with_expr) summary(target_pathway_with_expr) ## ont gene untrt_N61311 untrt_N052611 ## Length:514 Length:514 Min. : 0.0 Min. : 0.0 ## Class :character Class :character 1st Qu.: 254.2 1st Qu.: 240.8 ## Mode :character Mode :character Median : 781.3 Median : 784.1 ## Mean : 2528.6 Mean : 2895.1 ## 3rd Qu.: 1852.4 3rd Qu.: 1727.2 ## Max. :212953.1 Max. :360796.2 ## untrt_N080611 untrt_N061011 trt_N61311 trt_N052611 ## Min. : 0.0 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 235.0 1st Qu.: 237.9 1st Qu.: 248.2 1st Qu.: 211.0 ## Median : 734.9 Median : 764.2 Median : 766.6 Median : 723.2 ## Mean : 2549.2 Mean : 2864.9 Mean : 2531.8 Mean : 2783.3 ## 3rd Qu.: 1932.4 3rd Qu.: 1870.0 3rd Qu.: 1872.4 3rd Qu.: 1832.2 ## Max. :258977.3 Max. :408573.1 Max. :210002.2 Max. :316009.1 ## trt_N080611 trt_N061011 ## Min. : 0.0 Min. : 0.0 ## 1st Qu.: 250.6 1st Qu.: 227.9 ## Median : 739.3 Median : 746.0 ## Mean : 2840.3 Mean : 3043.6 ## 3rd Qu.: 1825.8 3rd Qu.: 1925.1 ## Max. :225547.4 Max. :393843.7 head(target_pathway_with_expr) ## ont gene untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 ## 1 HALLMARK_HYPOXIA PGK1 7567.398 7893.2150 6254.5945 5529.122 ## 2 HALLMARK_HYPOXIA PDK1 1009.850 1042.4868 735.9359 673.208 ## 3 HALLMARK_HYPOXIA GBE1 3859.557 1494.4120 3803.5627 3295.191 ## 4 HALLMARK_HYPOXIA PFKL 3581.499 3018.0675 2789.4430 3084.570 ## 5 HALLMARK_HYPOXIA ALDOA 19139.085 19587.3216 18089.5116 15519.899 ## 6 HALLMARK_HYPOXIA ENO2 1964.796 979.5255 1041.4660 1288.837 ## trt_N61311 trt_N052611 trt_N080611 trt_N061011 ## 1 7595.0408 6969.6128 15011.823 6076.4392 ## 2 419.6273 365.0062 1056.622 383.6163 ## 3 4769.5464 2359.7150 4759.809 4296.5471 ## 4 2867.2464 2599.5095 4399.403 3090.6701 ## 5 16388.1123 13949.5659 22630.701 14374.3437 ## 6 1303.5671 766.9436 1473.336 892.4621 转换宽矩阵为长矩阵 target_pathway_with_expr_long &lt;- target_pathway_with_expr %&gt;% gather(key=&quot;Sample&quot;, value=&quot;Expr&quot;, -ont, -gene) head(target_pathway_with_expr_long) ## ont gene Sample Expr ## 1 HALLMARK_HYPOXIA PGK1 untrt_N61311 7567.398 ## 2 HALLMARK_HYPOXIA PDK1 untrt_N61311 1009.850 ## 3 HALLMARK_HYPOXIA GBE1 untrt_N61311 3859.557 ## 4 HALLMARK_HYPOXIA PFKL untrt_N61311 3581.499 ## 5 HALLMARK_HYPOXIA ALDOA untrt_N61311 19139.085 ## 6 HALLMARK_HYPOXIA ENO2 untrt_N61311 1964.796 合并样本信息 metadata$Sample &lt;- rownames(metadata) target_pathway_with_expr_conditions_long &lt;- target_pathway_with_expr_long %&gt;% left_join(metadata, by=&quot;Sample&quot;) head(target_pathway_with_expr_conditions_long) ## ont gene Sample Expr conditions individual ## 1 HALLMARK_HYPOXIA PGK1 untrt_N61311 7567.398 untrt N61311 ## 2 HALLMARK_HYPOXIA PDK1 untrt_N61311 1009.850 untrt N61311 ## 3 HALLMARK_HYPOXIA GBE1 untrt_N61311 3859.557 untrt N61311 ## 4 HALLMARK_HYPOXIA PFKL untrt_N61311 3581.499 untrt N61311 ## 5 HALLMARK_HYPOXIA ALDOA untrt_N61311 19139.085 untrt N61311 ## 6 HALLMARK_HYPOXIA ENO2 untrt_N61311 1964.796 untrt N61311 再次画点带图 ggstripchart(target_pathway_with_expr_conditions_long, x = &quot;ont&quot;, y = &quot;Expr&quot;, ylab = &quot;Expression&quot;, combine=T, color = &quot;conditions&quot;, palette = &quot;jco&quot;, size = 0.1, jitter = 0.2, add.params = list(color = &quot;gray&quot;), # add = &quot;boxplot&quot; add = &quot;median_iqr&quot;) 表达数据log转换 target_pathway_with_expr_conditions_long$logExpr &lt;- log2(target_pathway_with_expr_conditions_long$Expr + 1) ggstripchart(target_pathway_with_expr_conditions_long, x = &quot;ont&quot;, y = &quot;logExpr&quot;, ylab = &quot;Expression&quot;, combine=T, color = &quot;conditions&quot;, palette = &quot;jco&quot;, size = 0.1, jitter = 0.2, add.params = list(color = &quot;gray&quot;), # add = &quot;boxplot&quot; add = &quot;median_iqr&quot;) head(target_pathway_with_expr_conditions_long) ## ont gene Sample Expr conditions individual logExpr ## 1 HALLMARK_HYPOXIA PGK1 untrt_N61311 7567.398 untrt N61311 12.885772 ## 2 HALLMARK_HYPOXIA PDK1 untrt_N61311 1009.850 untrt N61311 9.981353 ## 3 HALLMARK_HYPOXIA GBE1 untrt_N61311 3859.557 untrt N61311 11.914593 ## 4 HALLMARK_HYPOXIA PFKL untrt_N61311 3581.499 untrt N61311 11.806750 ## 5 HALLMARK_HYPOXIA ALDOA untrt_N61311 19139.085 untrt N61311 14.224310 ## 6 HALLMARK_HYPOXIA ENO2 untrt_N61311 1964.796 untrt N61311 10.940898 提取P53通路进行后续分析 HALLMARK_P53_PATHWAY = target_pathway_with_expr_conditions_long[target_pathway_with_expr_conditions_long$ont==&quot;HALLMARK_P53_PATHWAY&quot;,] ggstripchart(HALLMARK_P53_PATHWAY, x = &quot;conditions&quot;, y = &quot;logExpr&quot;, title = &quot;HALLMARK_P53_PATHWAY&quot;, ylab = &quot;Expression&quot;, color = &quot;conditions&quot;, palette = &quot;jco&quot;, size = 0.1, jitter = 0.2, add.params = list(color = &quot;gray&quot;), # add = &quot;boxplot&quot; add = &quot;median_iqr&quot;) ggdotplot(HALLMARK_P53_PATHWAY, x = &quot;conditions&quot;, y = &quot;logExpr&quot;, title = &quot;HALLMARK_P53_PATHWAY&quot;, ylab = &quot;Expression&quot;, color = &quot;conditions&quot;, palette = &quot;jco&quot;, fill = &quot;white&quot;, binwidth = 0.1, add.params = list(size = 0.9), # add = &quot;boxplot&quot; add = &quot;median_iqr&quot;) 9.5.1 密度图 ggdensity(HALLMARK_P53_PATHWAY, x=&quot;logExpr&quot;, y = &quot;..density..&quot;, combine = TRUE, # Combine the 3 plots xlab = &quot;Expression&quot;, add = &quot;median&quot;, # Add median line. rug = TRUE, # Add marginal rug color = &quot;conditions&quot;, fill = &quot;conditions&quot;, palette = &quot;jco&quot; ) head(top6_t_with_group) ## Sample conditions individual KCTD12 MAOA ARHGEF2 SPARCL1 ## 1 trt_N052611 trt N052611 633.4462 4429.7201 1441.992 1750.98786 ## 2 trt_N061011 trt N061011 641.4958 3778.1735 1501.515 2194.58930 ## 3 trt_N080611 trt N080611 979.7758 4629.6653 1464.598 1374.90745 ## 4 trt_N61311 trt N61311 936.6948 4628.0086 1395.398 2220.50867 ## 5 untrt_N052611 untrt N052611 3978.0401 452.9934 3105.783 102.58269 ## 6 untrt_N061011 untrt N061011 4792.3417 258.7328 2909.990 82.59042 ## PER1 SLC6A9 ## 1 1230.2575 56.89620 ## 2 1333.9121 95.33916 ## 3 1120.0065 86.82929 ## 4 1728.3812 63.90538 ## 5 156.3692 413.87971 ## 6 123.4769 443.71982 top6_t_with_group_long = top6_t_with_group %&gt;% gather(key=&quot;Gene&quot;, value=&quot;Expr&quot;, -conditions, -Sample, -individual) top6_t_with_group_long$conditions &lt;- as.factor(top6_t_with_group_long$conditions) head(top6_t_with_group_long) ## Sample conditions individual Gene Expr ## 1 trt_N052611 trt N052611 KCTD12 633.4462 ## 2 trt_N061011 trt N061011 KCTD12 641.4958 ## 3 trt_N080611 trt N080611 KCTD12 979.7758 ## 4 trt_N61311 trt N61311 KCTD12 936.6948 ## 5 untrt_N052611 untrt N052611 KCTD12 3978.0401 ## 6 untrt_N061011 untrt N061011 KCTD12 4792.3417 9.6 ggstatsplot绘图和统计分析 箱线图 library(ggstatsplot) ggstatsplot::ggwithinstats( data = top6_t_with_group, x = conditions, y = PER1, sort = &quot;descending&quot;, # ordering groups along the x-axis based on sort.fun = median, # values of `y` variable pairwise.comparisons = TRUE, pairwise.display = &quot;s&quot;, pairwise.annotation = &quot;p&quot;, title = &quot;PER1&quot;, caption = &quot;PER1 compare&quot;, ggstatsplot.layer = FALSE, messages = FALSE ) head(target_pathway_with_expr_conditions_long) ## ont gene Sample Expr conditions individual logExpr ## 1 HALLMARK_HYPOXIA PGK1 untrt_N61311 7567.398 untrt N61311 12.885772 ## 2 HALLMARK_HYPOXIA PDK1 untrt_N61311 1009.850 untrt N61311 9.981353 ## 3 HALLMARK_HYPOXIA GBE1 untrt_N61311 3859.557 untrt N61311 11.914593 ## 4 HALLMARK_HYPOXIA PFKL untrt_N61311 3581.499 untrt N61311 11.806750 ## 5 HALLMARK_HYPOXIA ALDOA untrt_N61311 19139.085 untrt N61311 14.224310 ## 6 HALLMARK_HYPOXIA ENO2 untrt_N61311 1964.796 untrt N61311 10.940898 head(HALLMARK_P53_PATHWAY) ## ont gene Sample Expr conditions individual ## 322 HALLMARK_P53_PATHWAY CDKN1A untrt_N61311 14406.1316 untrt N61311 ## 323 HALLMARK_P53_PATHWAY BTG2 untrt_N61311 1163.7198 untrt N61311 ## 324 HALLMARK_P53_PATHWAY MDM2 untrt_N61311 3614.5324 untrt N61311 ## 325 HALLMARK_P53_PATHWAY CCNG1 untrt_N61311 5749.1367 untrt N61311 ## 326 HALLMARK_P53_PATHWAY FAS untrt_N61311 1029.4007 untrt N61311 ## 327 HALLMARK_P53_PATHWAY TOB1 untrt_N61311 829.7721 untrt N61311 ## logExpr ## 322 13.814496 ## 323 10.185767 ## 324 11.819992 ## 325 12.489381 ## 326 10.008990 ## 327 9.698309 library(ggstatsplot) ggstatsplot::ggwithinstats( data = HALLMARK_P53_PATHWAY, x = conditions, y = logExpr, sort = &quot;descending&quot;, # ordering groups along the x-axis based on sort.fun = median, # values of `y` variable pairwise.comparisons = TRUE, pairwise.display = &quot;s&quot;, pairwise.annotation = &quot;p&quot;, title = &quot;HALLMARK_P53_PATHWAY&quot;, path.point = F, ggtheme = ggthemes::theme_fivethirtyeight(), ggstatsplot.layer = FALSE, messages = FALSE ) library(ggstatsplot) ggstatsplot::grouped_ggwithinstats( data = target_pathway_with_expr_conditions_long, x = conditions, y = logExpr, grouping.var = ont, xlab = &quot;Condition&quot;, ylab = &quot;CEMIP expression&quot;, path.point = F, palette = &quot;Set1&quot;, # R color brewer ggstatsplot.layer = FALSE, messages = FALSE ) ggstatsplot::grouped_ggwithinstats( data = top6_t_with_group_long, x = conditions, y = Expr, xlab = &quot;Condition&quot;, ylab = &quot;CEMIP expression&quot;, grouping.var = Gene, ggstatsplot.layer = FALSE, messages = FALSE ) head(expr) ## untrt_N61311 untrt_N052611 untrt_N080611 untrt_N061011 trt_N61311 ## FN1 245667.66 427435.1 221687.51 371144.2 240187.24 ## DCN 212953.14 360796.2 258977.30 408573.1 210002.18 ## CEMIP 40996.34 137783.1 53813.92 91066.8 62301.12 ## CCDC80 137229.15 232772.2 86258.13 212237.3 136730.76 ## IGFBP5 77812.65 288609.2 210628.87 168067.4 96021.74 ## COL1A1 146450.41 127367.3 152281.50 140861.1 62358.64 ## trt_N052611 trt_N080611 trt_N061011 ## FN1 450103.21 280226.19 376518.23 ## DCN 316009.14 225547.39 393843.74 ## CEMIP 223111.85 212724.84 157919.47 ## CCDC80 226070.89 124634.56 236237.81 ## IGFBP5 217439.21 162677.38 168387.36 ## COL1A1 53800.47 69160.97 51044.06 9.6.1 散点图 ggstatsplot::ggscatterstats( data = expr, x = untrt_N61311, y = untrt_N052611, xlab = &quot;untrt_N61311&quot;, ylab = &quot;untrt_N052611&quot;, title = &quot;Sample correlation&quot;, messages = FALSE ) ## `stat_xsidebin()` using `bins = 30`. ## Pick better value `binwidth`. ## `stat_ysidebin()` using `bins = 30`. ## Pick better value `binwidth`. ggstatsplot::ggscatterstats( data = log2(expr+1), x = untrt_N61311, y = trt_N61311, xlab = &quot;untrt_N61311&quot;, ylab = &quot;trt_N61311&quot;, title = &quot;Sample correlation&quot;, #marginal.type = &quot;density&quot;, # type of marginal distribution to be displayed messages = FALSE ) ## `stat_xsidebin()` using `bins = 30`. ## Pick better value `binwidth`. ## `stat_ysidebin()` using `bins = 30`. ## Pick better value `binwidth`. 9.6.2 相关性图 9.6.2.1 基因共表达 gene_cor &lt;- cor(t(top6)) head(gene_cor) ## KCTD12 MAOA ARHGEF2 SPARCL1 PER1 SLC6A9 ## KCTD12 1.0000000 -0.9792624 0.9799663 -0.9619660 -0.9529732 0.9772852 ## MAOA -0.9792624 1.0000000 -0.9897706 0.9406196 0.9614877 -0.9871408 ## ARHGEF2 0.9799663 -0.9897706 1.0000000 -0.9628750 -0.9660416 0.9791535 ## SPARCL1 -0.9619660 0.9406196 -0.9628750 1.0000000 0.9853858 -0.9510121 ## PER1 -0.9529732 0.9614877 -0.9660416 0.9853858 1.0000000 -0.9615253 ## SLC6A9 0.9772852 -0.9871408 0.9791535 -0.9510121 -0.9615253 1.0000000 pheatmap(gene_cor) Hmisc::rcorr(as.matrix(top6_t)) ## KCTD12 MAOA ARHGEF2 SPARCL1 PER1 SLC6A9 ## KCTD12 1.00 -0.98 0.98 -0.96 -0.95 0.98 ## MAOA -0.98 1.00 -0.99 0.94 0.96 -0.99 ## ARHGEF2 0.98 -0.99 1.00 -0.96 -0.97 0.98 ## SPARCL1 -0.96 0.94 -0.96 1.00 0.99 -0.95 ## PER1 -0.95 0.96 -0.97 0.99 1.00 -0.96 ## SLC6A9 0.98 -0.99 0.98 -0.95 -0.96 1.00 ## ## n= 8 ## ## ## P ## KCTD12 MAOA ARHGEF2 SPARCL1 PER1 SLC6A9 ## KCTD12 0e+00 0e+00 1e-04 3e-04 0e+00 ## MAOA 0e+00 0e+00 5e-04 1e-04 0e+00 ## ARHGEF2 0e+00 0e+00 1e-04 0e+00 0e+00 ## SPARCL1 1e-04 5e-04 1e-04 0e+00 3e-04 ## PER1 3e-04 1e-04 0e+00 0e+00 1e-04 ## SLC6A9 0e+00 0e+00 0e+00 3e-04 1e-04 head(top6_t) ## KCTD12 MAOA ARHGEF2 SPARCL1 PER1 SLC6A9 ## untrt_N61311 4700.7937 438.5445 3025.623 58.15705 170.6164 360.66314 ## untrt_N052611 3978.0401 452.9934 3105.783 102.58269 156.3692 413.87971 ## untrt_N080611 4416.1517 516.6303 3094.513 80.00997 194.9750 365.47650 ## untrt_N061011 4792.3417 258.7328 2909.990 82.59042 123.4769 443.71982 ## trt_N61311 936.6948 4628.0086 1395.398 2220.50867 1728.3812 63.90538 ## trt_N052611 633.4462 4429.7201 1441.992 1750.98786 1230.2575 56.89620 ggstatsplot::ggcorrmat( data = top6_t, corr.method = &quot;robust&quot;, # correlation method sig.level = 0.0001, # threshold of significance p.adjust.method = &quot;holm&quot;, # p-value adjustment method for multiple comparisons # cor.vars = c(sleep_rem, awake:bodywt), # a range of variables can be selected # cor.vars.names = c( # &quot;REM sleep&quot;, # variable names # &quot;time awake&quot;, # &quot;brain weight&quot;, # &quot;body weight&quot; # ), matrix.type = &quot;upper&quot;, # type of visualization matrix palette = &quot;Set2&quot;, #colors = c(&quot;#B2182B&quot;, &quot;white&quot;, &quot;#4D4D4D&quot;), title = &quot;Correlalogram for mammals sleep dataset&quot;, subtitle = &quot;sleep units: hours; weight units: kilograms&quot; ) 9.6.2.2 样品相关性 top100 &lt;- head(expr,100) ggstatsplot::ggcorrmat( data = top100, corr.method = &quot;robust&quot;, # correlation method sig.level = 0.05, # threshold of significance p.adjust.method = &quot;holm&quot;, # p-value adjustment method for multiple comparisons # cor.vars = c(sleep_rem, awake:bodywt), # a range of variables can be selected # cor.vars.names = c( # &quot;REM sleep&quot;, # variable names # &quot;time awake&quot;, # &quot;brain weight&quot;, # &quot;body weight&quot; # ), matrix.type = &quot;upper&quot;, # type of visualization matrix palette = &quot;Set2&quot; #colors = c(&quot;#B2182B&quot;, &quot;white&quot;, &quot;#4D4D4D&quot;), ) "],["imageGP.html", "10 高颜值免费在线绘图（提供绘图源码） 10.1 高颜值免费在线绘图基础版视频 10.2 高颜值免费在线绘图进阶版视频", " 10 高颜值免费在线绘图（提供绘图源码） ImageGP 1.0 https://www.bic.ac.cn/ImageGP ImageGP 2.0 https://www.bic.ac.cn/BIC 视频教程 https://space.bilibili.com/362709786/lists/5849058?type=season 10.1 高颜值免费在线绘图基础版视频 https://www.bilibili.com/video/BV1Zh411974X 10.2 高颜值免费在线绘图进阶版视频 https://www.bilibili.com/video/BV17D4y1o7y4 "],["ref.html", "11 参考 11.1 Illumina测序应用手册 11.2 系列教程 11.3 蛋白质组学研究 11.4 转录组研究 11.5 单细胞系列教程 11.6 GEO/TCGA数据 11.7 扩增子三步曲 11.8 宏基因组教程 11.9 宏基因组分析专题 11.10 ChIP-seq专题 11.11 Linux 全介绍 11.12 CIRCOS系列 11.13 R统计和作图 11.14 NGS基础和软件应用 11.15 生信宝典之傻瓜式 11.16 Python 11.17 Cytoscape网络图 11.18 分子对接 11.19 文献精读 11.20 2019的高阅读文章合集 11.21 精选文章推荐 11.22 科研经验 11.23 软件和数据库 11.24 扩增子分析 11.25 宏基因组分析 11.26 实验设计与技术 11.27 文献精读 11.28 科普视频*寓教于乐 11.29 系列宣传 11.30 永久链接", " 11 参考 生信的作用越来越大，想学的人越来越多，不管是为了以后发展，还是为了解决眼下的问题。但生信学习不是一朝一夕就可以完成的事情，也许你可以很短时间学会一个交互式软件的操作，却不能看完程序教学视频后就直接写程序。也许你可以跟着一个测序分析流程完成操作，但不懂得背后的原理，不知道什么参数需要修改，结果可以出来，却把握不住对还是错。 学习生信从来就不是一个简单的事，需要做好持久战的心理准备。 在学习时，我们都希望由浅入深的逐步深入，不断地练习和实践，这就是为什么我们需要一本书，因为书很系统。但生信发展的历史短于计算机编程的历史，如果想要一门程序设计的入门数据，每种语言都可以找到几本。但想要一个囊括生信的书，就有些难了。本身生信跨领域，需要多学科的知识，而其内部又有不少分子，都囊括了太大，包括的少又有些隔靴搔痒的感觉。 我们当时都是零基础下自学Linux, 自学Python，自学R，自学高通量测序；这些学习经历，之前都零星地记录在博客里。现在回头去看几年前自己记录的东西，觉得好简单，而当时却费了很大的力气。这些零星的随手记，当时也只是为了自己看，到现在确实只有自己能看得懂，不便惠及更多的人。 因此我们创建了生信宝典，希望从不同的角度传播知识。这个不同有三点含义，一是形式上的不同，摒弃之前主编们单人作战想写啥就写啥，而是有组织有计划的内容聚合，提供一系列的教程，由入门到提高。二是内容的不同，不去用网上现有教程的通用数据做例子，而是拿实际生物数据，讲述如何解释生信中普遍碰到的问题，讲述如何处理自己的数据。三是立足点不同。在写作时，我们回到了当年，在回忆中用整个阶段的学习去指导当初的那个小白，从那些会了的人觉得微不足道而不会的人又迈不过的坎入手，直击痛点。知识点的收录依据不是是否炫酷，是否难，而是是否必要。如果必要，再简单，也要提及；如果不必要，再炫酷，也暂不纳入。 通过大量的生信例子、关键的注释和浓缩的语句形成下面的一系列学习教程。每一篇内容都不多，可以当做小说阅读，也可以跟着去练，反复几遍，每读一次都会有不同的收获和体会。 征稿：诚邀广大同行分享学习经验、心得体会、成果文章解读，即有利于交流和宣传，又提高自身的影响和文章的引用推广；欢迎本领域科研院所和高校的团队在本平台免费发布招聘广告。(诚招培训招生主管、招生助理、公众号编辑) 生物信息学包含生物数据分析、数据可视化、重复工作程序化，是生物、医学科研必备的技能之一。生信宝典精心组织生信学习系列教程、生信工具精品教程，通过大量的生信例子、关键的注释、浓缩的语句和录制的视频帮助快速掌握生信知识。 更多知识敬请扫码关注，还有PDF教程可以领取。 注：下面为往期文章目录集合，所有蓝字均为文章链接，点击阅读原文 11.1 Illumina测序应用手册 Illumina测序仪比较和各种测序应用模式图，助力了解高通量测序 11.2 系列教程 画图手册 | ImageGP：今天你“plot”了吗？ 知乎阅读三百万的生信学习指南 当我们谈论生信的时候我们在谈什么 生物信息之程序学习 关于编程学习的一些思考 该如何自学入门生物信息学 生信宝典视频教程 转录组分析的正确姿势 收藏 你想要的生信学习系列教程-宝典在手，生信无忧 生信的系列书籍 文章用图的修改和排版 (1) 文章用图的修改和排版 (2) 简单强大的在线绘图 简单强大的在线绘图-升级版 简单强大的在线绘图-第3版 论文图表基本规范 学术图表的基本配色方法 数据可视化基本套路总结 英语写作常见错误总结和学习视频 教育部推出首批490门”国家精品在线开放课程” 你该知道的杂志分区和影响因子及最新表格下载 你和PPT高手之间，就只差一个iSlide 推荐 3 个超赞的 EXCEL 插件，让你 5 分钟从小白变大神 史上最全的图表色彩运用原理 生信宝典一周年福利第一波 - 电子书赠送 测序发展史：150年的风雨历程 一文看全！史上以来的59家测序仪公司 生信老司机以中心法则为主线讲解组学技术的应用和生信分析心得 别再让投稿信耽误你发稿啦！（附cover letter模板） 生物信息学数据库分类概览 (第一版) 跟Cell editor学做scientific presentation (25个判断标准，18个不能做，8个建议) 一文掌握GSEA，超详细教程 看人家的导师，不需要做实验，居然发表了27篇Cell，Cancer Cell，Immunity等高水平文章 Web of stories - 听大师讲故事 这个只需一步就可做富集分析的网站还未发表就被CNS等引用超过350次 什么，你算出的P-value看上去像齐天大圣变的庙？ 从一段挖矿病毒代码看Linux命令的实际应用 Nature重磅综述 |关于RNA-seq，你想知道的都在这 机器学习爱好者必读的入门指南 14岁的男孩说想学生信，应该给予哪些指导？ RNA-seq最强综述名词解释&amp;思维导图|关于RNA-seq，你想知道的都在这（续） 有了这些，文件批量重命名还需要求助其它工具吗？ 只需一行代码，完美呈现Markdown格式，写作展示两不误 11.3 蛋白质组学研究 蛋白质组学研究概述 《自然》重磅：迄今最大规模人类蛋白互作组诞生 11.4 转录组研究 39个转录组分析工具，120种组合评估(转录组分析工具哪家强-导读版) 39个转录组分析工具，120种组合评估(转录组分析工具大比拼 （完整翻译版）) 无参转录组分析工具评估和流程展示 120分的转录组试题（第一份答案） 120分的转录组试题（第二份答案） 120分的转录组试题（第三份答案） DESeq2差异基因分析和批次效应移除 美女教授带你从统计学视角看转录组分析 整合QC质控结果的利器——MultiQC 自从用了这个神器，大规模RNA-seq数据挖掘我也可以 NGS基础 - FASTQ格式解释和质量评估 NGS基础 - 高通量测序原理 NGS基础 - 参考基因组和基因注释文件 NGS基础 - GTF/GFF文件格式解读和转换 NGS基础 - 测序原始数据下载 耗时很长的程序忘加nohup就运行了怎么办？ Illumina测序仪比较和各种测序应用模式图，助力了解高通量测序 生信分析过程中这些常见文件的格式以及查看方式你都知道吗？ 本地安装UCSC基因组浏览器 测序数据可视化 (一) IGV基因组浏览器可视化高通量测序数据 高通量数据分析必备-基因组浏览器使用介绍 - 1 高通量数据分析必备-基因组浏览器使用介绍 - 2 高通量数据分析必备-基因组浏览器使用介绍 - 3 测序文章数据上传找哪里 GO、GSEA富集分析一网打进 GSEA富集分析 - 界面操作 无需写代码的高颜值富集分析神器 去东方，最好用的在线GO富集分析工具 没钱买KEGG怎么办？REACTOME开源通路更强大 超简便的国产lncRNA预测工具LGC 我想做信号通路分析，但我就是不想学编程 一个逆天的small RNA-seq数据挖掘神器 一文掌握GSEA，超详细教程 这个只需一步就可做富集分析的网站还未发表就被CNS等引用超过350次 什么，你算出的P-value看上去像齐天大圣变的庙？ 单基因GSEA怎么做？ 赠你一只金色的眼 - 富集分析和表达数据可视化 NCB|心咽发育多样化的单细胞转录轨迹分析 用了这么多年的PCA可视化竟然是错的！！！ 如何火眼金睛鉴定那些单细胞转录组中的混杂因素 Nature重磅综述 |关于RNA-seq，你想知道的都在这 RNA-seq最强综述名词解释&amp;思维导图|关于RNA-seq，你想知道的都在这（续） Pathview包：整合表达谱数据可视化KEGG通路 遗传所屠强研究组开发Decode-seq方法显著提高差异表达基因分析的准确性 转录组测序多少生物重复合适？2个？3个？48个？ 11.5 单细胞系列教程 11.5.1 经典综述 重磅综述：三万字长文读懂单细胞RNA测序分析的最佳实践教程 （原理、代码和评述） 如何使用Bioconductor进行单细胞分析？ 对一篇单细胞RNA综述的评述：细胞和基因质控参数的选择 收藏 北大生信平台” 单细胞分析、染色质分析” 视频和PPT分享 Nature重磅综述 |关于RNA-seq，你想知道的都在这 NBT|45种单细胞轨迹推断方法比较，110个实际数据集和229个合成数据集 11.5.2 文章解读 Science: 小鼠肾脏单细胞转录组+突变分析揭示肾病潜在的细胞靶标 Science：通过单细胞转录组测序揭示玉米减数分裂进程 | 很好的单细胞分析案例 Nature 首次对阿尔茨海默病进行单细胞转录组分析|详细解读 Cell 深度 一套普遍适用于各类单细胞测序数据集的锚定整合方案 骨髓基质在正常和白血病个体中的细胞图谱 Cell,Nature联袂解析 癌中之王：基质微环境塑造胰腺癌瘤内结构|Cell Nature系列 整合单细胞转录组学和质谱流式确定类风湿性关节炎滑膜组织中的炎症细胞状态 详细解读 Cell | 北大张泽民课题组与合作者揭示肝癌免疫微环境的动态特征 MC | 汤富酬课题组发表综述系统总结人类生殖系细胞发育的分子机制研究 Plos Biology | 汤富酬课题组与乔杰课题组合作绘制人类视网膜高精度发育细胞图谱 Cell子刊 | 植物单细胞转录组综述·植物功能基因组学的高分辨率研究方法 Cell子刊 | 肠内分泌细胞单细胞测序分析（附资源库传送门） 教你如何定义新亚群 | 在单细胞水平上解析人肝硬化的纤维化微环境 Cell stem cell | 周斌研究组利用10xgenomics测序和谱系示踪技术合作发现血管平滑肌干细胞参与动脉修复 风湿病年鉴 | scRNA-seq研究揭示骨关节炎患者的半月板退变新机制 2019文献汇总 | 单细胞与病毒感染 2019汇总之从4个关键词看单细胞与肝癌文献 植物单细胞转录组的春天来了，还不上车？Science, PC, PP, MP, bioRxiv各一个 跨物种单细胞分析发现胰腺导管癌中一类有免疫原性的抗原呈递成纤维细胞 NCB|心咽发育多样化的单细胞转录轨迹分析 Cell 单细胞文章 | 白凡课题组与合作团队揭示儿童结肠炎及炎症性肠病的致病机制及治疗方法 Nature | ​心脏发生的单细胞分析揭示了器官水平发育缺陷的基础 Gut | 汤富酬研究组与付卫研究组合作揭示家族性腺瘤性息肉病的发病机制 ​ 利用单细胞公共数据对新冠受体ACE2的研究进展 最新进展！单细胞数据显示ACE2在鼻腔、肾脏、睾丸均有分布！ 吃多一时爽，吃少活更长！ 大联合 - 单细胞测序在新冠肺炎研究中的应用进展 (视频+PPT) 致癌物（HPV-）和病毒介导的（HPV +）HNSCC免疫图谱 第一篇新冠单细胞文献！|解读 单细胞RNA-seq预处理工具比较分析（bioRxiv） Molecular Metabolism｜徐成冉研究组揭示生理和病理状态下胰岛β细胞异质性 Cell | 小鼠内皮细胞单细胞转录组图谱（详解） Nature Metabolism I 衰老的单细胞组学研究进展及展望 Science | 单细胞分析人类胸腺发育的细胞图谱 新冠患者样本单细胞测序文献汇总 Developmental Cell | 人类视网膜发育过程中的重要分子机制 Nature子刊：中科院动物所合作揭示灵长类血管衰老的驱动力 人类细胞图谱计划发起人Aviv Regev博士讲单细胞基因组学 NC文章详解 | 鼠成纤维细胞单细胞分析发现成纤维细胞在心肌细胞成熟中起关键作用 11.5.3 系列教程 10X单细胞测序分析软件:Cell ranger，从拆库到定量 Hemberg-lab单细胞转录组数据分析（一）- 引言 Hemberg-lab单细胞转录组数据分析（二）- 实验平台 Hemberg-lab单细胞转录组数据分析（三）- 原始数据质控 Hemberg-lab单细胞转录组数据分析（四）- 文库拆分和细胞鉴定 Hemberg-lab单细胞转录组数据分析（五）- STAR, Kallisto定量 Hemberg-lab单细胞转录组数据分析（六）- 构建表达矩阵，UMI介绍 Hemberg-lab单细胞转录组数据分析（七）- 导入10X和SmartSeq2数据Tabula Muris Hemberg-lab单细胞转录组数据分析（八）- Scater包输入导入和存储 Hemberg-lab单细胞转录组数据分析（九）- Scater包单细胞过滤 Hemberg-lab单细胞转录组数据分析（十）- Scater基因评估和过滤 Hemberg-lab单细胞转录组数据分析（十一）- Scater单细胞表达谱PCA可视化 Hemberg-lab单细胞转录组数据分析（十二）- Scater单细胞表达谱tSNE可视化 如何火眼金睛鉴定那些单细胞转录组中的混杂因素 什么？你做的差异基因方法不合适？ 单细胞分群后，怎么找到Marker基因定义每一类群？ 11.5.4 特色分析 哇！单细胞测序-配体受体互作分析原来可以这么简单又高大上！ 七龙珠|召唤一份单细胞数据库汇总 单细胞预测Doublets软件包汇总-过渡态细胞是真的吗？ Seurat亮点之细胞周期评分和回归 cellassign：用于肿瘤微环境分析的单细胞注释工具（9月Nature） NC |SCALE准确鉴定单细胞ATAC-seq数据中染色质开放特征 让你的单细胞数据动起来！|iCellR(一) 让你的单细胞数据动起来！|iCellR(二) Celaref | 单细胞测序细胞类型注释工具 SCENIC | 从单细胞数据推断基因调控网络和细胞类型 在线平台如何做单细胞测序分析全套？有它so easy! SpatialDB |单细胞空间转录组数据分析可视化平台 单细胞分析Seurat使用相关的10个问题答疑精选！ 三人成虎，概率却不足十分之五？ 一文掌握GSEA，超详细教程 这个只需一步就可做富集分析的网站还未发表就被CNS等引用超过350次 什么，你算出的P-value看上去像齐天大圣变的庙？ GO、GSEA富集分析一网打进 GSEA富集分析 - 界面操作 无需写代码的高颜值富集分析神器 去东方，最好用的在线GO富集分析工具 用了这么多年的PCA可视化竟然是错的！！！ RNA-seq最强综述名词解释&amp;思维导图|关于RNA-seq，你想知道的都在这（续） “harmony”整合不同平台的单细胞数据之旅 复现原文（一）：Single-cell RNA sequencing of human kidney（step by step） 复现原文（二）：Single-cell RNA sequencing of human kidney（step by step） 单细胞转录组亚群分析 单细胞转录组高级分析介绍 代码分析 | 单细胞转录组质控详解 代码分析 | 单细胞转录组Normalization详解 代码分析 | 单细胞转录组数据整合详解 代码分析 | 单细胞转录组clustering详解 NBT：单细胞转录组新降维可视化方法PHATE 复现nature communication PCA原图|代码分析（一） 这篇Nature子刊文章的蛋白组学数据PCA分析竟花费了我两天时间来重现|附全过程代码 一个R包玩转单细胞免疫组库分析，还能与Seurat无缝对接 这个R包自动注释单细胞数据的平均准确率为83％，使用后我的结果出现了点问题|附全代码 翻车实录之Nature Medicine新冠单细胞文献|附全代码 听哈佛大神讲怎么做单细胞转录组GSEA分析 一个R包完成单细胞基因集富集分析 （全代码） 复现Cell附图 |类器官的单细胞分析 Seurat的单细胞免疫组库分析来了！ 哈佛大学单细胞课程：笔记汇总前篇 11.6 GEO/TCGA数据 UCSC XENA - 集大成者(TCGA, ICGC) ICGC数据库使用 TCGA数据库在线使用 BROAD开发的TCGA分析平台，强大的下载功能 cBioPortal功能强大的TCGA再分析平台 这是数据更新最实时的TCGA网站，功能强大 不懂R，如何进行GEO数据库表达谱的差异分析、富集分析、蛋白互作、可视化？ 典型医学设计实验GEO数据分析 (step-by-step) - Limma差异分析、火山图、功能富集 典型医学设计实验GEO数据分析 (step-by-step) - 数据获取到标准化 为什么GEO2R/GEOquery的结果可能是错的？ 这个只需一步就可做富集分析的网站还未发表就被CNS等引用超过350次 GEPIA|神一样的TCGA可视化网站 用了这么多年的PCA可视化竟然是错的！！！ maftools|TCGA肿瘤突变数据的汇总，分析和可视化 分享一个完美的工具：多数据库集合，研究基因组学癌症必备 TISIDB：这个科研工具能助你顺利发高分肿瘤免疫文章 超详细的GEO数据上传攻略，一看就会 11.7 扩增子三步曲 1图表解读-理解文章思路 2分析流程-把握分析细节 扩展1：视频教程-夯实分析思路 扩展2：QIIME2教程-了解分析趋势 3统计绘图-冲击高分文章 易生信-扩增子教程01-基本概念 易生信-扩增子教程02-真菌引物选择 收藏-手把手带你重现菌群封面文章全部结果图表 如何简化美化LEfSe分析结果中的Cladogram图 FEMS综述: 如何从微生物网络中的“毛线球”理出头绪(3万字长文带你系统学习网络) Nature子刊：教你零基础开展微生物组数据分析和可视化 11.8 宏基因组教程 Nature综述：Microbiota, metagenome, microbiome傻傻分不清 微生物组入门必读+宏基因组实操课程 扩增子图表解读-理解文章思路 扩增子分析流程-把握分析细节 扩增子统计绘图-冲击高分文章 宏基因组分析教程 4500元的微生物组培训资料 宏基因组分析教程合集 宏基因组分析教程合集和往期课程PPT分享 人类微生物组计划 - 宏基因组/16S分析流程 bioBakery 11.9 宏基因组分析专题 1 背景知识-Shell入门与本地blast实战 2 数据质控fastqc, Trimmomatic, MultiQC, khmer 3 组装拼接MEGAHIT和评估quast 4 基因注释Prokka 5 基于Kmer比较数据集sourmash 6 不比对快速估计基因丰度Salmon 7 bwa序列比对, samtools查看, bedtools丰度统计 8 分箱宏基因组binning, MaxBin, MetaBin, VizBin 9 组装assembly和分箱bin结果可视化—Anvio 10 绘制圈图-Circos安装与使用 MetaPhlAn2分析有参宏基因组 11.10 ChIP-seq专题 ChIP-seq基本分析流程 从Richard Young教授的系列研究看超级增强子发现背后的故事 (附超级增强子鉴定代码) 表观遗传小白逆袭之道：从这 19 个视频开始吧！ Bedtools使用简介 2018 升级版Motif数据库Jaspar MotifStack：多motif序列比较和可视化 一文教会你查找基因的启动子、UTR、TSS等区域以及预测转录因子结合位点 AnimalTFDB 3.0 动物转录因子注释和预测的综合资源库 Cell重磅综述：关于人类转录因子，你想知道的都在这 11.11 Linux 全介绍 免费Linux系统和生信宝典原创学习教程 PATH和path，傻傻分不清 Linux - 总目录 Linux - 文件和目录 Linux - 文件操作 Linux - 文件内容操作 Linux - 环境变量和可执行属性 Linux - 管道、标准输入输出 Linux - 命令运行监测和软件安装 Linux - 常见错误和快捷操作 Linux - 文件列太多，很难识别想要的信息在哪列；别焦急，看这里。 Linux - 文件排序和FASTA文件操作 Linux - 应用Docker安装软件 Linux - Conda软件安装方法 Linux - 服务器数据定期同步和备份方式 Linux - VIM的强大文本处理方法 Linux - 查看服务器配置信息 Linux - SED操作，awk的姊妹篇 Linux - 常用和不太常用的实用awk命令 Linux - 那些查找命令 Linux - 原来你是这样的软连接 Bash概论 - Linux系列教程补充篇 Nature Method：Bioconda解决生物软件安装的烦恼 Linux下文件内容更新了文件夹时间戳却没变？ 如何获取目标基因的转录因子（上）——Biomart下载基因和motif位置信息 如何获取目标基因的转录因子（下）——Linux命令获取目标基因TF 生信人写程序1. Perl语言模板及配置 生信人写程序2. Editplus添加Perl, Shell, R, markdown模板和语法高亮 手把手教你生信分析平台搭建 Windows轻松实现linux shell环境：gitforwindows 开启win10内置Linux子程序 Docker的基本使用-Ubuntu18.04 Linux命令screen—终端切换，工作环境保存，画面同步，防断网 Bioconda软件安装神器：多版本并存、环境复制、环境导出 收藏(附中奖信息) | 15 个你非了解不可的 Linux 特殊字符，妈妈再也不用担心我看不懂这些符号了！ 有了这些，文件批量重命名还需要求助其它工具吗？ 软件安装不上，可能是网速慢！Conda/R/pip/brew等国内镜像大全拿走不谢~~ 耗时很长的程序忘加nohup就运行了怎么办？ 11.12 CIRCOS系列 CIRCOS圈图绘制 - circos安装 CIRCOS圈图绘制 - 最简单绘图和解释 CIRCOS圈图绘制 - 染色体信息展示和调整 CIRCOS增加热图、点图、线图和区块属性 11.13 R统计和作图 文章用图的修改和排版 (1) 文章用图的修改和排版 (2) 简单强大的在线绘图 简单强大的在线绘图-升级版 简单强大的在线绘图-第3版 论文图表基本规范 学术图表的基本配色方法 数据可视化基本套路总结 Graphpad，经典绘图工具初学初探 你的包佩奇了吗？试试新版Rstudio，自动提醒缺失包！ 原来Rstudio还可以这么使用，又方便了一些 在R中赞扬下努力工作的你，奖励一份CheatShet 别人的电子书，你的电子书，都在bookdown R语言 - 入门环境Rstudio R语言 - 热图绘制 (heatmap) R语言 - 基础概念和矩阵操作 R语言 - 热图简化 R语言 - 热图美化 R语言 - 线图绘制 R语言 - 线图一步法 R语言 - 箱线图（小提琴图、抖动图、区域散点图） R语言 - 箱线图一步法 R语言 - 火山图 Volcano plot | 别再问我这为什么是火山图 R语言 - 富集分析泡泡图 R语言 - 散点图绘制 R语言 - 韦恩图 R语言 - 柱状图 R语言 - 图形设置中英字体 R语言 - 非参数法生存分析 R语言 - 绘制seq logo图 WGCNA分析，简单全面的最新教程 psych +igraph：共表达网络构建 一文学会网络分析——Co-occurrence网络图在R中的实现 一文看懂PCA主成分分析 主成分分析PCA 富集分析DotPlot，可以服 基因共表达聚类分析和可视化 R中1010个热图绘制方法 还在用PCA降维？快学学大牛最爱的t-SNE算法吧, 附Python/R代码 一个函数抓取代谢组学权威数据库HMDB的所有表格数据 文章用图的修改和排版 network3D: 交互式桑基图 network3D 交互式网络生成 Seq logo 在线绘制工具——Weblogo 生物AI插图素材获取和拼装指导 如何使用AI进行SCI组图 如何使用AI画一个简单的细胞通路图? 一分钟绘制磷脂双分子层：AI零基础入门和基本图形绘制 AI科研绘图（二）：模式图的基本画法 ggplot2高效实用指南 (可视化脚本、工具、套路、配色) 图像处理R包magick学习笔记 SOM基因表达聚类分析初探 利用gganimate可视化全球范围R-Ladies（R社区性别多样性组织）发展情况 你知道R中的赋值符号箭头(&lt;-)和等号（=）的区别吗？ R语言可视化学习笔记之ggridges包 利用ComplexHeatmap绘制热图(一) ggplot2学习笔记之图形排列 R包reshape2，轻松实现长、宽数据表格转换 用R在地图上绘制网络图的三种方法 PCA主成分分析实战和可视化 附R代码和测试数据 iTOL快速绘制颜值最高的进化树！ 12个ggplot2扩展包帮你实现更强大的可视化 编程模板-R语言脚本写作：最简单的统计与绘图，包安装、命令行参数解析、文件读取、表格和矢量图输出 R语言统计入门课程推荐——生物科学中的数据分析Data Analysis for the Life Sciences 数据可视化基本套路总结 你知道R中的赋值符号箭头&lt;-和等号=的区别吗？ 使用dplyr进行数据操作30例 交集intersect、并集union、找不同setdiff R包reshape2，轻松实现长、宽数据表格转换 1数据类型（向量、数组、矩阵、 列表和数据框） 2读写数据所需的主要函数、与外部环境交互 3数据筛选——提取对象的子集 4向量、矩阵的数学运算 5控制结构 6函数及作用域 7认识循环函数lapply和sapply 8分解数据框split和查看对象str 9模拟—随机数、抽样、线性模型 1初识ggplot2绘制几何对象 2图层的使用—基础、加标签、注释 3工具箱—误差线、加权数、展示数据分布 4语法基础 5通过图层构建图像 6标度、轴和图例 7定位-分面和坐标系 8主题设置、存储导出 9绘图需要的数据整理技术 创建属于自己的调色板 28个实用绘图包，总有几个适合你 热图绘制 R做线性回归 绘图相关系数矩阵corrplot 相关矩阵可视化ggcorrplot 绘制交互式图形recharts 交互式可视化CanvasXpress 聚类分析factoextra LDA分析、作图及添加置信-ggord 解决散点图样品标签重叠ggrepel 添加P值或显著性标记ggpubr Alpha多样性稀释曲线rarefraction curve 堆叠柱状图各成分连线画法：突出组间变化 冲击图展示组间时间序列变化ggalluvial 桑基图riverplot 微生物环境因子分析ggvegan 五彩进化树与热图更配ggtree 多元回归树分析mvpart 随机森林randomForest 分类Classification 回归Regression 加权基因共表达网络分析WGCNA circlize包绘制circos-plot R语言搭建炫酷的线上博客系统 维恩(Venn)图绘制工具大全 （在线+R包） R包circlize：柱状图用腻了？试试好看的弦状图 获取pheatmap聚类后和标准化后的结果 增强火山图，要不要试一下？ 一个震撼的交互型3D可视化R包 - 可直接转ggplot2图为3D 赠你一只金色的眼 - 富集分析和表达数据可视化 是Excel的图，不！是R的图 道友，来Rstudio里面看动画了 用了这么多年的PCA可视化竟然是错的！！！ 主成分分析PCA 万能转换：R图和统计表转成发表级的Word、PPT、Excel、HTML、Latex、矢量图等 那天空飘过的梅花月饼，是今年中秋最好的礼物 2019年诺贝尔生理医学奖揭晓 |动图展示历年生理学奖 2019年诺贝尔化学奖揭晓 |八一八，那些年的诺贝尔化学奖 cellassign：用于肿瘤微环境分析的单细胞注释工具（9月Nature） maftools|TCGA肿瘤突变数据的汇总，分析和可视化 ggThemeAssist｜鼠标调整主题，并返回代码 ggcor |相关系数矩阵可视化 这也太简单了吧！一个函数完成数据相关性热图计算和展示 ggcor在微生物生态领域的使用实战​ 昨天的science组合图换方案了 画图手册 | ImageGP：今天你“plot”了吗？ R语言一键批量完成差异统计和可视化 gggenes绘制多物种基因结构比较 数据可视化完美指南-R-python Pathview包：整合表达谱数据可视化KEGG通路 Matplotlib绘制的27个常用图(附对应代码实现) 让你的单细胞数据动起来！|iCellR(一) 让你的单细胞数据动起来！|iCellR(二) Celaref | 单细胞测序细胞类型注释工具 SCENIC | 从单细胞数据推断基因调控网络和细胞类型 R变量索引 - 什么时候使用 @或$ 手把手重现Science的主图Maptree 可视化之为什么要使用箱线图？ Alpha多样性箱线图(样章，11图2视频) 学会这个BBC，你的图也可以上新闻啦！ ggplot2 图区域放大 iheatmapr包：可交互的热图绘制方法 图形解读系列 | 给你5个示例，你能看懂常用热图使用吗？ 一个R包玩转单细胞免疫组库分析，还能与Seurat无缝对接 这个R包自动注释单细胞数据的平均准确率为83％，使用后我的结果出现了点问题|附全代码 一个R包完成单细胞基因集富集分析 （全代码） 11.14 NGS基础和软件应用 OrthoMCL鉴定物种同源基因 （安装+使用） Rfam 12.0+本地使用 （最新版教程） 轻松绘制各种Venn图 ETE构建、绘制进化树 psRobot：植物小RNA分析系统 生信软件系列 - NCBI使用 掌握这个网站，万方、维普、CNKI等众多数据库文献统统可以免费下载！ 拿到基因两眼一抹黑？没关系，先做个基因富集分析吧！ 科研小萌新，掌握这些技巧，轻松玩转各个基因！ 引起相变的无序结构域（IDRs）怎么预测？跟踪热点，提升文章档次！ 如果你经常用PubMed，那么这个插件将非常好用！ 基于人工智能的文献检索，导师查找，更聪明 GeenMedical：文献查询、筛选、引用排序、相似文献、全文下载、杂志分区、影响因子、结果导出、杂志评述、直接投稿，一站服务 如何快准狠地找到相关领域的经典文献？ Excel改变了你的基因名，30% 相关Nature文章受影响，NCBI也受波及 这些基因的名字太有才了，研究一下都可以发10分文章 文献检索新姿势，教你如何直搜文中的科研图片！ Endnote X8云同步：家里单位实时同步文献笔记，有网随时读文献 还在慌？Endnote的个性化文献引用助毕业论文一臂之力 参考文献中杂志名字格式混乱问题一次解决 - 修改style是没用的 参考文献中杂志名字格式混乱问题一次解决 实用网站和在线工具推荐 在线浏览器，在线PS，在线AI，在线编程 … Bioconda软件安装神器：多版本并存、环境复制、环境导出 Gephi轻松绘制超美网络图 微生物组间差异分析神器-STAMP简明教程 中文帮助文档 微生物网络构建：MENA, LSA, SparCC和CoNet FUNGuild：真菌功能注释 在线RaxML构建系统发育树 MetaboAnalyst 4.0，代谢组学研究利器的升级 RepeatMasker：基因组重复序列注释 基因组注释 1重复序列 2非编码和编码基因 3功能注释Prokka cellassign：用于肿瘤微环境分析的单细胞注释工具（9月Nature） NBT|45种单细胞轨迹推断方法比较，110个实际数据集和229个合成数据集 NC |SCALE准确鉴定单细胞ATAC-seq数据中染色质开放特征 截屏工具千千万，用了这个不舍得换 内存小还免费，Adobe Acrobat表示有危机 Nicetools：定一个小目标，先做它个1000个工具 20W+喜爱的Pathview网页版 | 整合表达谱数据KEGG通路可视化 中科院遗传所课题组开发高质量基因组组装软件 中科院研究组新建一种高敏高精度的RNA poly(A)尾巴检测技术 CIRIquant：circRNA定量和剪接体转换识别 超详细的GEO数据上传攻略，一看就会 遇到这个工具前我都是建议文章写好就先投Cell？ iBiology |除了B站，这还有个专业的生科科普网站 嗐，别的95后一天两登Nature，你却还不知道有一款工具可以帮你校对英文文稿和回复审稿意见 11.15 生信宝典之傻瓜式 生信宝典之傻瓜式 (一) 如何提取指定位置的基因组序列 生信宝典之傻瓜式 (二) 如何快速查找指定基因的调控网络 生信宝典之傻瓜式 (三) 我的基因在哪里发光 - 如何查找基因在发表研究中的表达 生信宝典之傻瓜式 (四) 蛋白蛋白互作网络在线搜索 生信宝典之傻瓜式 (五) 文献挖掘查找指定基因调控网络 生信宝典之傻瓜式 (六) 查找转录因子的靶基因 挖掘PubMed数据库，获取报道的或推测新的基因调控关系 Cytoscape教程1 Cytoscape之操作界面介绍 新出炉的Cytoscape视频教程 Cytoscape制作带bar图和pie图节点的网络图 Cytoscape: MCODE增强包的网络模块化分析 知乎阅读三百万的生信学习指南 当我们谈论生信的时候我们在谈什么 如何使用AI画一个简单的细胞通路图? 11.16 Python Python极简教程（一） Python极简教程（二） Python极简教程（三） Python极简教程（四） Python极简教程（五） Python极简教程（六） Pandas，让Python像R一样处理数据，但快 Python解析psiBlast输出的JSON文件结果 为啥我的Python这么慢 - 字符串连接 (一) 为啥我的Python这么慢 - 项查找 (二) Python学习 - 可视化变量赋值、循环、程序运行过程 Python资源 关于Python中的__main__和编程模板 莫烦Python机器学习 编程新手入门踩过的25个“坑”，你犯过其中哪些错误？ Python文学化编程 - Jupyter notebook使用和插件拓展 Python3中正则表达式使用方法 Python3中BeautifulSoup的使用方法 我用Python开发了个SCI-HUB本地版 手把手 哇！用R也可以跑Python了 Bioconda软件安装神器：多版本并存、环境复制、环境导出 还在用PCA降维？快学学大牛最爱的t-SNE算法吧, 附Python/R代码 Python没有捷径，但可以加速，零基础九天你也可以会编程 小学生都学Python了，你还不知道怎么开始*资源帖 一个月学会Python的Quora指南和资料放送 推荐一个牛逼的生物信息 Python 库 - Dash Bio Matplotlib绘制的27个常用图(附对应代码实现) Python语法糖之：列表解析、集合解析和字典解析 入门课的入门课，微软推出Python零基础教程，基于原生VS Code 11.17 Cytoscape网络图 Cytoscape教程1 Cytoscape之操作界面介绍 新出炉的Cytoscape视频教程 Cytoscape制作带bar图和pie图节点的网络图 Cytoscape: MCODE增强包的网络模块化分析 11.18 分子对接 来一场蛋白和小分子的风花雪月 《自然》重磅：迄今最大规模人类蛋白互作组诞生 不是原配也可以-对接非原生配体 简单可视化-送你一双发现美的眼睛 你需要知道的那些前奏 11.19 文献精读 Nature重磅综述 |关于RNA-seq，你想知道的都在这 知乎阅读三百万的生信学习指南 2018年生信宝典阅读最高文章Top10 数学好真的可以为所欲为啊！论一个你不知道的学科-数理生物学 这些基因的名字太有才了，研究一下都可以发10分文章 人类多能性干细胞研究20周年：起始于5个细胞系，我们未来20年的进步将取决于我们现在做的 许多癌症的发生只是概率问题 专访约翰·霍普金斯大学病理系主任拉尔夫·赫鲁班 肿瘤化疗无效是对预先存在的突变的选择还是诱发新突变，Cell给你答案 “人鸡胚胎”破解生命起源奥秘，百年来首次证实“组织者”存在于人体 ｜《Nature》发表重磅论文 被高中生物骗了这么多年，原来人体内细胞的DNA是有不同的？ 周琪院士正面回应：60万一针有用吗？（干细胞治疗） CRISPR-CAS9发展历程小记 一场大病引起的诺贝尔2017年生理学奖角逐 Science搞反狗脑 - 人脑和狗脑一样？ 一篇压根不存在的文献被引用400次？！揭开” 幽灵文献” 的真面目 YANDEX搜索，不翻墙稳定使用近谷歌搜索 Nature我的研究对后人毫无用途：21%的学术论文自发布后从未被引用 SCI-HUB镜像, SSH隧道访问学校内网 为了速成生物学，一位程序员探索了”爆款”基因背后的秘密 Nature邀请6位专家为您支招如何写出一流论文？ Cell：荧光标记out了，AI不用“侵入”也能识别细胞死活和类型 如果你经常用PubMed，那么这个插件将非常好用！ 生物研究中不可缺少的数字概念，多少，多大，多快 王秀杰研究组合作发现m6A修饰在小脑发育中的新功能 （附2018上半年m6A研究文章和点评） 把人类宝宝和黑猩猩幼崽一起养大，会发生什么有趣的事情呢？结局可能是有些出乎意料的～～ 你体内的细胞“成精了”？居然还互相看对了眼？ 父爱无言！科学家首次发现来自爸爸的基因，可以通过胎儿来控制妈妈对宝宝的爱 饿死癌细胞？还是先看看肿瘤中的异常代谢的特征分析和背后的遗传与环境互作吧！ 2018Cell系列最好的调控方式-相变，最强综述，未来以来，你在哪 2018“不务正业”的化学奖又发给了生物 2018美日科学家因免疫治疗得诺贝尔生理医学奖-动图展示历年生理学奖 Nature综述-整合组学分析护航健康，推动精准医学时代的到来！ 勤能补拙，过目不忘，提高m6A助力好记性？中科院王秀杰/杨运桂合作最新成果 综述：变温动物的适应性免疫 你的DNA都会玩摇滚了，你却还是个音痴 “乱搞”的动物可能只是脸盲？新研究发现24个基因决定动物“忠诚度” 经常喜欢熬夜？也许你天生就是“夜型人”基因！ 基因编辑婴儿违规，预防艾滋还是了解下啪啪啪为何会传染（视频） 读趣味漫画了解生物技术的发展与应用 颠覆！垃圾DNA不是垃圾！活细胞成像实时演绎基因调控全过程！ Nature重磅！肥胖有救了：分析了362499个人，发现了98个与肥胖相关的遗传信号，其中29个是第一次发现 当细胞生物学遇上计算机思维，会产生什么样的火花？ 整天泡实验室已经out了，会写代码才是不被淘汰的关键 Science文章背靠背揭示癌症中细胞感应氧气的新机制 跟随美国博导12年，我学到最深刻的不是科研，而是这个。。。 用PCR之歌怀念PCR之父凯利·穆利斯：生物学从此人分为PCR之前，PCR之后 最会数据分析的护士！全世界最有名的白衣天使是如何走上可视化之路的？ 她的癌细胞救了上亿条命，却很少有人知道她的名字 NCB|心咽发育多样化的单细胞转录轨迹分析 学生说 |当代硕博生常犯错觉图鉴 整合基因组学和蛋白质结构的致病机制分析 万能转换：R图和统计表转成发表级的Word、PPT、Excel、HTML、Latex、矢量图等 这个Nature推荐的代码海洋竟然有文章作者上传的所有可重现性脚本，涉及单细胞、微生物组、转录组分析、机器学习等相关 iBiology |真·免费的最好生物科学知识盛宴 2019年诺贝尔生理医学奖揭晓 |动图展示历年生理学奖 2019年诺贝尔化学奖揭晓 |八一八，那些年的诺贝尔化学奖 DNA metabarcoding: 条形码的追踪饮食摄入之路 你转发的四倍体锦鲤还好吗？NC首次鉴定出异源四倍体鱼类的祖先二倍体并成功进行亚基因组拆分 RNA-seq最强综述名词解释&amp;思维导图|关于RNA-seq，你想知道的都在这（续） 美国科学院公布未来10年农业发展的五大方向，生物信息和微生物组占两项！ Cell 单细胞文章 | 白凡课题组与合作团队揭示儿童结肠炎及炎症性肠病的致病机制及治疗方法 在论文修改了5次之后，院士作者终于怼了“不共戴天”的审稿人 城市里的穷人最容易“喜当爹”，但概率也没你想得那么高 国际顶刊《PNAS》：爱发朋友圈的人，更容易长寿 你在办公室呼吸的每口空气，都有来自同事洗发水的污染物 Nature重大发现：癌基因竟不在染色体上？第一作者吴思涵亲身解读！ Cell子刊 | 植物单细胞转录组综述·植物功能基因组学的高分辨率研究方法 Cell子刊 | 肠内分泌细胞单细胞测序分析（附资源库传送门） 这篇5分文章不做实验，纯数据挖掘发现调控乳腺癌细胞增殖与预后的关键蛋白激酶 Science：请注意了，当人们讲话用到这个词时，可能是在描述负面体验！ 比较基因组学揭示海洋最深鱼类嗅觉的适应性进化 还以为”猪脑子”是在骂人？这篇文章告诉你，猪的智商高到爆表 纳尼？Genbank中超200万条序列受污染！蛋白污染主要来源于一只蜘蛛？ 实验和检测技术带来的高假阳性乌云：6mA是否真的在哺乳动物中广泛存在？ 众志成城 - 财经、医学、数学、古脊椎多领域团队19文解析新型冠状病毒 - 起源、传播、防控 - 为决策助力 因为2万人自愿被感染，首个人类冠状病毒才被发现 电脑仿真程序揭秘：为何现在还不能出门？ 既没新样本，也没实验，如何猜到新冠病毒“喜欢”感染哪些细胞？ 再添力证，还是穿山甲！管轶教授从被走私的穿山甲中发现新冠病毒 中国人是否对新冠病毒更易感？ 你的大脑、肝脏和肠胃，都是“傻帽”？ 蚯蚓不生活在水中，鱼为什么喜欢吃它？ Cell|严景华/齐建勋首次发现新冠病毒进入细胞的详细分子细节 香港大学做了三个新冠病毒重磅实验，信息量很大… 史上最完善人类新陈代谢谱系模型登上《科学》封面！支持3D交互 中山大学骆观正教授 | 核酸修饰的鉴定和编辑技术前沿综述 （全文翻译版） 当细胞生物学遇上计算机思维，会产生什么样的火花？ 漫画科普：陈玲玲研究组发现长非编码RNA种属特异性加工决定其功能差异 一口气看够人类染色体故事，痛快！ NatureGenetics：所有五个异源四倍体棉花起源被厘清 吃了一辈子大米，你还在相信水稻种水里是因为喜欢水？ Nature Communications | 白凡研究组揭示结直肠癌近端淋巴结与远端器官的转移路径 JAMA子刊：20来岁就要控制体重！分析超8万中国人数据发现，成年到中年体重每多增加10斤，老了之后死亡风险增加10% BMJ二十年最火论文：性行为时生殖器会变成什么样子？ 结肠癌个性化治疗新手段——基于类器官的Cas9筛选平台 | Cell Press 青促会述评 智商随妈，性格随爸？遗传学家们找到了这些证据 人类细胞图谱计划发起人Aviv Regev博士讲单细胞基因组学 获得诺贝尔奖之后影响力会下降？绘制精英科学家的职业生涯路线图 11.20 2019的高阅读文章合集 跟随美国博导12年，我学到最深刻的不是科研，而是这个。。。 用PCR之歌怀念PCR之父凯利·穆利斯：生物学从此人分为PCR之前，PCR之后 著名养生专家因病逝世，享年59岁，寿命基因决定还是养生决定？ 最新发表的这篇《细胞》论文，颠覆了太多认知…… 保护导师，从我做起；爱护博导，人人有责 这个只需一步就可做富集分析的网站还未发表就被CNS等引用超过350次 是Excel的图，不！是R的图 SCI-HUB客户端（文献神器V4.0）——下载文献如此简单 2019影响因子分享下 增强火山图，要不要试一下？ Volcano plot | 别再问我这为什么是火山图 Science组合图表解读 《自然》：真是绝了！科学家发现癌细胞竟会把自己伪装成比正常细胞健康的“赢家”，然后通过未知手段干掉健康的邻居 | 科学大发现 无需写代码的高颜值富集分析神器 一个震撼的交互型3D可视化R包 - 可直接转ggplot2图为3D 博士出身好科研产出高，学术谱系真的可以决定一切吗？ 研究基因50年后，这位院士说基因决定了智力，别操心育儿了 原来Rstudio还可以这么使用，又方便了一些 综述之我的十年本硕博生活 万能转换：R图和统计表转成发表级的Word、PPT、Excel、HTML、Latex、矢量图等 “你都硕士博士了，竟然还不如我！” Manuscript match— 找到最适合你文章的那个ta（之期刊杂志） 这个Nature推荐的代码海洋竟然有文章作者上传的所有可重现性脚本，涉及单细胞、微生物组、转录组分析、机器学习等相关 当我们谈论生信的时候我们在谈什么 Nature重磅综述 |关于RNA-seq，你想知道的都在这 RNA-seq最强综述名词解释&amp;思维导图|关于RNA-seq，你想知道的都在这（续） 美国科学院公布未来10年农业发展的五大方向，生物信息和微生物组占两项！ 在论文修改了 5 次之后，院士作者终于怼了“不共戴天”的审稿人 国际顶刊《PNAS》：爱发朋友圈的人，更容易长寿 如何判断一个人是不是真的博士？ BMJ二十年最火论文：性行为时生殖器会变成什么样子？ 11.21 精选文章推荐 Nature重磅综述 |关于RNA-seq，你想知道的都在这 知乎阅读三百万的生信学习指南 宏基因组分析教程 微生物组入门必读+宏基因组实操课程 Nature综述：大佬手把手教你分析菌群数据 Nature综述：微生物构成的氮循环网络 Nature替宠物正名：宝宝身体好，猫狗不可少 DNA提取也能发Nature？ 学术论文图表基本规范大全 Microbiome：中国科学家完成鸡肠道微生物宏基因集的构建(张和平、魏泓、秦楠点评) 一片看懂肠道菌群在人体中的作用 岛国科普—生命大跃进 人体上的生命：看完此片我想把身上的细菌寄生虫供起来 3分和30分文章差距在哪里？ 28个实用绘图包，总有几个适合你 你想要的生信知识全在这—生信宝典 NB：实验vs分析，谁对结果影响大 NC：16S序列预测培养基配方 Cell：人与肠道菌群休戚与共的一生 35张图，看懂肠道和大脑的魔性关系 深度好文—我们的未来在哪里？ 宏基因组领域杂志简介及最新影响因子 学术图表的基本配色方法 手把手带你重现菌群封面文章图表 79个超强微生物知识助你孕育超优宝宝 漫谈16S的前世今生 16S+功能预测发Sciences Nature：宏基因组关联分析 Nature: 宏基因组关联分析-深入研究微生物组 Nature：肠道菌群如何划分肠型 一条命令轻松绘制CNS顶级配图-ggpubr Co-occurrence网络图在R中的实现 一文读懂宏基因组分析套路 简单漂亮的在线生信绘图工具 一文读懂微生物组 生信9天速成班—成为团队不可或缺的人 进化树 一文读懂 Evolview基础 Evolview进阶 iTOL美化 iTOL进阶 自学生信-biostar handbook 当我们谈论生信的时候我们在谈什么 你转发的四倍体锦鲤还好吗？NC首次鉴定出异源四倍体鱼类的祖先二倍体并成功进行亚基因组拆分 机器学习爱好者必读的入门指南 14岁的男孩说想学生信，应该给予哪些指导？ 美国求学执教的见闻和感受，又是一场“北京人在纽约”？ 神操作，为了让孩子上个好大学，学术论文里把孩子列为作者… 灵长类胚胎体外培养的“14天规则”是否应该修改？ Cell 单细胞文章 | 白凡课题组与合作团队揭示儿童结肠炎及炎症性肠病的致病机制及治疗方法 在论文修改了 5 次之后，院士作者终于怼了“不共戴天”的审稿人 BMJ二十年最火论文：性行为时生殖器会变成什么样子？ PATH和path，傻傻分不清 R变量索引 - 什么时候使用 @或$ Volcano plot | 别再问我这为什么是火山图 中国人是否对新冠病毒更易感？ ISME Journal | 气候变化可通过肠道菌群影响鼠类生长及其种群变化 11.22 科研经验 如何优雅的提问 公众号搜索方法大全 如何第一时间了解研究领域最新动态? 科研团队成长三部曲：1云笔记 2云协作 3公众号 文献阅读 1热心肠 2SemanticScholar 3geenmedical 猫咪论文 生信编程模板 Perl Shell R 生物信息之程序学习 论文Figures，你不能不知道的秘密 原始数据极速上传NCBI SRA教程 Endnote X8云同步：有网随时读文献 Excel绘图新高度-EasyCharts 你和PPT高手之间，就只差一个iSlide 如何让你的PPT出彩？掌握这一个技能也就足够了！ Windows10远程桌面Ubuntu R，Git和Github代码备份和版本管理 上 下 2018谷歌学术指数——综合、生物、生信、微生物领域高引文章和杂志 Excel改变了你的基因名，30% 相关Nature文章受影响，NCBI也受波及 适合做生物信息的笔记本推荐 求求你使用Tab键好吗 整合基因组学和蛋白质结构的致病机制分析 七龙珠|召唤一份单细胞数据库汇总 Nature重磅综述 |关于RNA-seq，你想知道的都在这 你转发的四倍体锦鲤还好吗？NC首次鉴定出异源四倍体鱼类的祖先二倍体并成功进行亚基因组拆分 DNA metabarcoding: 条形码的追踪饮食摄入之路 机器学习爱好者必读的入门指南 14岁的男孩说想学生信，应该给予哪些指导？ 美国求学执教的见闻和感受，又是一场“北京人在纽约”？ ggcor |相关系数矩阵可视化 截屏工具千千万，用了这个不舍得换 一篇所有研究生都该读的好文：阳光温热 科研静好 在论文修改了 5 次之后，院士作者终于怼了“不共戴天”的审稿人 如何判断一个人是不是真的博士？ 这个网站，搞学术的人错过太遗憾了！ 大多数人都不知道，人类基因组正在衰败 笑翻了！想象的论文答辩和真实的论文答辩 六位女科学家谈过往：四五十岁了没成果还能做研究吗？怎么确定自己是否适合科研？ 中国科学院的100多家科研院所都在研究什么？ 学术造假都能投SCI，凭什么民科就要被嘲笑？因为实在太好笑了… Science：请注意了，当人们讲话用到这个词时，可能是在描述负面体验！ BMJ二十年最火论文：性行为时生殖器会变成什么样子？ 那些年，顶级期刊和国风碰撞过的“图说” 博士毕业将更加困难？SCI评价改革带来的喜与忧 你的大脑、肝脏和肠胃，都是“傻帽”？ 宏基因组数据提交GSA实操手册—发表文章前必备技能 超详细的GEO数据上传攻略，一看就会 本科、硕士、博士的区别 105万篇博士论文数据，勾画学术界30年的知识变迁 博士学位真的那么重要吗？上交大博士亲述科研心路，获4万高赞，网友：这是知乎最好的回答 嗐，别的95后一天两登Nature，你却还不知道有一款工具可以帮你校对英文文稿和回复审稿意见 师妹越多，团队集体智慧越高，当占比80%时，达到巅峰 日读论文100+，AI都替代不了！辞去医药研发总监后，她成为了一名全职学术警察 11.23 软件和数据库 Gephi轻松绘制超美网络图 在线浏览器，在线PS，在线AI，在线编程 微生物组间差异分析神器-STAMP简明教程 中文帮助文档 微生物网络构建：MENA, LSA, SparCC和CoNet Cytoscape: MCODE包实现网络模块化分析 Cytoscape制作带bar图和pie图节点的网络图 FUNGuild：真菌功能注释 在线RaxML构建系统发育树 MetaboAnalyst 4.0，代谢组学研究利器的升级 Genevestigator: 查找基因在发表研究中的表达 psRobot：植物小RNA分析系统 RepeatMasker：基因组重复序列注释 基因组注释 1重复序列 2非编码和编码基因 3功能注释Prokka Linux命令screen—终端切换，工作环境保存，画面同步，防断网 Nature Method：Bioconda解决生物软件安装的烦恼 数据的质量控制软件——fastQC 极速的FASTQ文件质控+过滤+校正fastp SpatialDB |单细胞空间转录组数据分析可视化平台 截屏工具千千万，用了这个不舍得换 NAR | 李磊课题组与杨效曾课题组构建植物miRNA数据库 20W+喜爱的Pathview网页版 | 整合表达谱数据KEGG通路可视化 增强版文献检索利器，免费下载高质量文献！ 一个函数抓取代谢组学权威数据库HMDB的所有表格数据 分享一个完美的工具：多数据库集合，研究基因组学癌症必备 TISIDB：这个科研工具能助你顺利发高分肿瘤免疫文章 植物激素分析平台| 褚金芳团队在植物激素分析技术研究中取得新进展 11.24 扩增子分析 扩增子图表解读-理解文章思路 扩增子分析流程-把握分析细节 扩增子统计绘图-冲击高分文章 QIIME2中文教程-把握分析趋势 16S功能预测 0概述 1KO通路PICRUSt 2元素循环FAPROTAX 3表型bugbase 4KO通路Tax4Fun 水稻微生物组时间序列分析 1模式图与PCoA 2a相关分析 2b散点图拟合 3冲击图 4随机森林回归 9个模块＋40余款软件＋老司机辣评 16S信息分析流程软件和数据库合集 Nature Method ：Rob Knight发布Striped UniFrac算法轻松分析微生物组大数据 01-背景介绍 02-真菌引物选择 MicrobiomeAnalyst：可视化微生物组网页工具 NAR：gcMeta——全球微生物组数据存储和标准化分析平台 NAR：rrnDB-16S拷贝数校正数据库 METAGENassist帮你搞定宏基因组分析的图形需求 SILVAngs:16S/18S在线分析1 2 扩增子分析神器USEARCH 简介 v11新功能 v11命令大全 OTU表抽平otutab_rare 核心OTU鉴定otutab_core 扩增子分析神器VSEARCH 分析流程 2.8.1中文帮助文档 微生物扩增子数据库大全 SourceTracker—微生物来源分析 DNA metabarcoding: 条形码的追踪饮食摄入之路 IF:10.465 | 苏铁类植物微生物相的扩增子16S分析 ggcor在微生物生态领域的使用实战​ Cell Research | 华农解析水虻基因组图谱和肠道微生物组降解规律 Fungal Diversity | 70位作者共同修订真菌界担子菌门分类系统 Nature：​肠道微生物通过代谢调节人体肠道免疫 11.25 宏基因组分析 宏基因组分析教程 1简介-定义、方法和数据库 2扩增子-微生物群落多样性 3PICRUSt功能预测 4宏基因组物种组成和分箱 5宏基因组功能数据库与通路 6宏转录组流程和功能 7挖掘微生物组生物标记 4500元的微生物组培训资料 微生物组助手——最易学的扩增子、宏基因组分析流程 GigaScience：ASaiM基于Galaxy微生物组分析框架 斯坦福大学统计系教授带你玩转微生物组分析 一文读懂宏基因组binning 30余款宏基因组分析软件经验总结上 中 下 微生物组学数据分析工具综述 16S+宏基因组＋宏病毒组＋宏转录组 Nature Protocols：整合宏基因组、代谢组和表型分析的的计算框架 MetaPhlAn2一条命令获得宏基因组物种组成 Nature Method：HUMAnN2实现宏基因组和宏转录组种水平功能组成分析 HUMAnN2：人类微生物组统一代谢网络分析2 宏基因组有参流程Metagenomics Tutorial (HUMAnN2) 1背景知识-Shell入门与本地blast实战 2数据质控fastqc, Trimmomatic, MultiQC, khmer 3组装拼接MEGAHIT和评估quast 4基因注释Prokka 5基于Kmer比较数据集sourmash 6不比对快速估计基因丰度Salmon 7bwa序列比对, samtools查看, bedtools丰度统计 8分箱宏基因组binning, MaxBin, MetaBin, VizBin 9组装assembly和分箱bin结果可视化—Anvi’o 10绘制圈图-Circos安装与使用 KEGG在线数据库使用攻略 NAR-2018-dbCAN2鉴定宏基因组CAZYome碳水化合物相关基因 EggNOG功能注释数据库在线和本地使用 antiSMASH：微生物次生代谢物基因簇预测 Microbiome：宏基因组分箱流程MetaWRAP 简介 安装和数据库部署 实战和结果解读 Krona绘制物种或功能组成圈图 microbiomeViz：绘制lefse结果中Cladogram MMinte：预测微生物群体内代谢物互作 手把手重现Science的主图Maptree 11.26 实验设计与技术 微生物组取样和DNA提取建议 样品生物学重复数据选择 1必要性 2需要多少重复？ 样品命名 注意事项 实例 扩增子引物选择 16S结构 16S单V4区是最佳选择? 引物评估 海洋可培养微生物的鉴定与分类 怎么取粪便样品 根际土Rhizosphere/Rhizoplane如何取 Microbiome: 室温存储样本方法比较 Nat. Biotechnol.：高通量测序16S及18S rRNA全长 两种土壤细菌群落结构高通量绝对定量方法 MiBioGen联盟倡议：综合分析人类基因组与菌群关系研究 Microbiome：16S扩增子测序研究中定量变异和生物量影响 有声专栏-宏基因组专业词汇—001宏基因组 Microbiota, metagenome, microbiome傻傻分不清 16S测序，不知道OTU你就out了！ 扩增子分析还聚OTU就真OUT了 主流非聚类方法dada2,deblur和unoise3介绍与比较 计量宏基因组学数据分析的方法及进展 排序方法比较大全PCA、PCoA、NMDS、CCA Adonis和ANOSIM方法组间整体差异评估原理 PCoA距离算法大全 读懂PCA和PCoA LEfSe分析，你真的懂了么 宏基因组基础知识梳理 功能基因多样性研究概述 扩增子SCI套路 1群落结构差异 2组间差异 3总结 环境因子关联分析—CCA还是RDA P值背后那些事儿 轻松看懂机器学习十大常用算法 一文读懂随机森林在微生态中的应用 你想知道的ROC曲线 相关分析：Spearman、Kendall和Pearson 学习全基因组测序数据分析 1测序技术 2fasta&amp;fastq 机器学习爱好者必读的入门指南 11.27 文献精读 Microbiome：中国科学家完成鸡肠道微生物宏基因集的构建(张和平、魏泓、秦楠点评) Gut：人体最初的微生物起源与生殖健康 孕期健康对孩子至关重要 Microbiome：土壤微生物驱动退耕还林系统土壤剖面的养分循环 BA：根际微生物组提高植物耐盐性的研究进展 PC: 陈峰等纵论口腔菌群何以影响全身 SBB：石油污染土壤微生物群落构建与生物多样性研究 SCLS：水稻微生物组时间序列分析 中国微生物组计划—农作物微生物组 应用生态学报：东北黑土区不同纬度农田土壤真菌分子生态网络的比较 Sciences：用膳食纤维”钓”出15株缓解糖尿病的细菌！ Nature: 来自细菌的通告——群体感知效应 Nature：皮肤微生物群-宿主相互作用 Nature综述：人类微生物培养及培养组学culturomics NRM: 蓝藻水华的形成机理及防治动态 NRM: 拥抱未知-解析土壤微生物组的复杂性 NRM: 追“根”溯源：植物根际的微生物生态 NRM 关键物种对于微生物菌群结构和功能的驱动作用 NRM：多年冻土的微生物组 Nat Rev Gastroenterol Hepatol: 给医生的菌群分析指南上 下 PNAS: 干旱延缓高粱根系微生物组的建成并富集革兰氏阳性菌 NAR：MicrobiomeAnalyst微生物组分析师——统计、可视化和元分析微生物组数据的网页工具 Nature综述：微生物的社交网络 - 营养缺陷型如何塑造复杂群落 Cell综述：人类肠道菌群-从关联到调控 Cell: 宏基因组学成为病毒分类新方法 Nat Rev Microbiol：呼吸道菌群—呼吸道健康的守门人 Nat. Plant: 可持续农业生态系统中的核心微生物组 Cell：代谢控制中的脑肠轴 Cell:人体肠道细菌与自身细胞的比例究竟是多少？ COM: 土壤微生物组——从宏基因组学到宏表型组学 Ann. Rev.：植物微生物组—系统见解与展望 Ann. Rev.：微生物组与人 微生物组学与植物病害微生物防治 组学重建真菌现有分类系统 FEMS: 森林微生物组多样性，复杂性和动态变化 Nature Microbiology: 微生物数据的系统发育分析方法 Protein&amp;Cell解析宿主基因组和微生物的复杂互作 Microbiome植物内部微生物的相互作用 微生物组学研究的可再现性、可重现性、稳定性与普适性 TPS：植物相关微生物群在传统草药中的作用 Nature Microbiology：微生物与海洋全球变化 NBT：根际微生物组抗番茄枯萎病 Nature：益生菌清除致病菌的机制 科普：原来益生菌是这么搞定致病菌的 Nature: 高通量细菌分离培养鉴定 Nature：根系菌群参与磷胁迫和免疫的平衡 Nature: EMP揭示地球多尺度微生物多样性 Nature：环境vs基因，谁对肠道菌群影响更大？ Nature：人类肠道微生物组的肠型 Nature：如何做一篇肠道菌群免疫的顶级文章-高盐与高血压 Nature：肠道菌群代谢物调节肠道与免疫 Nature: 拟南芥根微生物组的结构和组成 Nature: 地球上最古老的热液喷口发现早期生命迹象 Nature: 甘露糖苷选择性抑制致病性大肠杆菌 Nature：乙酸盐通过介导微生物-脑-β细胞轴促进代谢综合征 Nature：人工甜味剂改变小鼠肠道菌群组成及功能 Nature：土壤细菌具有多种合成次级代谢物的基因 Nature: 海洋病毒对环境基因组和潜在的生物地球化学影响 TM：宏基因组学揭示海洋微生物及其病毒的生态学 Nature综述：宏基因组时代的病毒分类 Nature：全球表层土微生物组群落结构和功能 Nature-2018-抗菌药物组合有望特异性治疗耐多药性的细菌感染 Nat. Genet.：微生物如何适应植物的？ 评论 正文 NBT: 宏表观组—DNA甲基化辅助宏基因组binning NM: 宏基因组软件评估—人工重组宏基因组基准数据集 NC.：降低微生物群落复杂度突破组装难题 NC：宏基因组学提示曙古菌门的代谢和进化(中大李文均组) NM：植物根系分泌物影响菌群结构 NM：丰度决定了细菌在复杂群落中的功能作用 CHM:小肠菌群与脂肪的消化和吸收密切相关 GigaScience:植物MWAS研究—谷子产量与微生物组关联分析 Microbiome：微生物组研究中你必须注意的细节 Microbiome：土壤微生物驱动退耕还林系统土壤剖面的养分循环 Microbiome：HiSeq平台16S扩增子文库构建方法 Microbiome：植物根际微生物组也有昼夜节律 Microbiome: 简单套路发高分文章–杨树微生物组 Microbiome: 植物生态位和基因型对微生物的影响 Microbiome：肠道菌群失衡促进高血压 Microbiome：重新定义“卫生”概念 Microbiome: 绝对定量环境样本细菌、真菌、真核群落丰度 Microbiome: 培养组学对已分离人类细菌和古菌物种库的贡献 Microbiome：空间尺度对华北平原麦田土壤细菌群落的影响(南土所褚海燕组) Microbiome: 黄龙病破坏柑橘根部相关微生物菌群从根际到根面的富集过程 Microbiome：在人工肠道中建立动态线性模型指导设计和分析微生物组研究 Nat. Med.:菌群与疾病的关：先有鸡还是先有蛋？ NM: 四分之一常用的非抗菌药物，居然也会抑制人体肠道菌群？ Science: 肠道微生物可以转移到肝脏促进先天性免疫疾病发生 Science：肠道菌群介导胆汁代谢通过NKT细胞调控肝癌 Science：微生物群落的构建过程具有趋简性 Gut-2018-菌群标志物有望诊断早期肝癌 PPT和视频讲解 Gut-口腔微生物可以预测直肠癌 Cell子刊：碳水化合物限制饮食对人类肝脂肪变性的快速代谢益处的综合理解 看“低碳饮食“大法如何降低肝脏脂肪 PNAS：水稻微生物组 PNAS-2018-病原菌在植物免疫下的转录组 PNAS-2018-根系分泌物香豆素调控微生物群落结构并促进植物健康 PNAS-2018-玉米根际的大规模田间重复研究确定可遗传的微生物 方法解读 PNAS-2017-人工构建玉米极简微生物组 PNAS: 儿童生长发育迟缓 = 长期饥饿？ ISME宏转录组揭示参与深海碳氮循环的微生物 PLOS Biology: 发现一种固氮玉米 PBio-2018：如何设计可预测植物表型的微生物组 npjsba-2018-用肠道微生物模型指导个性化膳食缓解局部性肠炎 SBB：长期施肥影响土壤固氮菌的群落装配过程 11.28 科普视频*寓教于乐 一席-赵立平-大树细菌 肠道—刘洋彧-建肠道菌群生态网络 CCTV9让尸体说话-法医密档 走进科学：枯草芽孢杆菌替代畜牧业抗生素添加 走进科学：锄禾者新说 NHK再造人类生命的神奇细胞 NHK一片看懂肠道菌群在人体中的作用 NHK生命大跃进 BBC人体奥秘之细胞的暗战 BBC人体奥秘Inside.the.Human.Body NGC人体内旅行Inside.the.Living.Body NGC子宫日记Womb 原来益生菌是这么搞定致病菌的 CNS接连发文背书，原来生姜这么神奇 漱口水增加糖尿病，高血压风险 一顿寄生虫大餐，或能治好干净引来的免疫病 致命病毒为何疯狂袭击人类？ 马铃薯晚疫病：引发百万人死亡和逃难 看完这些能控制大脑的寄生虫，你会怀疑人类！ 考拉：你以为我想呆萌？幼年吃屎长大磕毒，差点就没活下来 盘尾丝虫病——河盲症 结核菌——抗药性的严峻形式 粘菌会走迷宫规划交通路线-重定义智能 水痘痊愈就能终生免疫？其实病毒仍潜伏在神经 噬菌体的前世今生 乙肝疫苗的故事，居然有人体实验 他发现了疟疾的元凶，开创了致病生物研究新时代 谁来养活中国人？他用小麦增产千亿斤让中国成为粮食大国 感染这种随处可见的“食脑虫”，你可能必死无疑 机洗内裤容易得暗病？这个锅我们袜子不背！ 西游记里河水让人怀孕的秘密：是寄生虫！ 超级细菌事不关己？看完它才发现我们都在自己身体里养蛊 抠出来的鼻屎不要丢，隔壁家的小孩都馋哭了 谁说被吃是鸡的宿命？这只鸡长了个价值三个诺奖的肿瘤 3个月近30万上海人被感染，真相是潜伏已久的“吃祸” 大肠杆菌O157:H7——仅次于霍乱的致命腹泻，正跟着“吃草”潮流全球“开花” 皮肤共生菌可以促进伤口愈合 轻断食是一种科学的减肥方法吗？ 脂肪肝，应该拿你怎么办 想更易怀孕，生更多娃？男人去打猎，女人靠蛔虫？！ 吃寄生虫能治病？又来涨知识吧！ 减肥难？别急，精准调控细菌的方法已横空出世！ 想知道自己能不能长命百岁？窝个粑粑测个菌？ 饮食、生物钟、肠道菌群的“三角恋” 艾滋病交响诗 被传染艾滋 梅毒狂想曲 厌氧君和好氧君谁是明日之子 Nature: 你的肠道菌群是遗传自你父母还是后天 Cell: 为了PK抗生素而服用益生菌？后果竟然如此严重 11.29 系列宣传 转录组分析的正确姿势 120分的转录组考题，你能得多少 维密摔倒不可怕，关键时有人搀一把，坚持走下去 生物信息作图系列 R、网络图及文章图形排版 易生信转录组培训总结和优惠分享 生物信息9天速成班 — 你也可以成为团队不可或缺的人 Python没有捷径，但可以加速，零基础九天你也可以会编程 小学生都学Python了，你还不知道怎么开始*资源帖 一个月学会Python的Quora指南和资料放送 扩增子分析基本流程和结果解读 微生物组——扩增子分析专题实战开课啦 如何入门生信Linux 3分和30分文章差距在哪里？ 生信必备Linux培训，助您扎好根基 表观调控高通量测序分析培训开课啦 让你学了一次还想参加后续课程的实战班是什么样？ 二代三代转录组测序分析实战班 谈谈数次生信线下活动的收获和体会 转录组课程以旧换新 4天你也可以自己处理二代三代转录组测序数据 （可只报名二代或三代） 芒种“忙种”，不负光阴 发乎于情止乎于怕 怎么才能拥有他？ 易生信暑期黑马集训营 - 收获一“夏” 助力CNS 学术论文统计图插图绘制 微生物组——宏基因组分析专题培训开课啦！ 学术论文统计图插图绘制第二期，开始报名啦！ 易生信 转录组专题分析第4期开课啦 生信分析Linux基础和R绘图——玩转公司反馈的测序报告和数据表！ 从Nature, Science文章看易生信培训的重要性 啥是佩奇？ 这么高配的培训班集齐了CNS，不想来看看？ NBT之后再发Science，这个公众号主编不一般 DNA metabarcoding: 条形码的追踪饮食摄入之路 11.30 永久链接 http://blog.genesino.com/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
